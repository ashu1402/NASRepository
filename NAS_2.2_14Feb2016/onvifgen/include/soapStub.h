/* soapStub.h
   Generated by gSOAP 2.8.27 from onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_WSDD_2009
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsdd	"http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_tev	"http://www.onvif.org/ver10/events/wsdl"
#define SOAP_NAMESPACE_OF_wsrfrw	"http://docs.oasis-open.org/wsrf/rw-2"
#define SOAP_NAMESPACE_OF_wsrfr	"http://docs.oasis-open.org/wsrf/r-2"
#define SOAP_NAMESPACE_OF_tls	"http://www.onvif.org/ver10/display/wsdl"
#define SOAP_NAMESPACE_OF_tmd	"http://www.onvif.org/ver10/deviceIO/wsdl"
#define SOAP_NAMESPACE_OF_timg	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_trt	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_tptz	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_trv	"http://www.onvif.org/ver10/receiver/wsdl"
#define SOAP_NAMESPACE_OF_trc	"http://www.onvif.org/ver10/recording/wsdl"
#define SOAP_NAMESPACE_OF_tse	"http://www.onvif.org/ver10/search/wsdl"
#define SOAP_NAMESPACE_OF_tdn	"http://www.onvif.org/ver10/network/wsdl"
#define SOAP_NAMESPACE_OF_trp	"http://www.onvif.org/ver10/replay/wsdl"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20827
# error "GSOAP VERSION 20827 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (8)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault
{
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:98 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (10)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum
{
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (83)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType
{
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* wsa5.h:94 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (112)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType
{
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:102 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (113)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType
{
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:252 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (131)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter
{
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* wsdd.h:109 */
#ifndef SOAP_TYPE_wsdd__FaultCodeType
#define SOAP_TYPE_wsdd__FaultCodeType (162)
/* wsdd:FaultCodeType */
enum wsdd__FaultCodeType
{
	wsdd__MatchingRuleNotSupported = 0
};
#endif

/* onvif.h:4078 */
#ifndef SOAP_TYPE_tds__StorageType
#define SOAP_TYPE_tds__StorageType (1397)
/* tds:StorageType */
enum tds__StorageType
{
	tds__StorageType__NFS = 0,
	tds__StorageType__CIFS = 1,
	tds__StorageType__CDMI = 2
};
#endif

/* onvif.h:4144 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (1403)
/* tt:RotateMode */
enum tt__RotateMode
{
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* onvif.h:4161 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (1405)
/* tt:VideoEncoding */
enum tt__VideoEncoding
{
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* onvif.h:4178 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (1407)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile
{
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* onvif.h:4194 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (1409)
/* tt:H264Profile */
enum tt__H264Profile
{
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* onvif.h:4215 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (1411)
/* tt:VideoEncodingMimeNames */
enum tt__VideoEncodingMimeNames
{
	tt__VideoEncodingMimeNames__JPEG = 0,
	tt__VideoEncodingMimeNames__MPV4_ES = 1,
	tt__VideoEncodingMimeNames__H264 = 2,
	tt__VideoEncodingMimeNames__H265 = 3
};
#endif

/* onvif.h:4233 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (1413)
/* tt:VideoEncodingProfiles */
enum tt__VideoEncodingProfiles
{
	tt__VideoEncodingProfiles__Simple = 0,
	tt__VideoEncodingProfiles__AdvancedSimple = 1,
	tt__VideoEncodingProfiles__Baseline = 2,
	tt__VideoEncodingProfiles__Main = 3,
	tt__VideoEncodingProfiles__Main10 = 4,
	tt__VideoEncodingProfiles__Extended = 5,
	tt__VideoEncodingProfiles__High = 6
};
#endif

/* onvif.h:4254 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (1415)
/* tt:AudioEncoding */
enum tt__AudioEncoding
{
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* onvif.h:4274 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (1417)
/* tt:AudioEncodingMimeNames */
enum tt__AudioEncodingMimeNames
{
	tt__AudioEncodingMimeNames__PCMU = 0,
	tt__AudioEncodingMimeNames__G726 = 1,
	tt__AudioEncodingMimeNames__MP4A_LATM = 2
};
#endif

/* onvif.h:4291 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (1419)
/* tt:MetadataCompressionType */
enum tt__MetadataCompressionType
{
	tt__MetadataCompressionType__None = 0,
	tt__MetadataCompressionType__GZIP = 1,
	tt__MetadataCompressionType__EXI = 2
};
#endif

/* onvif.h:4308 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (1421)
/* tt:StreamType */
enum tt__StreamType
{
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* onvif.h:4324 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (1423)
/* tt:TransportProtocol */
enum tt__TransportProtocol
{
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* onvif.h:4342 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (1425)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition
{
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* onvif.h:4358 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (1427)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode
{
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* onvif.h:4386 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (1431)
/* tt:Duplex */
enum tt__Duplex
{
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* onvif.h:4416 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (1435)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration
{
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* onvif.h:4434 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (1437)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType
{
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* onvif.h:4451 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (1439)
/* tt:NetworkHostType */
enum tt__NetworkHostType
{
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* onvif.h:4501 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (1447)
/* tt:IPType */
enum tt__IPType
{
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* onvif.h:4539 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (1453)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType
{
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* onvif.h:4555 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (1455)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType
{
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* onvif.h:4584 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (1459)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode
{
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* onvif.h:4601 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (1461)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode
{
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* onvif.h:4620 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (1463)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher
{
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* onvif.h:4662 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (1469)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength
{
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* onvif.h:4682 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (1471)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite
{
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* onvif.h:4700 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (1473)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory
{
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* onvif.h:4724 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (1475)
/* tt:SystemLogType */
enum tt__SystemLogType
{
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* onvif.h:4749 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (1477)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType
{
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* onvif.h:4771 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (1479)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType
{
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* onvif.h:4793 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (1481)
/* tt:UserLevel */
enum tt__UserLevel
{
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* onvif.h:4812 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (1483)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState
{
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* onvif.h:4828 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (1485)
/* tt:RelayIdleState */
enum tt__RelayIdleState
{
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* onvif.h:4844 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (1487)
/* tt:RelayMode */
enum tt__RelayMode
{
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* onvif.h:4860 */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (1489)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState
{
	tt__DigitalIdleState__closed = 0,
	tt__DigitalIdleState__open = 1
};
#endif

/* onvif.h:4876 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (1491)
/* tt:EFlipMode */
enum tt__EFlipMode
{
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* onvif.h:4893 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (1493)
/* tt:ReverseMode */
enum tt__ReverseMode
{
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* onvif.h:4923 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1497)
/* tt:MoveStatus */
enum tt__MoveStatus
{
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/* onvif.h:4940 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (1499)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState
{
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* onvif.h:4958 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (1501)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection
{
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* onvif.h:4975 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (1503)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation
{
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* onvif.h:4993 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (1505)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode
{
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* onvif.h:5009 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (1507)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode
{
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* onvif.h:5028 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (1509)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode
{
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* onvif.h:5050 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (1511)
/* tt:ExposurePriority */
enum tt__ExposurePriority
{
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* onvif.h:5066 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (1513)
/* tt:ExposureMode */
enum tt__ExposureMode
{
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* onvif.h:5082 */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (1515)
/* tt:Enabled */
enum tt__Enabled
{
	tt__Enabled__ENABLED = 0,
	tt__Enabled__DISABLED = 1
};
#endif

/* onvif.h:5098 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (1517)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode
{
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* onvif.h:5114 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (1519)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode
{
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* onvif.h:5131 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (1521)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode
{
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* onvif.h:5149 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (1523)
/* tt:IrCutFilterAutoBoundaryType */
enum tt__IrCutFilterAutoBoundaryType
{
	tt__IrCutFilterAutoBoundaryType__Common = 0,
	tt__IrCutFilterAutoBoundaryType__ToOn = 1,
	tt__IrCutFilterAutoBoundaryType__ToOff = 2,
	tt__IrCutFilterAutoBoundaryType__Extended = 3
};
#endif

/* onvif.h:5167 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (1525)
/* tt:ToneCompensationMode */
enum tt__ToneCompensationMode
{
	tt__ToneCompensationMode__OFF = 0,
	tt__ToneCompensationMode__ON = 1,
	tt__ToneCompensationMode__AUTO = 2
};
#endif

/* onvif.h:5184 */
#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (1527)
/* tt:DefoggingMode */
enum tt__DefoggingMode
{
	tt__DefoggingMode__OFF = 0,
	tt__DefoggingMode__ON = 1,
	tt__DefoggingMode__AUTO = 2
};
#endif

/* onvif.h:5212 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (1531)
/* tt:PropertyOperation */
enum tt__PropertyOperation
{
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* onvif.h:5229 */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (1533)
/* tt:Direction */
enum tt__Direction
{
	tt__Direction__Left = 0,
	tt__Direction__Right = 1,
	tt__Direction__Any = 2
};
#endif

/* onvif.h:5246 */
#ifndef SOAP_TYPE_tt__ClassType
#define SOAP_TYPE_tt__ClassType (1535)
/* tt:ClassType */
enum tt__ClassType
{
	tt__ClassType__Animal = 0,
	tt__ClassType__Face = 1,
	tt__ClassType__Human = 2,
	tt__ClassType__Vehical = 3,
	tt__ClassType__Other = 4
};
#endif

/* onvif.h:5268 */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (1537)
/* tt:ReceiverMode */
enum tt__ReceiverMode
{
	tt__ReceiverMode__AutoConnect = 0,
	tt__ReceiverMode__AlwaysConnect = 1,
	tt__ReceiverMode__NeverConnect = 2,
	tt__ReceiverMode__Unknown = 3
};
#endif

/* onvif.h:5301 */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (1539)
/* tt:ReceiverState */
enum tt__ReceiverState
{
	tt__ReceiverState__NotConnected = 0,
	tt__ReceiverState__Connecting = 1,
	tt__ReceiverState__Connected = 2,
	tt__ReceiverState__Unknown = 3
};
#endif

/* onvif.h:5353 */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (1545)
/* tt:SearchState */
enum tt__SearchState
{
	tt__SearchState__Queued = 0,
	tt__SearchState__Searching = 1,
	tt__SearchState__Completed = 2,
	tt__SearchState__Unknown = 3
};
#endif

/* onvif.h:5383 */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (1547)
/* tt:RecordingStatus */
enum tt__RecordingStatus
{
	tt__RecordingStatus__Initiated = 0,
	tt__RecordingStatus__Recording = 1,
	tt__RecordingStatus__Stopped = 2,
	tt__RecordingStatus__Removing = 3,
	tt__RecordingStatus__Removed = 4,
	tt__RecordingStatus__Unknown = 5
};
#endif

/* onvif.h:5406 */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (1549)
/* tt:TrackType */
enum tt__TrackType
{
	tt__TrackType__Video = 0,
	tt__TrackType__Audio = 1,
	tt__TrackType__Metadata = 2,
	tt__TrackType__Extended = 3
};
#endif

/* onvif.h:5449 */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (1555)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation
{
	tt__ModeOfOperation__Idle = 0,
	tt__ModeOfOperation__Active = 1,
	tt__ModeOfOperation__Unknown = 2
};
#endif

/* onvif.h:5484 */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (1559)
/* tt:OSDType */
enum tt__OSDType
{
	tt__OSDType__Text = 0,
	tt__OSDType__Image = 1,
	tt__OSDType__Extended = 2
};
#endif

/* onvif.h:5622 */
#ifndef SOAP_TYPE_tmd__SerialPortType
#define SOAP_TYPE_tmd__SerialPortType (1567)
/* tmd:SerialPortType */
enum tmd__SerialPortType
{
	tmd__SerialPortType__RS232 = 0,
	tmd__SerialPortType__RS422HalfDuplex = 1,
	tmd__SerialPortType__RS422FullDuplex = 2,
	tmd__SerialPortType__RS485HalfDuplex = 3,
	tmd__SerialPortType__RS485FullDuplex = 4,
	tmd__SerialPortType__Generic = 5
};
#endif

/* onvif.h:5645 */
#ifndef SOAP_TYPE_tmd__ParityBit
#define SOAP_TYPE_tmd__ParityBit (1569)
/* tmd:ParityBit */
enum tmd__ParityBit
{
	tmd__ParityBit__None = 0,
	tmd__ParityBit__Even = 1,
	tmd__ParityBit__Odd = 2,
	tmd__ParityBit__Mark = 3,
	tmd__ParityBit__Space = 4,
	tmd__ParityBit__Extended = 5
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (201)
typedef LONG64 xsd__duration;
#endif
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (196)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:76 */
struct _wsse__UsernameToken;	/* wsse.h:114 */
struct _wsse__BinarySecurityToken;	/* wsse.h:125 */
struct _wsse__Reference;	/* wsse.h:135 */
struct _wsse__Embedded;	/* wsse.h:143 */
struct _wsse__KeyIdentifier;	/* wsse.h:152 */
struct _wsse__SecurityTokenReference;	/* wsse.h:162 */
struct ds__SignatureType;	/* ds.h:47 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:74 */
struct ds__KeyInfoType;	/* ds.h:49 */
struct ds__SignedInfoType;	/* ds.h:47 */
struct ds__CanonicalizationMethodType;	/* ds.h:60 */
struct ds__SignatureMethodType;	/* ds.h:63 */
struct ds__ReferenceType;	/* ds.h:66 */
struct ds__TransformsType;	/* ds.h:69 */
struct ds__DigestMethodType;	/* ds.h:80 */
struct ds__KeyValueType;	/* ds.h:86 */
struct ds__RetrievalMethodType;	/* ds.h:87 */
struct ds__X509DataType;	/* wsse.h:165 */
struct ds__X509IssuerSerialType;	/* ds.h:103 */
struct ds__DSAKeyValueType;	/* ds.h:124 */
struct ds__RSAKeyValueType;	/* ds.h:127 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct _wsse__Security;	/* wsse.h:177 */
struct _wsse__Password;	/* wsse.h:115 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:63 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:66 */
struct wsa5__MetadataType;	/* wsa5.h:69 */
struct wsa5__ProblemActionType;	/* wsa5.h:84 */
struct wsa5__RelatesToType;	/* wsa5.h:72 */
struct chan__ChannelInstanceType;	/* wsa5.h:258 */
struct wsdd__HelloType;	/* wsdd.h:55 */
struct wsdd__ByeType;	/* wsdd.h:58 */
struct wsdd__ProbeType;	/* wsdd.h:61 */
struct wsdd__ProbeMatchesType;	/* wsdd.h:64 */
struct wsdd__ProbeMatchType;	/* wsdd.h:67 */
struct wsdd__ResolveType;	/* wsdd.h:70 */
struct wsdd__ResolveMatchesType;	/* wsdd.h:73 */
struct wsdd__ResolveMatchType;	/* wsdd.h:76 */
struct wsdd__SecurityType;	/* wsdd.h:82 */
struct wsdd__SigType;	/* wsdd.h:85 */
struct wsdd__ScopesType;	/* wsdd.h:79 */
struct wsdd__AppSequenceType;	/* wsdd.h:88 */
struct __wsdd__Hello;	/* wsdx.h:67 */
struct __wsdd__Bye;	/* wsdx.h:76 */
struct __wsdd__Probe;	/* wsdx.h:85 */
struct __wsdd__ProbeMatches;	/* wsdx.h:94 */
struct __wsdd__Resolve;	/* wsdx.h:103 */
struct __wsdd__ResolveMatches;	/* wsdx.h:112 */
struct _xop__Include;	/* xop.h:58 */
class xsd__anyType;	/* onvif.h:246 */
struct SOAP_ENV__Envelope;	/* onvif.h:249 */
class xsd__base64Binary;	/* onvif.h:255 */
class xsd__hexBinary;	/* onvif.h:266 */
class xsd__NCName_;	/* onvif.h:274 */
class xsd__QName_;	/* onvif.h:281 */
class xsd__anySimpleType_;	/* onvif.h:291 */
class xsd__anyURI_;	/* onvif.h:301 */
class xsd__base64Binary_;	/* onvif.h:308 */
class xsd__boolean;	/* onvif.h:315 */
class xsd__dateTime;	/* onvif.h:322 */
class xsd__duration_;	/* onvif.h:329 */
class xsd__float;	/* onvif.h:336 */
class xsd__hexBinary_;	/* onvif.h:343 */
class xsd__int;	/* onvif.h:350 */
class xsd__integer_;	/* onvif.h:360 */
class xsd__nonNegativeInteger_;	/* onvif.h:370 */
class xsd__string;	/* onvif.h:377 */
class xsd__token_;	/* onvif.h:387 */
class tds__StorageType_;	/* onvif.h:4095 */
class tt__ReferenceToken__;	/* onvif.h:4120 */
class tt__Name__;	/* onvif.h:4135 */
class tt__RotateMode_;	/* onvif.h:4152 */
class tt__VideoEncoding_;	/* onvif.h:4169 */
class tt__Mpeg4Profile_;	/* onvif.h:4185 */
class tt__H264Profile_;	/* onvif.h:4203 */
class tt__VideoEncodingMimeNames_;	/* onvif.h:4224 */
class tt__VideoEncodingProfiles_;	/* onvif.h:4245 */
class tt__AudioEncoding_;	/* onvif.h:4262 */
class tt__AudioEncodingMimeNames_;	/* onvif.h:4282 */
class tt__MetadataCompressionType_;	/* onvif.h:4299 */
class tt__StreamType_;	/* onvif.h:4315 */
class tt__TransportProtocol_;	/* onvif.h:4333 */
class tt__ScopeDefinition_;	/* onvif.h:4349 */
class tt__DiscoveryMode_;	/* onvif.h:4365 */
class tt__NetworkInterfaceConfigPriority__;	/* onvif.h:4377 */
class tt__Duplex_;	/* onvif.h:4393 */
class tt__IANA_IfTypes__;	/* onvif.h:4407 */
class tt__IPv6DHCPConfiguration_;	/* onvif.h:4425 */
class tt__NetworkProtocolType_;	/* onvif.h:4442 */
class tt__NetworkHostType_;	/* onvif.h:4459 */
class tt__IPv4Address__;	/* onvif.h:4470 */
class tt__IPv6Address__;	/* onvif.h:4481 */
class tt__HwAddress__;	/* onvif.h:4492 */
class tt__IPType_;	/* onvif.h:4508 */
class tt__DNSName__;	/* onvif.h:4519 */
class tt__Domain__;	/* onvif.h:4530 */
class tt__IPAddressFilterType_;	/* onvif.h:4546 */
class tt__DynamicDNSType_;	/* onvif.h:4563 */
class tt__Dot11SSIDType__;	/* onvif.h:4575 */
class tt__Dot11StationMode_;	/* onvif.h:4592 */
class tt__Dot11SecurityMode_;	/* onvif.h:4611 */
class tt__Dot11Cipher_;	/* onvif.h:4629 */
class tt__Dot11PSK__;	/* onvif.h:4641 */
class tt__Dot11PSKPassphrase__;	/* onvif.h:4653 */
class tt__Dot11SignalStrength_;	/* onvif.h:4673 */
class tt__Dot11AuthAndMangementSuite_;	/* onvif.h:4691 */
class tt__CapabilityCategory_;	/* onvif.h:4712 */
class tt__SystemLogType_;	/* onvif.h:4737 */
class tt__FactoryDefaultType_;	/* onvif.h:4762 */
class tt__SetDateTimeType_;	/* onvif.h:4784 */
class tt__UserLevel_;	/* onvif.h:4803 */
class tt__RelayLogicalState_;	/* onvif.h:4819 */
class tt__RelayIdleState_;	/* onvif.h:4835 */
class tt__RelayMode_;	/* onvif.h:4851 */
class tt__DigitalIdleState_;	/* onvif.h:4867 */
class tt__EFlipMode_;	/* onvif.h:4884 */
class tt__ReverseMode_;	/* onvif.h:4902 */
class tt__AuxiliaryData__;	/* onvif.h:4914 */
class tt__MoveStatus_;	/* onvif.h:4931 */
class tt__PTZPresetTourState_;	/* onvif.h:4949 */
class tt__PTZPresetTourDirection_;	/* onvif.h:4966 */
class tt__PTZPresetTourOperation_;	/* onvif.h:4984 */
class tt__AutoFocusMode_;	/* onvif.h:5000 */
class tt__WideDynamicMode_;	/* onvif.h:5016 */
class tt__BacklightCompensationMode_;	/* onvif.h:5041 */
class tt__ExposurePriority_;	/* onvif.h:5057 */
class tt__ExposureMode_;	/* onvif.h:5073 */
class tt__Enabled_;	/* onvif.h:5089 */
class tt__WhiteBalanceMode_;	/* onvif.h:5105 */
class tt__IrCutFilterMode_;	/* onvif.h:5122 */
class tt__ImageStabilizationMode_;	/* onvif.h:5140 */
class tt__IrCutFilterAutoBoundaryType_;	/* onvif.h:5158 */
class tt__ToneCompensationMode_;	/* onvif.h:5175 */
class tt__DefoggingMode_;	/* onvif.h:5192 */
class tt__TopicNamespaceLocation__;	/* onvif.h:5203 */
class tt__PropertyOperation_;	/* onvif.h:5220 */
class tt__Direction_;	/* onvif.h:5237 */
class tt__ClassType_;	/* onvif.h:5256 */
class tt__ReceiverMode_;	/* onvif.h:5289 */
class tt__ReceiverState_;	/* onvif.h:5322 */
class tt__Description__;	/* onvif.h:5333 */
class tt__XPathExpression__;	/* onvif.h:5344 */
class tt__SearchState_;	/* onvif.h:5374 */
class tt__RecordingStatus_;	/* onvif.h:5397 */
class tt__TrackType_;	/* onvif.h:5418 */
class tt__RecordingJobMode__;	/* onvif.h:5429 */
class tt__RecordingJobState__;	/* onvif.h:5440 */
class tt__ModeOfOperation_;	/* onvif.h:5460 */
class tt__AudioClassType__;	/* onvif.h:5475 */
class tt__OSDType_;	/* onvif.h:5492 */
class wstop__FullTopicExpression__;	/* onvif.h:5531 */
class wstop__ConcreteTopicExpression__;	/* onvif.h:5547 */
class wstop__SimpleTopicExpression__;	/* onvif.h:5562 */
class tmd__SerialPortType_;	/* onvif.h:5633 */
class tmd__ParityBit_;	/* onvif.h:5656 */
class tt__ReceiverReference__;	/* onvif.h:5731 */
class tt__RecordingReference__;	/* onvif.h:5742 */
class tt__TrackReference__;	/* onvif.h:5753 */
class tt__JobToken__;	/* onvif.h:5764 */
class tt__RecordingJobReference__;	/* onvif.h:5775 */
class _tds__Service_Capabilities;	/* onvif.h:5958 */
class tds__Service;	/* onvif.h:405 */
class tds__DeviceServiceCapabilities;	/* onvif.h:408 */
class tds__NetworkCapabilities;	/* onvif.h:411 */
class tds__SecurityCapabilities;	/* onvif.h:414 */
class tds__SystemCapabilities;	/* onvif.h:417 */
class tds__MiscCapabilities;	/* onvif.h:420 */
class _tds__UserCredential_Extension;	/* onvif.h:6340 */
class tds__UserCredential;	/* onvif.h:423 */
class _tds__StorageConfigurationData_Extension;	/* onvif.h:6391 */
class tds__StorageConfigurationData;	/* onvif.h:426 */
class _tds__GetServices;	/* onvif.h:432 */
class _tds__GetServicesResponse;	/* onvif.h:435 */
class _tds__GetServiceCapabilities;	/* onvif.h:438 */
class _tds__GetServiceCapabilitiesResponse;	/* onvif.h:441 */
class _tds__GetDeviceInformation;	/* onvif.h:444 */
class _tds__GetDeviceInformationResponse;	/* onvif.h:447 */
class _tds__SetSystemDateAndTime;	/* onvif.h:450 */
class _tds__SetSystemDateAndTimeResponse;	/* onvif.h:453 */
class _tds__GetSystemDateAndTime;	/* onvif.h:456 */
class _tds__GetSystemDateAndTimeResponse;	/* onvif.h:459 */
class _tds__SetSystemFactoryDefault;	/* onvif.h:462 */
class _tds__SetSystemFactoryDefaultResponse;	/* onvif.h:465 */
class _tds__UpgradeSystemFirmware;	/* onvif.h:468 */
class _tds__UpgradeSystemFirmwareResponse;	/* onvif.h:471 */
class _tds__SystemReboot;	/* onvif.h:474 */
class _tds__SystemRebootResponse;	/* onvif.h:477 */
class _tds__RestoreSystem;	/* onvif.h:480 */
class _tds__RestoreSystemResponse;	/* onvif.h:483 */
class _tds__GetSystemBackup;	/* onvif.h:486 */
class _tds__GetSystemBackupResponse;	/* onvif.h:489 */
class _tds__GetSystemSupportInformation;	/* onvif.h:492 */
class _tds__GetSystemSupportInformationResponse;	/* onvif.h:495 */
class _tds__GetSystemLog;	/* onvif.h:498 */
class _tds__GetSystemLogResponse;	/* onvif.h:501 */
class _tds__GetScopes;	/* onvif.h:504 */
class _tds__GetScopesResponse;	/* onvif.h:507 */
class _tds__SetScopes;	/* onvif.h:510 */
class _tds__SetScopesResponse;	/* onvif.h:513 */
class _tds__AddScopes;	/* onvif.h:516 */
class _tds__AddScopesResponse;	/* onvif.h:519 */
class _tds__RemoveScopes;	/* onvif.h:522 */
class _tds__RemoveScopesResponse;	/* onvif.h:525 */
class _tds__GetDiscoveryMode;	/* onvif.h:528 */
class _tds__GetDiscoveryModeResponse;	/* onvif.h:531 */
class _tds__SetDiscoveryMode;	/* onvif.h:534 */
class _tds__SetDiscoveryModeResponse;	/* onvif.h:537 */
class _tds__GetRemoteDiscoveryMode;	/* onvif.h:540 */
class _tds__GetRemoteDiscoveryModeResponse;	/* onvif.h:543 */
class _tds__SetRemoteDiscoveryMode;	/* onvif.h:546 */
class _tds__SetRemoteDiscoveryModeResponse;	/* onvif.h:549 */
class _tds__GetDPAddresses;	/* onvif.h:552 */
class _tds__GetDPAddressesResponse;	/* onvif.h:555 */
class _tds__SetDPAddresses;	/* onvif.h:558 */
class _tds__SetDPAddressesResponse;	/* onvif.h:561 */
class _tds__GetEndpointReference;	/* onvif.h:564 */
class _tds__GetEndpointReferenceResponse;	/* onvif.h:567 */
class _tds__GetRemoteUser;	/* onvif.h:570 */
class _tds__GetRemoteUserResponse;	/* onvif.h:573 */
class _tds__SetRemoteUser;	/* onvif.h:576 */
class _tds__SetRemoteUserResponse;	/* onvif.h:579 */
class _tds__GetUsers;	/* onvif.h:582 */
class _tds__GetUsersResponse;	/* onvif.h:585 */
class _tds__CreateUsers;	/* onvif.h:588 */
class _tds__CreateUsersResponse;	/* onvif.h:591 */
class _tds__DeleteUsers;	/* onvif.h:594 */
class _tds__DeleteUsersResponse;	/* onvif.h:597 */
class _tds__SetUser;	/* onvif.h:600 */
class _tds__SetUserResponse;	/* onvif.h:603 */
class _tds__GetWsdlUrl;	/* onvif.h:606 */
class _tds__GetWsdlUrlResponse;	/* onvif.h:609 */
class _tds__GetCapabilities;	/* onvif.h:612 */
class _tds__GetCapabilitiesResponse;	/* onvif.h:615 */
class _tds__GetHostname;	/* onvif.h:618 */
class _tds__GetHostnameResponse;	/* onvif.h:621 */
class _tds__SetHostname;	/* onvif.h:624 */
class _tds__SetHostnameResponse;	/* onvif.h:627 */
class _tds__SetHostnameFromDHCP;	/* onvif.h:630 */
class _tds__SetHostnameFromDHCPResponse;	/* onvif.h:633 */
class _tds__GetDNS;	/* onvif.h:636 */
class _tds__GetDNSResponse;	/* onvif.h:639 */
class _tds__SetDNS;	/* onvif.h:642 */
class _tds__SetDNSResponse;	/* onvif.h:645 */
class _tds__GetNTP;	/* onvif.h:648 */
class _tds__GetNTPResponse;	/* onvif.h:651 */
class _tds__SetNTP;	/* onvif.h:654 */
class _tds__SetNTPResponse;	/* onvif.h:657 */
class _tds__GetDynamicDNS;	/* onvif.h:660 */
class _tds__GetDynamicDNSResponse;	/* onvif.h:663 */
class _tds__SetDynamicDNS;	/* onvif.h:666 */
class _tds__SetDynamicDNSResponse;	/* onvif.h:669 */
class _tds__GetNetworkInterfaces;	/* onvif.h:672 */
class _tds__GetNetworkInterfacesResponse;	/* onvif.h:675 */
class _tds__SetNetworkInterfaces;	/* onvif.h:678 */
class _tds__SetNetworkInterfacesResponse;	/* onvif.h:681 */
class _tds__GetNetworkProtocols;	/* onvif.h:684 */
class _tds__GetNetworkProtocolsResponse;	/* onvif.h:687 */
class _tds__SetNetworkProtocols;	/* onvif.h:690 */
class _tds__SetNetworkProtocolsResponse;	/* onvif.h:693 */
class _tds__GetNetworkDefaultGateway;	/* onvif.h:696 */
class _tds__GetNetworkDefaultGatewayResponse;	/* onvif.h:699 */
class _tds__SetNetworkDefaultGateway;	/* onvif.h:702 */
class _tds__SetNetworkDefaultGatewayResponse;	/* onvif.h:705 */
class _tds__GetZeroConfiguration;	/* onvif.h:708 */
class _tds__GetZeroConfigurationResponse;	/* onvif.h:711 */
class _tds__SetZeroConfiguration;	/* onvif.h:714 */
class _tds__SetZeroConfigurationResponse;	/* onvif.h:717 */
class _tds__GetIPAddressFilter;	/* onvif.h:720 */
class _tds__GetIPAddressFilterResponse;	/* onvif.h:723 */
class _tds__SetIPAddressFilter;	/* onvif.h:726 */
class _tds__SetIPAddressFilterResponse;	/* onvif.h:729 */
class _tds__AddIPAddressFilter;	/* onvif.h:732 */
class _tds__AddIPAddressFilterResponse;	/* onvif.h:735 */
class _tds__RemoveIPAddressFilter;	/* onvif.h:738 */
class _tds__RemoveIPAddressFilterResponse;	/* onvif.h:741 */
class _tds__GetAccessPolicy;	/* onvif.h:744 */
class _tds__GetAccessPolicyResponse;	/* onvif.h:747 */
class _tds__SetAccessPolicy;	/* onvif.h:750 */
class _tds__SetAccessPolicyResponse;	/* onvif.h:753 */
class _tds__CreateCertificate;	/* onvif.h:756 */
class _tds__CreateCertificateResponse;	/* onvif.h:759 */
class _tds__GetCertificates;	/* onvif.h:762 */
class _tds__GetCertificatesResponse;	/* onvif.h:765 */
class _tds__GetCertificatesStatus;	/* onvif.h:768 */
class _tds__GetCertificatesStatusResponse;	/* onvif.h:771 */
class _tds__SetCertificatesStatus;	/* onvif.h:774 */
class _tds__SetCertificatesStatusResponse;	/* onvif.h:777 */
class _tds__DeleteCertificates;	/* onvif.h:780 */
class _tds__DeleteCertificatesResponse;	/* onvif.h:783 */
class _tds__GetPkcs10Request;	/* onvif.h:786 */
class _tds__GetPkcs10RequestResponse;	/* onvif.h:789 */
class _tds__LoadCertificates;	/* onvif.h:792 */
class _tds__LoadCertificatesResponse;	/* onvif.h:795 */
class _tds__GetClientCertificateMode;	/* onvif.h:798 */
class _tds__GetClientCertificateModeResponse;	/* onvif.h:801 */
class _tds__SetClientCertificateMode;	/* onvif.h:804 */
class _tds__SetClientCertificateModeResponse;	/* onvif.h:807 */
class _tds__GetCACertificates;	/* onvif.h:810 */
class _tds__GetCACertificatesResponse;	/* onvif.h:813 */
class _tds__LoadCertificateWithPrivateKey;	/* onvif.h:816 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* onvif.h:819 */
class _tds__GetCertificateInformation;	/* onvif.h:822 */
class _tds__GetCertificateInformationResponse;	/* onvif.h:825 */
class _tds__LoadCACertificates;	/* onvif.h:828 */
class _tds__LoadCACertificatesResponse;	/* onvif.h:831 */
class _tds__CreateDot1XConfiguration;	/* onvif.h:834 */
class _tds__CreateDot1XConfigurationResponse;	/* onvif.h:837 */
class _tds__SetDot1XConfiguration;	/* onvif.h:840 */
class _tds__SetDot1XConfigurationResponse;	/* onvif.h:843 */
class _tds__GetDot1XConfiguration;	/* onvif.h:846 */
class _tds__GetDot1XConfigurationResponse;	/* onvif.h:849 */
class _tds__GetDot1XConfigurations;	/* onvif.h:852 */
class _tds__GetDot1XConfigurationsResponse;	/* onvif.h:855 */
class _tds__DeleteDot1XConfiguration;	/* onvif.h:858 */
class _tds__DeleteDot1XConfigurationResponse;	/* onvif.h:861 */
class _tds__GetRelayOutputs;	/* onvif.h:864 */
class _tds__GetRelayOutputsResponse;	/* onvif.h:867 */
class _tds__SetRelayOutputSettings;	/* onvif.h:870 */
class _tds__SetRelayOutputSettingsResponse;	/* onvif.h:873 */
class _tds__SetRelayOutputState;	/* onvif.h:876 */
class _tds__SetRelayOutputStateResponse;	/* onvif.h:879 */
class _tds__SendAuxiliaryCommand;	/* onvif.h:882 */
class _tds__SendAuxiliaryCommandResponse;	/* onvif.h:885 */
class _tds__GetDot11Capabilities;	/* onvif.h:888 */
class _tds__GetDot11CapabilitiesResponse;	/* onvif.h:891 */
class _tds__GetDot11Status;	/* onvif.h:894 */
class _tds__GetDot11StatusResponse;	/* onvif.h:897 */
class _tds__ScanAvailableDot11Networks;	/* onvif.h:900 */
class _tds__ScanAvailableDot11NetworksResponse;	/* onvif.h:903 */
class _tds__GetSystemUris;	/* onvif.h:906 */
class _tds__GetSystemUrisResponse_Extension;	/* onvif.h:9946 */
class _tds__GetSystemUrisResponse;	/* onvif.h:909 */
class _tds__StartFirmwareUpgrade;	/* onvif.h:912 */
class _tds__StartFirmwareUpgradeResponse;	/* onvif.h:915 */
class _tds__StartSystemRestore;	/* onvif.h:918 */
class _tds__StartSystemRestoreResponse;	/* onvif.h:921 */
class _tds__GetStorageConfigurations;	/* onvif.h:924 */
class _tds__GetStorageConfigurationsResponse;	/* onvif.h:927 */
class _tds__CreateStorageConfiguration;	/* onvif.h:930 */
class _tds__CreateStorageConfigurationResponse;	/* onvif.h:933 */
class _tds__GetStorageConfiguration;	/* onvif.h:936 */
class _tds__GetStorageConfigurationResponse;	/* onvif.h:939 */
class _tds__SetStorageConfiguration;	/* onvif.h:942 */
class _tds__SetStorageConfigurationResponse;	/* onvif.h:945 */
class _tds__DeleteStorageConfiguration;	/* onvif.h:948 */
class _tds__DeleteStorageConfigurationResponse;	/* onvif.h:951 */
class tt__DeviceEntity;	/* onvif.h:954 */
class tt__IntRectangle;	/* onvif.h:957 */
class tt__IntRectangleRange;	/* onvif.h:960 */
class tt__IntRange;	/* onvif.h:963 */
class tt__FloatRange;	/* onvif.h:966 */
class tt__DurationRange;	/* onvif.h:969 */
class tt__IntList;	/* onvif.h:972 */
class tt__FloatList;	/* onvif.h:975 */
class tt__AnyHolder;	/* onvif.h:978 */
class tt__VideoSourceExtension;	/* onvif.h:984 */
class tt__VideoSourceExtension2;	/* onvif.h:987 */
class tt__Profile;	/* onvif.h:993 */
class tt__ProfileExtension;	/* onvif.h:996 */
class tt__ProfileExtension2;	/* onvif.h:999 */
class tt__ConfigurationEntity;	/* onvif.h:1002 */
class tt__VideoSourceConfigurationExtension;	/* onvif.h:1008 */
class tt__VideoSourceConfigurationExtension2;	/* onvif.h:1011 */
class tt__Rotate;	/* onvif.h:1014 */
class tt__RotateExtension;	/* onvif.h:1017 */
class tt__LensProjection;	/* onvif.h:1020 */
class tt__LensOffset;	/* onvif.h:1023 */
class tt__LensDescription;	/* onvif.h:1026 */
class tt__VideoSourceConfigurationOptions;	/* onvif.h:1029 */
class tt__VideoSourceConfigurationOptionsExtension;	/* onvif.h:1032 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* onvif.h:1035 */
class tt__RotateOptions;	/* onvif.h:1038 */
class tt__RotateOptionsExtension;	/* onvif.h:1041 */
class tt__VideoResolution;	/* onvif.h:1047 */
class tt__VideoRateControl;	/* onvif.h:1050 */
class tt__Mpeg4Configuration;	/* onvif.h:1053 */
class tt__H264Configuration;	/* onvif.h:1056 */
class tt__VideoEncoderConfigurationOptions;	/* onvif.h:1059 */
class tt__VideoEncoderOptionsExtension;	/* onvif.h:1062 */
class tt__VideoEncoderOptionsExtension2;	/* onvif.h:1065 */
class tt__JpegOptions;	/* onvif.h:1068 */
class tt__Mpeg4Options;	/* onvif.h:1074 */
class tt__H264Options;	/* onvif.h:1080 */
class tt__VideoResolution2;	/* onvif.h:1089 */
class tt__VideoRateControl2;	/* onvif.h:1092 */
class tt__VideoEncoder2ConfigurationOptions;	/* onvif.h:1095 */
class tt__AudioSourceConfigurationOptions;	/* onvif.h:1101 */
class tt__AudioSourceOptionsExtension;	/* onvif.h:1104 */
class tt__AudioEncoderConfigurationOptions;	/* onvif.h:1110 */
class tt__AudioEncoderConfigurationOption;	/* onvif.h:1113 */
class tt__AudioEncoder2ConfigurationOptions;	/* onvif.h:1119 */
class tt__MetadataConfigurationExtension;	/* onvif.h:1128 */
class tt__PTZFilter;	/* onvif.h:1131 */
class _tt__EventSubscription_SubscriptionPolicy;	/* onvif.h:11825 */
class tt__EventSubscription;	/* onvif.h:1134 */
class tt__MetadataConfigurationOptions;	/* onvif.h:1137 */
class tt__MetadataConfigurationOptionsExtension;	/* onvif.h:1140 */
class tt__MetadataConfigurationOptionsExtension2;	/* onvif.h:1143 */
class tt__PTZStatusFilterOptions;	/* onvif.h:1146 */
class tt__PTZStatusFilterOptionsExtension;	/* onvif.h:1149 */
class tt__VideoOutputExtension;	/* onvif.h:1155 */
class tt__VideoOutputConfigurationOptions;	/* onvif.h:1161 */
class tt__VideoDecoderConfigurationOptions;	/* onvif.h:1164 */
class tt__H264DecOptions;	/* onvif.h:1167 */
class tt__JpegDecOptions;	/* onvif.h:1170 */
class tt__Mpeg4DecOptions;	/* onvif.h:1173 */
class tt__VideoDecoderConfigurationOptionsExtension;	/* onvif.h:1176 */
class tt__AudioOutputConfigurationOptions;	/* onvif.h:1185 */
class tt__AudioDecoderConfigurationOptions;	/* onvif.h:1191 */
class tt__G711DecOptions;	/* onvif.h:1194 */
class tt__AACDecOptions;	/* onvif.h:1197 */
class tt__G726DecOptions;	/* onvif.h:1200 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* onvif.h:1203 */
class tt__MulticastConfiguration;	/* onvif.h:1206 */
class tt__StreamSetup;	/* onvif.h:1209 */
class tt__Transport;	/* onvif.h:1212 */
class tt__MediaUri;	/* onvif.h:1215 */
class tt__Scope;	/* onvif.h:1218 */
class tt__NetworkInterfaceExtension;	/* onvif.h:1224 */
class tt__Dot3Configuration;	/* onvif.h:1227 */
class tt__NetworkInterfaceExtension2;	/* onvif.h:1230 */
class tt__NetworkInterfaceLink;	/* onvif.h:1233 */
class tt__NetworkInterfaceConnectionSetting;	/* onvif.h:1236 */
class tt__NetworkInterfaceInfo;	/* onvif.h:1239 */
class tt__IPv6NetworkInterface;	/* onvif.h:1242 */
class tt__IPv4NetworkInterface;	/* onvif.h:1245 */
class tt__IPv4Configuration;	/* onvif.h:1248 */
class tt__IPv6Configuration;	/* onvif.h:1251 */
class tt__IPv6ConfigurationExtension;	/* onvif.h:1254 */
class tt__NetworkProtocol;	/* onvif.h:1257 */
class tt__NetworkProtocolExtension;	/* onvif.h:1260 */
class tt__NetworkHost;	/* onvif.h:1263 */
class tt__NetworkHostExtension;	/* onvif.h:1266 */
class tt__IPAddress;	/* onvif.h:1269 */
class tt__PrefixedIPv4Address;	/* onvif.h:1272 */
class tt__PrefixedIPv6Address;	/* onvif.h:1275 */
class tt__HostnameInformation;	/* onvif.h:1278 */
class tt__HostnameInformationExtension;	/* onvif.h:1281 */
class tt__DNSInformation;	/* onvif.h:1284 */
class tt__DNSInformationExtension;	/* onvif.h:1287 */
class tt__NTPInformation;	/* onvif.h:1290 */
class tt__NTPInformationExtension;	/* onvif.h:1293 */
class tt__DynamicDNSInformation;	/* onvif.h:1296 */
class tt__DynamicDNSInformationExtension;	/* onvif.h:1299 */
class tt__NetworkInterfaceSetConfiguration;	/* onvif.h:1302 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* onvif.h:1305 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* onvif.h:1308 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* onvif.h:1311 */
class tt__NetworkGateway;	/* onvif.h:1314 */
class tt__NetworkZeroConfiguration;	/* onvif.h:1317 */
class tt__NetworkZeroConfigurationExtension;	/* onvif.h:1320 */
class tt__NetworkZeroConfigurationExtension2;	/* onvif.h:1323 */
class tt__IPAddressFilter;	/* onvif.h:1326 */
class tt__IPAddressFilterExtension;	/* onvif.h:1329 */
class tt__Dot11Configuration;	/* onvif.h:1332 */
class tt__Dot11SecurityConfiguration;	/* onvif.h:1335 */
class tt__Dot11SecurityConfigurationExtension;	/* onvif.h:1338 */
class tt__Dot11PSKSet;	/* onvif.h:1341 */
class tt__Dot11PSKSetExtension;	/* onvif.h:1344 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* onvif.h:1347 */
class tt__Dot11Capabilities;	/* onvif.h:1350 */
class tt__Dot11Status;	/* onvif.h:1353 */
class tt__Dot11AvailableNetworks;	/* onvif.h:1356 */
class tt__Dot11AvailableNetworksExtension;	/* onvif.h:1359 */
class tt__Capabilities;	/* onvif.h:1362 */
class tt__CapabilitiesExtension;	/* onvif.h:1365 */
class tt__CapabilitiesExtension2;	/* onvif.h:1368 */
class tt__AnalyticsCapabilities;	/* onvif.h:1371 */
class tt__DeviceCapabilities;	/* onvif.h:1374 */
class tt__DeviceCapabilitiesExtension;	/* onvif.h:1377 */
class tt__EventCapabilities;	/* onvif.h:1380 */
class tt__IOCapabilities;	/* onvif.h:1383 */
class tt__IOCapabilitiesExtension;	/* onvif.h:1386 */
class tt__IOCapabilitiesExtension2;	/* onvif.h:1389 */
class tt__MediaCapabilities;	/* onvif.h:1392 */
class tt__MediaCapabilitiesExtension;	/* onvif.h:1395 */
class tt__RealTimeStreamingCapabilities;	/* onvif.h:1398 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* onvif.h:1401 */
class tt__ProfileCapabilities;	/* onvif.h:1404 */
class tt__NetworkCapabilities;	/* onvif.h:1407 */
class tt__NetworkCapabilitiesExtension;	/* onvif.h:1410 */
class tt__NetworkCapabilitiesExtension2;	/* onvif.h:1413 */
class tt__SecurityCapabilities;	/* onvif.h:1416 */
class tt__SecurityCapabilitiesExtension;	/* onvif.h:1419 */
class tt__SecurityCapabilitiesExtension2;	/* onvif.h:1422 */
class tt__SystemCapabilities;	/* onvif.h:1425 */
class tt__SystemCapabilitiesExtension;	/* onvif.h:1428 */
class tt__SystemCapabilitiesExtension2;	/* onvif.h:1431 */
class tt__OnvifVersion;	/* onvif.h:1434 */
class tt__ImagingCapabilities;	/* onvif.h:1437 */
class tt__PTZCapabilities;	/* onvif.h:1440 */
class tt__DeviceIOCapabilities;	/* onvif.h:1443 */
class tt__DisplayCapabilities;	/* onvif.h:1446 */
class tt__RecordingCapabilities;	/* onvif.h:1449 */
class tt__SearchCapabilities;	/* onvif.h:1452 */
class tt__ReplayCapabilities;	/* onvif.h:1455 */
class tt__ReceiverCapabilities;	/* onvif.h:1458 */
class tt__AnalyticsDeviceCapabilities;	/* onvif.h:1461 */
class tt__AnalyticsDeviceExtension;	/* onvif.h:1464 */
class tt__SystemLog;	/* onvif.h:1467 */
class tt__SupportInformation;	/* onvif.h:1470 */
class tt__BinaryData;	/* onvif.h:1473 */
class tt__AttachmentData;	/* onvif.h:1476 */
class tt__BackupFile;	/* onvif.h:1479 */
class tt__SystemLogUriList;	/* onvif.h:1482 */
class tt__SystemLogUri;	/* onvif.h:1485 */
class tt__SystemDateTime;	/* onvif.h:1488 */
class tt__SystemDateTimeExtension;	/* onvif.h:1491 */
class tt__DateTime;	/* onvif.h:1494 */
class tt__Date;	/* onvif.h:1497 */
class tt__Time;	/* onvif.h:1500 */
class tt__TimeZone;	/* onvif.h:1503 */
class tt__RemoteUser;	/* onvif.h:1506 */
class tt__User;	/* onvif.h:1509 */
class tt__UserExtension;	/* onvif.h:1512 */
class tt__CertificateGenerationParameters;	/* onvif.h:1515 */
class tt__CertificateGenerationParametersExtension;	/* onvif.h:1518 */
class tt__Certificate;	/* onvif.h:1521 */
class tt__CertificateStatus;	/* onvif.h:1524 */
class tt__CertificateWithPrivateKey;	/* onvif.h:1527 */
class tt__CertificateInformation;	/* onvif.h:1530 */
class tt__CertificateInformationExtension;	/* onvif.h:1536 */
class tt__Dot1XConfiguration;	/* onvif.h:1539 */
class tt__Dot1XConfigurationExtension;	/* onvif.h:1542 */
class tt__EAPMethodConfiguration;	/* onvif.h:1545 */
class tt__EapMethodExtension;	/* onvif.h:1548 */
class tt__TLSConfiguration;	/* onvif.h:1551 */
class tt__GenericEapPwdConfigurationExtension;	/* onvif.h:1554 */
class tt__RelayOutputSettings;	/* onvif.h:1557 */
class tt__PTZNodeExtension;	/* onvif.h:1569 */
class tt__PTZNodeExtension2;	/* onvif.h:1572 */
class tt__PTZPresetTourSupported;	/* onvif.h:1575 */
class tt__PTZPresetTourSupportedExtension;	/* onvif.h:1578 */
class tt__PTZConfigurationExtension;	/* onvif.h:1584 */
class tt__PTZConfigurationExtension2;	/* onvif.h:1587 */
class tt__PTControlDirection;	/* onvif.h:1590 */
class tt__PTControlDirectionExtension;	/* onvif.h:1593 */
class tt__EFlip;	/* onvif.h:1596 */
class tt__Reverse;	/* onvif.h:1599 */
class tt__PTZConfigurationOptions;	/* onvif.h:1602 */
class tt__PTZConfigurationOptions2;	/* onvif.h:1605 */
class tt__PTControlDirectionOptions;	/* onvif.h:1608 */
class tt__PTControlDirectionOptionsExtension;	/* onvif.h:1611 */
class tt__EFlipOptions;	/* onvif.h:1614 */
class tt__EFlipOptionsExtension;	/* onvif.h:1617 */
class tt__ReverseOptions;	/* onvif.h:1620 */
class tt__ReverseOptionsExtension;	/* onvif.h:1623 */
class tt__PanTiltLimits;	/* onvif.h:1626 */
class tt__ZoomLimits;	/* onvif.h:1629 */
class tt__PTZSpaces;	/* onvif.h:1632 */
class tt__PTZSpacesExtension;	/* onvif.h:1635 */
class tt__Space2DDescription;	/* onvif.h:1638 */
class tt__Space1DDescription;	/* onvif.h:1641 */
class tt__Vector2D;	/* onvif.h:1644 */
class tt__Vector1D;	/* onvif.h:1647 */
class tt__PTZVector;	/* onvif.h:1650 */
class tt__PTZSpeed;	/* onvif.h:1653 */
class tt__PTZStatus;	/* onvif.h:1656 */
class tt__PTZPreset;	/* onvif.h:1659 */
class tt__PTZMoveStatus;	/* onvif.h:1662 */
class tt__PresetTour;	/* onvif.h:1665 */
class tt__PTZPresetTourExtension;	/* onvif.h:1668 */
class tt__PTZPresetTourSpot;	/* onvif.h:1671 */
class tt__PTZPresetTourSpotExtension;	/* onvif.h:1674 */
union _tt__union_PTZPresetTourPresetDetail;	/* onvif.h:17397 */
class tt__PTZPresetTourPresetDetail;	/* onvif.h:1677 */
class tt__PTZPresetTourTypeExtension;	/* onvif.h:1680 */
class tt__PTZPresetTourStatus;	/* onvif.h:1683 */
class tt__PTZPresetTourStatusExtension;	/* onvif.h:1686 */
class tt__PTZPresetTourStartingCondition;	/* onvif.h:1689 */
class tt__PTZPresetTourStartingConditionExtension;	/* onvif.h:1692 */
class tt__PTZPresetTourOptions;	/* onvif.h:1695 */
class tt__PTZPresetTourSpotOptions;	/* onvif.h:1698 */
class tt__PTZPresetTourPresetDetailOptions;	/* onvif.h:1701 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* onvif.h:1704 */
class tt__PTZPresetTourStartingConditionOptions;	/* onvif.h:1707 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* onvif.h:1710 */
class tt__ImagingStatus;	/* onvif.h:1713 */
class tt__FocusStatus;	/* onvif.h:1716 */
class tt__FocusConfiguration;	/* onvif.h:1719 */
class tt__ImagingSettings;	/* onvif.h:1722 */
class tt__ImagingSettingsExtension;	/* onvif.h:1725 */
class tt__Exposure;	/* onvif.h:1728 */
class tt__WideDynamicRange;	/* onvif.h:1731 */
class tt__BacklightCompensation;	/* onvif.h:1734 */
class tt__ImagingOptions;	/* onvif.h:1737 */
class tt__WideDynamicRangeOptions;	/* onvif.h:1740 */
class tt__BacklightCompensationOptions;	/* onvif.h:1743 */
class tt__FocusOptions;	/* onvif.h:1746 */
class tt__ExposureOptions;	/* onvif.h:1749 */
class tt__WhiteBalanceOptions;	/* onvif.h:1752 */
class tt__FocusMove;	/* onvif.h:1755 */
class tt__AbsoluteFocus;	/* onvif.h:1758 */
class tt__RelativeFocus;	/* onvif.h:1761 */
class tt__ContinuousFocus;	/* onvif.h:1764 */
class tt__MoveOptions;	/* onvif.h:1767 */
class tt__AbsoluteFocusOptions;	/* onvif.h:1770 */
class tt__RelativeFocusOptions;	/* onvif.h:1773 */
class tt__ContinuousFocusOptions;	/* onvif.h:1776 */
class tt__WhiteBalance;	/* onvif.h:1779 */
class tt__ImagingStatus20;	/* onvif.h:1782 */
class tt__ImagingStatus20Extension;	/* onvif.h:1785 */
class tt__FocusStatus20;	/* onvif.h:1788 */
class tt__FocusStatus20Extension;	/* onvif.h:1791 */
class tt__ImagingSettings20;	/* onvif.h:1794 */
class tt__ImagingSettingsExtension20;	/* onvif.h:1797 */
class tt__ImagingSettingsExtension202;	/* onvif.h:1800 */
class tt__ImagingSettingsExtension203;	/* onvif.h:1803 */
class tt__ImagingSettingsExtension204;	/* onvif.h:1806 */
class tt__ImageStabilization;	/* onvif.h:1809 */
class tt__ImageStabilizationExtension;	/* onvif.h:1812 */
class tt__IrCutFilterAutoAdjustment;	/* onvif.h:1815 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* onvif.h:1818 */
class tt__WideDynamicRange20;	/* onvif.h:1821 */
class tt__BacklightCompensation20;	/* onvif.h:1824 */
class tt__Exposure20;	/* onvif.h:1827 */
class tt__ToneCompensation;	/* onvif.h:1830 */
class tt__ToneCompensationExtension;	/* onvif.h:1833 */
class tt__Defogging;	/* onvif.h:1836 */
class tt__DefoggingExtension;	/* onvif.h:1839 */
class tt__NoiseReduction;	/* onvif.h:1842 */
class tt__ImagingOptions20;	/* onvif.h:1845 */
class tt__ImagingOptions20Extension;	/* onvif.h:1848 */
class tt__ImagingOptions20Extension2;	/* onvif.h:1851 */
class tt__ImagingOptions20Extension3;	/* onvif.h:1854 */
class tt__ImagingOptions20Extension4;	/* onvif.h:1857 */
class tt__ImageStabilizationOptions;	/* onvif.h:1860 */
class tt__ImageStabilizationOptionsExtension;	/* onvif.h:1863 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* onvif.h:1866 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvif.h:1869 */
class tt__WideDynamicRangeOptions20;	/* onvif.h:1872 */
class tt__BacklightCompensationOptions20;	/* onvif.h:1875 */
class tt__ExposureOptions20;	/* onvif.h:1878 */
class tt__MoveOptions20;	/* onvif.h:1881 */
class tt__RelativeFocusOptions20;	/* onvif.h:1884 */
class tt__WhiteBalance20;	/* onvif.h:1887 */
class tt__WhiteBalance20Extension;	/* onvif.h:1890 */
class tt__FocusConfiguration20;	/* onvif.h:1893 */
class tt__FocusConfiguration20Extension;	/* onvif.h:1896 */
class tt__WhiteBalanceOptions20;	/* onvif.h:1899 */
class tt__WhiteBalanceOptions20Extension;	/* onvif.h:1902 */
class tt__FocusOptions20;	/* onvif.h:1905 */
class tt__FocusOptions20Extension;	/* onvif.h:1908 */
class tt__ToneCompensationOptions;	/* onvif.h:1911 */
class tt__DefoggingOptions;	/* onvif.h:1914 */
class tt__NoiseReductionOptions;	/* onvif.h:1917 */
class tt__MessageExtension;	/* onvif.h:1920 */
class _tt__ItemList_SimpleItem;	/* onvif.h:20143 */
class _tt__ItemList_ElementItem;	/* onvif.h:20171 */
class tt__ItemList;	/* onvif.h:1923 */
class tt__ItemListExtension;	/* onvif.h:1926 */
class tt__MessageDescription;	/* onvif.h:1929 */
class tt__MessageDescriptionExtension;	/* onvif.h:1932 */
class _tt__ItemListDescription_SimpleItemDescription;	/* onvif.h:20322 */
class _tt__ItemListDescription_ElementItemDescription;	/* onvif.h:20347 */
class tt__ItemListDescription;	/* onvif.h:1935 */
class tt__ItemListDescriptionExtension;	/* onvif.h:1938 */
class tt__Vector;	/* onvif.h:1941 */
class tt__Rectangle;	/* onvif.h:1944 */
class tt__Polygon;	/* onvif.h:1947 */
class tt__Polyline;	/* onvif.h:1950 */
class tt__Color;	/* onvif.h:1953 */
class tt__ColorCovariance;	/* onvif.h:1956 */
class tt__Appearance;	/* onvif.h:1959 */
class tt__AppearanceExtension;	/* onvif.h:1962 */
class tt__ShapeDescriptor;	/* onvif.h:1965 */
class tt__ShapeDescriptorExtension;	/* onvif.h:1968 */
class _tt__ColorDescriptor_ColorCluster;	/* onvif.h:20661 */
class tt__ColorDescriptor;	/* onvif.h:1971 */
class tt__ColorDescriptorExtension;	/* onvif.h:1974 */
class _tt__ClassDescriptor_ClassCandidate;	/* onvif.h:20729 */
class tt__ClassDescriptor;	/* onvif.h:1977 */
class tt__ClassDescriptorExtension;	/* onvif.h:1980 */
class tt__ClassDescriptorExtension2;	/* onvif.h:1983 */
class tt__OtherType;	/* onvif.h:1986 */
class tt__ObjectExtension;	/* onvif.h:1992 */
class tt__Transformation;	/* onvif.h:1995 */
class tt__TransformationExtension;	/* onvif.h:1998 */
class tt__Frame;	/* onvif.h:2001 */
class tt__FrameExtension;	/* onvif.h:2004 */
class tt__FrameExtension2;	/* onvif.h:2007 */
class tt__Merge;	/* onvif.h:2010 */
class tt__Split;	/* onvif.h:2013 */
class tt__Rename;	/* onvif.h:2016 */
class tt__ObjectId;	/* onvif.h:2019 */
class _tt__Behaviour_Removed;	/* onvif.h:21095 */
class _tt__Behaviour_Idle;	/* onvif.h:21115 */
class tt__Behaviour;	/* onvif.h:2022 */
class tt__BehaviourExtension;	/* onvif.h:2025 */
class tt__ObjectTree;	/* onvif.h:2028 */
class tt__ObjectTreeExtension;	/* onvif.h:2031 */
class tt__MotionInCells;	/* onvif.h:2034 */
class tt__AnalyticsEngineConfiguration;	/* onvif.h:2037 */
class tt__AnalyticsEngineConfigurationExtension;	/* onvif.h:2040 */
class tt__RuleEngineConfiguration;	/* onvif.h:2043 */
class tt__RuleEngineConfigurationExtension;	/* onvif.h:2046 */
class tt__Config;	/* onvif.h:2049 */
class _tt__ConfigDescription_Messages;	/* onvif.h:21425 */
class tt__ConfigDescription;	/* onvif.h:2052 */
class tt__ConfigDescriptionExtension;	/* onvif.h:2055 */
class tt__SupportedRules;	/* onvif.h:2058 */
class tt__SupportedRulesExtension;	/* onvif.h:2061 */
class tt__SupportedAnalyticsModules;	/* onvif.h:2064 */
class tt__SupportedAnalyticsModulesExtension;	/* onvif.h:2067 */
class tt__PolygonConfiguration;	/* onvif.h:2070 */
class tt__PolylineArray;	/* onvif.h:2073 */
class tt__PolylineArrayExtension;	/* onvif.h:2076 */
class tt__PolylineArrayConfiguration;	/* onvif.h:2079 */
class tt__MotionExpression;	/* onvif.h:2082 */
class tt__MotionExpressionConfiguration;	/* onvif.h:2085 */
class tt__CellLayout;	/* onvif.h:2088 */
union _tt__union_MetadataStream;	/* onvif.h:21885 */
class __tt__union_MetadataStream;	/* onvif.h:21872 */
class tt__MetadataStream;	/* onvif.h:2091 */
class tt__MetadataStreamExtension;	/* onvif.h:2094 */
class tt__MetadataStreamExtension2;	/* onvif.h:2097 */
class tt__AudioAnalyticsStream;	/* onvif.h:2100 */
class tt__AudioDescriptor;	/* onvif.h:2103 */
class tt__AudioAnalyticsStreamExtension;	/* onvif.h:2106 */
union _tt__union_VideoAnalyticsStream;	/* onvif.h:22064 */
class __tt__union_VideoAnalyticsStream;	/* onvif.h:22054 */
class tt__VideoAnalyticsStream;	/* onvif.h:2109 */
class tt__VideoAnalyticsStreamExtension;	/* onvif.h:2112 */
union _tt__union_PTZStream;	/* onvif.h:22118 */
class __tt__union_PTZStream;	/* onvif.h:22108 */
class tt__PTZStream;	/* onvif.h:2115 */
class tt__PTZStreamExtension;	/* onvif.h:2118 */
union _tt__union_EventStream;	/* onvif.h:22172 */
class __tt__union_EventStream;	/* onvif.h:22162 */
class tt__EventStream;	/* onvif.h:2121 */
class tt__EventStreamExtension;	/* onvif.h:2124 */
class tt__PaneConfiguration;	/* onvif.h:2127 */
class tt__PaneLayout;	/* onvif.h:2130 */
class tt__Layout;	/* onvif.h:2133 */
class tt__LayoutExtension;	/* onvif.h:2136 */
class tt__CodingCapabilities;	/* onvif.h:2139 */
class tt__LayoutOptions;	/* onvif.h:2142 */
class tt__LayoutOptionsExtension;	/* onvif.h:2145 */
class tt__PaneLayoutOptions;	/* onvif.h:2148 */
class tt__PaneOptionExtension;	/* onvif.h:2151 */
class tt__Receiver;	/* onvif.h:2154 */
class tt__ReceiverConfiguration;	/* onvif.h:2157 */
class tt__ReceiverStateInformation;	/* onvif.h:2160 */
class tt__SourceReference;	/* onvif.h:2163 */
class tt__DateTimeRange;	/* onvif.h:2166 */
class tt__RecordingSummary;	/* onvif.h:2169 */
class tt__SearchScope;	/* onvif.h:2172 */
class tt__SearchScopeExtension;	/* onvif.h:2175 */
class tt__PTZPositionFilter;	/* onvif.h:2181 */
class tt__MetadataFilter;	/* onvif.h:2184 */
class tt__FindRecordingResultList;	/* onvif.h:2187 */
class tt__FindEventResultList;	/* onvif.h:2190 */
class tt__FindEventResult;	/* onvif.h:2193 */
class tt__FindPTZPositionResultList;	/* onvif.h:2196 */
class tt__FindPTZPositionResult;	/* onvif.h:2199 */
class tt__FindMetadataResultList;	/* onvif.h:2202 */
class tt__FindMetadataResult;	/* onvif.h:2205 */
class tt__RecordingInformation;	/* onvif.h:2208 */
class tt__RecordingSourceInformation;	/* onvif.h:2211 */
class tt__TrackInformation;	/* onvif.h:2214 */
class tt__MediaAttributes;	/* onvif.h:2217 */
class tt__TrackAttributes;	/* onvif.h:2220 */
class tt__TrackAttributesExtension;	/* onvif.h:2223 */
class tt__VideoAttributes;	/* onvif.h:2226 */
class tt__AudioAttributes;	/* onvif.h:2229 */
class tt__MetadataAttributes;	/* onvif.h:2232 */
class tt__RecordingConfiguration;	/* onvif.h:2235 */
class tt__TrackConfiguration;	/* onvif.h:2238 */
class tt__GetRecordingsResponseItem;	/* onvif.h:2241 */
class tt__GetTracksResponseList;	/* onvif.h:2244 */
class tt__GetTracksResponseItem;	/* onvif.h:2247 */
class tt__RecordingJobConfiguration;	/* onvif.h:2250 */
class tt__RecordingJobConfigurationExtension;	/* onvif.h:2253 */
class tt__RecordingJobSource;	/* onvif.h:2256 */
class tt__RecordingJobSourceExtension;	/* onvif.h:2259 */
class tt__RecordingJobTrack;	/* onvif.h:2262 */
class tt__RecordingJobStateInformation;	/* onvif.h:2265 */
class tt__RecordingJobStateInformationExtension;	/* onvif.h:2268 */
class tt__RecordingJobStateSource;	/* onvif.h:2271 */
class tt__RecordingJobStateTracks;	/* onvif.h:2274 */
class tt__RecordingJobStateTrack;	/* onvif.h:2277 */
class tt__GetRecordingJobsResponseItem;	/* onvif.h:2280 */
class tt__ReplayConfiguration;	/* onvif.h:2283 */
class tt__AnalyticsDeviceEngineConfiguration;	/* onvif.h:2289 */
class tt__AnalyticsDeviceEngineConfigurationExtension;	/* onvif.h:2292 */
class tt__EngineConfiguration;	/* onvif.h:2295 */
class tt__AnalyticsEngineInputInfo;	/* onvif.h:2298 */
class tt__AnalyticsEngineInputInfoExtension;	/* onvif.h:2301 */
class tt__SourceIdentification;	/* onvif.h:2307 */
class tt__SourceIdentificationExtension;	/* onvif.h:2310 */
class tt__MetadataInput;	/* onvif.h:2313 */
class tt__MetadataInputExtension;	/* onvif.h:2316 */
class tt__AnalyticsStateInformation;	/* onvif.h:2322 */
class tt__AnalyticsState;	/* onvif.h:2325 */
class tt__ActionEngineEventPayload;	/* onvif.h:2328 */
class tt__ActionEngineEventPayloadExtension;	/* onvif.h:2331 */
class tt__AudioClassCandidate;	/* onvif.h:2334 */
class tt__AudioClassDescriptor;	/* onvif.h:2337 */
class tt__AudioClassDescriptorExtension;	/* onvif.h:2340 */
class tt__OSDPosConfiguration;	/* onvif.h:2346 */
class tt__OSDPosConfigurationExtension;	/* onvif.h:2349 */
class tt__OSDColor;	/* onvif.h:2352 */
class tt__OSDTextConfiguration;	/* onvif.h:2355 */
class tt__OSDTextConfigurationExtension;	/* onvif.h:2358 */
class tt__OSDImgConfiguration;	/* onvif.h:2361 */
class tt__OSDImgConfigurationExtension;	/* onvif.h:2364 */
class tt__ColorspaceRange;	/* onvif.h:2367 */
union _tt__union_ColorOptions;	/* onvif.h:25010 */
class tt__ColorOptions;	/* onvif.h:2370 */
class tt__OSDColorOptions;	/* onvif.h:2373 */
class tt__OSDColorOptionsExtension;	/* onvif.h:2376 */
class tt__OSDTextOptions;	/* onvif.h:2379 */
class tt__OSDTextOptionsExtension;	/* onvif.h:2382 */
class tt__OSDImgOptions;	/* onvif.h:2385 */
class tt__OSDImgOptionsExtension;	/* onvif.h:2388 */
class tt__OSDConfigurationExtension;	/* onvif.h:2394 */
class tt__MaximumNumberOfOSDs;	/* onvif.h:2397 */
class tt__OSDConfigurationOptions;	/* onvif.h:2400 */
class tt__OSDConfigurationOptionsExtension;	/* onvif.h:2403 */
class tt__FileProgress;	/* onvif.h:2406 */
class tt__ArrayOfFileProgress;	/* onvif.h:2409 */
class tt__ArrayOfFileProgressExtension;	/* onvif.h:2412 */
class tt__StorageReferencePath;	/* onvif.h:2415 */
class tt__StorageReferencePathExtension;	/* onvif.h:2418 */
class _tt__Message;	/* onvif.h:2421 */
class wsnt__QueryExpressionType;	/* onvif.h:2424 */
class wsnt__TopicExpressionType;	/* onvif.h:2427 */
class wsnt__FilterType;	/* onvif.h:2430 */
class wsnt__SubscriptionPolicyType;	/* onvif.h:2433 */
class _wsnt__NotificationMessageHolderType_Message;	/* onvif.h:25718 */
class wsnt__NotificationMessageHolderType;	/* onvif.h:2436 */
class _wsnt__NotificationProducerRP;	/* onvif.h:2499 */
class _wsnt__SubscriptionManagerRP;	/* onvif.h:2502 */
class _wsnt__Notify;	/* onvif.h:2505 */
class _wsnt__UseRaw;	/* onvif.h:2508 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* onvif.h:25861 */
class _wsnt__Subscribe;	/* onvif.h:2511 */
class _wsnt__SubscribeResponse;	/* onvif.h:2514 */
class _wsnt__GetCurrentMessage;	/* onvif.h:2517 */
class _wsnt__GetCurrentMessageResponse;	/* onvif.h:2520 */
class _wsnt__GetMessages;	/* onvif.h:2523 */
class _wsnt__GetMessagesResponse;	/* onvif.h:2526 */
class _wsnt__DestroyPullPoint;	/* onvif.h:2529 */
class _wsnt__DestroyPullPointResponse;	/* onvif.h:2532 */
class _wsnt__CreatePullPoint;	/* onvif.h:2535 */
class _wsnt__CreatePullPointResponse;	/* onvif.h:2538 */
class _wsnt__Renew;	/* onvif.h:2541 */
class _wsnt__RenewResponse;	/* onvif.h:2544 */
class _wsnt__Unsubscribe;	/* onvif.h:2547 */
class _wsnt__UnsubscribeResponse;	/* onvif.h:2550 */
class _wsnt__PauseSubscription;	/* onvif.h:2553 */
class _wsnt__PauseSubscriptionResponse;	/* onvif.h:2556 */
class _wsnt__ResumeSubscription;	/* onvif.h:2559 */
class _wsnt__ResumeSubscriptionResponse;	/* onvif.h:2562 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* onvif.h:26423 */
class _wsrfbf__BaseFaultType_Description;	/* onvif.h:26444 */
class _wsrfbf__BaseFaultType_FaultCause;	/* onvif.h:26461 */
class wsrfbf__BaseFaultType;	/* onvif.h:2565 */
class wstop__Documentation;	/* onvif.h:2568 */
class wstop__ExtensibleDocumented;	/* onvif.h:2571 */
class wstop__QueryExpressionType;	/* onvif.h:2574 */
class tev__Capabilities;	/* onvif.h:2586 */
class tev__SubscriptionPolicy;	/* onvif.h:2589 */
class _tev__GetServiceCapabilities;	/* onvif.h:2592 */
class _tev__GetServiceCapabilitiesResponse;	/* onvif.h:2595 */
class _tev__CreatePullPointSubscription_SubscriptionPolicy;	/* onvif.h:26750 */
class _tev__CreatePullPointSubscription;	/* onvif.h:2598 */
class _tev__CreatePullPointSubscriptionResponse;	/* onvif.h:2601 */
class _tev__PullMessages;	/* onvif.h:2604 */
class _tev__PullMessagesResponse;	/* onvif.h:2607 */
class _tev__PullMessagesFaultResponse;	/* onvif.h:2610 */
class _tev__Seek;	/* onvif.h:2613 */
class _tev__SeekResponse;	/* onvif.h:2616 */
class _tev__SetSynchronizationPoint;	/* onvif.h:2619 */
class _tev__SetSynchronizationPointResponse;	/* onvif.h:2622 */
class _tev__GetEventProperties;	/* onvif.h:2625 */
class _tev__GetEventPropertiesResponse;	/* onvif.h:2628 */
class tls__Capabilities;	/* onvif.h:2637 */
class _tls__GetServiceCapabilities;	/* onvif.h:2640 */
class _tls__GetServiceCapabilitiesResponse;	/* onvif.h:2643 */
class _tls__GetLayout;	/* onvif.h:2646 */
class _tls__GetLayoutResponse;	/* onvif.h:2649 */
class _tls__SetLayout;	/* onvif.h:2652 */
class _tls__SetLayoutResponse;	/* onvif.h:2655 */
class _tls__GetDisplayOptions;	/* onvif.h:2658 */
class _tls__GetDisplayOptionsResponse;	/* onvif.h:2661 */
class _tls__GetPaneConfigurations;	/* onvif.h:2664 */
class _tls__GetPaneConfigurationsResponse;	/* onvif.h:2667 */
class _tls__GetPaneConfiguration;	/* onvif.h:2670 */
class _tls__GetPaneConfigurationResponse;	/* onvif.h:2673 */
class _tls__SetPaneConfigurations;	/* onvif.h:2676 */
class _tls__SetPaneConfigurationsResponse;	/* onvif.h:2679 */
class _tls__SetPaneConfiguration;	/* onvif.h:2682 */
class _tls__SetPaneConfigurationResponse;	/* onvif.h:2685 */
class _tls__CreatePaneConfiguration;	/* onvif.h:2688 */
class _tls__CreatePaneConfigurationResponse;	/* onvif.h:2691 */
class _tls__DeletePaneConfiguration;	/* onvif.h:2694 */
class _tls__DeletePaneConfigurationResponse;	/* onvif.h:2697 */
class tmd__Capabilities;	/* onvif.h:2700 */
class tmd__RelayOutputOptions;	/* onvif.h:2703 */
class tmd__RelayOutputOptionsExtension;	/* onvif.h:2706 */
class tmd__Get;	/* onvif.h:2709 */
class tmd__GetResponse;	/* onvif.h:2712 */
class tmd__DigitalInputConfigurationInputOptions;	/* onvif.h:2715 */
union _tmd__union_SerialData;	/* onvif.h:28013 */
class tmd__SerialData;	/* onvif.h:2718 */
class tmd__SerialPortConfiguration;	/* onvif.h:2724 */
class tmd__SerialPortConfigurationOptions;	/* onvif.h:2727 */
class tmd__ParityBitList;	/* onvif.h:2730 */
class _tmd__GetServiceCapabilities;	/* onvif.h:2733 */
class _tmd__GetServiceCapabilitiesResponse;	/* onvif.h:2736 */
class _tmd__GetRelayOutputOptions;	/* onvif.h:2739 */
class _tmd__GetRelayOutputOptionsResponse;	/* onvif.h:2742 */
class _tmd__GetVideoOutputs;	/* onvif.h:2745 */
class _tmd__GetVideoOutputsResponse;	/* onvif.h:2748 */
class _tmd__GetAudioSourceConfiguration;	/* onvif.h:2751 */
class _tmd__GetAudioSourceConfigurationResponse;	/* onvif.h:2754 */
class _tmd__GetAudioOutputConfiguration;	/* onvif.h:2757 */
class _tmd__GetAudioOutputConfigurationResponse;	/* onvif.h:2760 */
class _tmd__GetVideoSourceConfiguration;	/* onvif.h:2763 */
class _tmd__GetVideoSourceConfigurationResponse;	/* onvif.h:2766 */
class _tmd__GetVideoOutputConfiguration;	/* onvif.h:2769 */
class _tmd__GetVideoOutputConfigurationResponse;	/* onvif.h:2772 */
class _tmd__SetAudioSourceConfiguration;	/* onvif.h:2775 */
class _tmd__SetAudioSourceConfigurationResponse;	/* onvif.h:2778 */
class _tmd__SetAudioOutputConfiguration;	/* onvif.h:2781 */
class _tmd__SetAudioOutputConfigurationResponse;	/* onvif.h:2784 */
class _tmd__SetVideoSourceConfiguration;	/* onvif.h:2787 */
class _tmd__SetVideoSourceConfigurationResponse;	/* onvif.h:2790 */
class _tmd__SetVideoOutputConfiguration;	/* onvif.h:2793 */
class _tmd__SetVideoOutputConfigurationResponse;	/* onvif.h:2796 */
class _tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:2799 */
class _tmd__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:2802 */
class _tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:2805 */
class _tmd__GetVideoOutputConfigurationOptionsResponse;	/* onvif.h:2808 */
class _tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:2811 */
class _tmd__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:2814 */
class _tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:2817 */
class _tmd__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:2820 */
class _tmd__SetRelayOutputSettings;	/* onvif.h:2823 */
class _tmd__SetRelayOutputSettingsResponse;	/* onvif.h:2826 */
class _tmd__GetDigitalInputs;	/* onvif.h:2829 */
class _tmd__GetDigitalInputsResponse;	/* onvif.h:2832 */
class _tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:2835 */
class _tmd__GetDigitalInputConfigurationOptionsResponse;	/* onvif.h:2838 */
class _tmd__SetDigitalInputConfigurations;	/* onvif.h:2841 */
class _tmd__SetDigitalInputConfigurationsResponse;	/* onvif.h:2844 */
class _tmd__GetSerialPorts;	/* onvif.h:2847 */
class _tmd__GetSerialPortsResponse;	/* onvif.h:2850 */
class _tmd__GetSerialPortConfiguration;	/* onvif.h:2853 */
class _tmd__GetSerialPortConfigurationResponse;	/* onvif.h:2856 */
class _tmd__SetSerialPortConfiguration;	/* onvif.h:2859 */
class _tmd__SetSerialPortConfigurationResponse;	/* onvif.h:2862 */
class _tmd__GetSerialPortConfigurationOptions;	/* onvif.h:2865 */
class _tmd__GetSerialPortConfigurationOptionsResponse;	/* onvif.h:2868 */
class _tmd__SendReceiveSerialCommand;	/* onvif.h:2871 */
class _tmd__SendReceiveSerialCommandResponse;	/* onvif.h:2874 */
class timg__Capabilities;	/* onvif.h:2877 */
class _timg__GetServiceCapabilities;	/* onvif.h:2880 */
class _timg__GetServiceCapabilitiesResponse;	/* onvif.h:2883 */
class _timg__GetImagingSettings;	/* onvif.h:2886 */
class _timg__GetImagingSettingsResponse;	/* onvif.h:2889 */
class _timg__SetImagingSettings;	/* onvif.h:2892 */
class _timg__SetImagingSettingsResponse;	/* onvif.h:2895 */
class _timg__GetOptions;	/* onvif.h:2898 */
class _timg__GetOptionsResponse;	/* onvif.h:2901 */
class _timg__Move;	/* onvif.h:2904 */
class _timg__MoveResponse;	/* onvif.h:2907 */
class _timg__GetMoveOptions;	/* onvif.h:2910 */
class _timg__GetMoveOptionsResponse;	/* onvif.h:2913 */
class _timg__Stop;	/* onvif.h:2916 */
class _timg__StopResponse;	/* onvif.h:2919 */
class _timg__GetStatus;	/* onvif.h:2922 */
class _timg__GetStatusResponse;	/* onvif.h:2925 */
class trt__Capabilities;	/* onvif.h:2928 */
class trt__ProfileCapabilities;	/* onvif.h:2931 */
class trt__StreamingCapabilities;	/* onvif.h:2934 */
class trt__VideoSourceMode;	/* onvif.h:2937 */
class trt__VideoSourceModeExtension;	/* onvif.h:2940 */
class _trt__GetServiceCapabilities;	/* onvif.h:2943 */
class _trt__GetServiceCapabilitiesResponse;	/* onvif.h:2946 */
class _trt__GetVideoSources;	/* onvif.h:2949 */
class _trt__GetVideoSourcesResponse;	/* onvif.h:2952 */
class _trt__GetAudioSources;	/* onvif.h:2955 */
class _trt__GetAudioSourcesResponse;	/* onvif.h:2958 */
class _trt__GetAudioOutputs;	/* onvif.h:2961 */
class _trt__GetAudioOutputsResponse;	/* onvif.h:2964 */
class _trt__CreateProfile;	/* onvif.h:2967 */
class _trt__CreateProfileResponse;	/* onvif.h:2970 */
class _trt__GetProfile;	/* onvif.h:2973 */
class _trt__GetProfileResponse;	/* onvif.h:2976 */
class _trt__GetProfiles;	/* onvif.h:2979 */
class _trt__GetProfilesResponse;	/* onvif.h:2982 */
class _trt__AddVideoEncoderConfiguration;	/* onvif.h:2985 */
class _trt__AddVideoEncoderConfigurationResponse;	/* onvif.h:2988 */
class _trt__RemoveVideoEncoderConfiguration;	/* onvif.h:2991 */
class _trt__RemoveVideoEncoderConfigurationResponse;	/* onvif.h:2994 */
class _trt__AddVideoSourceConfiguration;	/* onvif.h:2997 */
class _trt__AddVideoSourceConfigurationResponse;	/* onvif.h:3000 */
class _trt__RemoveVideoSourceConfiguration;	/* onvif.h:3003 */
class _trt__RemoveVideoSourceConfigurationResponse;	/* onvif.h:3006 */
class _trt__AddAudioEncoderConfiguration;	/* onvif.h:3009 */
class _trt__AddAudioEncoderConfigurationResponse;	/* onvif.h:3012 */
class _trt__RemoveAudioEncoderConfiguration;	/* onvif.h:3015 */
class _trt__RemoveAudioEncoderConfigurationResponse;	/* onvif.h:3018 */
class _trt__AddAudioSourceConfiguration;	/* onvif.h:3021 */
class _trt__AddAudioSourceConfigurationResponse;	/* onvif.h:3024 */
class _trt__RemoveAudioSourceConfiguration;	/* onvif.h:3027 */
class _trt__RemoveAudioSourceConfigurationResponse;	/* onvif.h:3030 */
class _trt__AddPTZConfiguration;	/* onvif.h:3033 */
class _trt__AddPTZConfigurationResponse;	/* onvif.h:3036 */
class _trt__RemovePTZConfiguration;	/* onvif.h:3039 */
class _trt__RemovePTZConfigurationResponse;	/* onvif.h:3042 */
class _trt__AddVideoAnalyticsConfiguration;	/* onvif.h:3045 */
class _trt__AddVideoAnalyticsConfigurationResponse;	/* onvif.h:3048 */
class _trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:3051 */
class _trt__RemoveVideoAnalyticsConfigurationResponse;	/* onvif.h:3054 */
class _trt__AddMetadataConfiguration;	/* onvif.h:3057 */
class _trt__AddMetadataConfigurationResponse;	/* onvif.h:3060 */
class _trt__RemoveMetadataConfiguration;	/* onvif.h:3063 */
class _trt__RemoveMetadataConfigurationResponse;	/* onvif.h:3066 */
class _trt__AddAudioOutputConfiguration;	/* onvif.h:3069 */
class _trt__AddAudioOutputConfigurationResponse;	/* onvif.h:3072 */
class _trt__RemoveAudioOutputConfiguration;	/* onvif.h:3075 */
class _trt__RemoveAudioOutputConfigurationResponse;	/* onvif.h:3078 */
class _trt__AddAudioDecoderConfiguration;	/* onvif.h:3081 */
class _trt__AddAudioDecoderConfigurationResponse;	/* onvif.h:3084 */
class _trt__RemoveAudioDecoderConfiguration;	/* onvif.h:3087 */
class _trt__RemoveAudioDecoderConfigurationResponse;	/* onvif.h:3090 */
class _trt__DeleteProfile;	/* onvif.h:3093 */
class _trt__DeleteProfileResponse;	/* onvif.h:3096 */
class _trt__GetVideoEncoderConfigurations;	/* onvif.h:3099 */
class _trt__GetVideoEncoderConfigurationsResponse;	/* onvif.h:3102 */
class _trt__GetVideoSourceConfigurations;	/* onvif.h:3105 */
class _trt__GetVideoSourceConfigurationsResponse;	/* onvif.h:3108 */
class _trt__GetAudioEncoderConfigurations;	/* onvif.h:3111 */
class _trt__GetAudioEncoderConfigurationsResponse;	/* onvif.h:3114 */
class _trt__GetAudioSourceConfigurations;	/* onvif.h:3117 */
class _trt__GetAudioSourceConfigurationsResponse;	/* onvif.h:3120 */
class _trt__GetVideoAnalyticsConfigurations;	/* onvif.h:3123 */
class _trt__GetVideoAnalyticsConfigurationsResponse;	/* onvif.h:3126 */
class _trt__GetMetadataConfigurations;	/* onvif.h:3129 */
class _trt__GetMetadataConfigurationsResponse;	/* onvif.h:3132 */
class _trt__GetAudioOutputConfigurations;	/* onvif.h:3135 */
class _trt__GetAudioOutputConfigurationsResponse;	/* onvif.h:3138 */
class _trt__GetAudioDecoderConfigurations;	/* onvif.h:3141 */
class _trt__GetAudioDecoderConfigurationsResponse;	/* onvif.h:3144 */
class _trt__GetVideoSourceConfiguration;	/* onvif.h:3147 */
class _trt__GetVideoSourceConfigurationResponse;	/* onvif.h:3150 */
class _trt__GetVideoEncoderConfiguration;	/* onvif.h:3153 */
class _trt__GetVideoEncoderConfigurationResponse;	/* onvif.h:3156 */
class _trt__GetAudioSourceConfiguration;	/* onvif.h:3159 */
class _trt__GetAudioSourceConfigurationResponse;	/* onvif.h:3162 */
class _trt__GetAudioEncoderConfiguration;	/* onvif.h:3165 */
class _trt__GetAudioEncoderConfigurationResponse;	/* onvif.h:3168 */
class _trt__GetVideoAnalyticsConfiguration;	/* onvif.h:3171 */
class _trt__GetVideoAnalyticsConfigurationResponse;	/* onvif.h:3174 */
class _trt__GetMetadataConfiguration;	/* onvif.h:3177 */
class _trt__GetMetadataConfigurationResponse;	/* onvif.h:3180 */
class _trt__GetAudioOutputConfiguration;	/* onvif.h:3183 */
class _trt__GetAudioOutputConfigurationResponse;	/* onvif.h:3186 */
class _trt__GetAudioDecoderConfiguration;	/* onvif.h:3189 */
class _trt__GetAudioDecoderConfigurationResponse;	/* onvif.h:3192 */
class _trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:3195 */
class _trt__GetCompatibleVideoEncoderConfigurationsResponse;	/* onvif.h:3198 */
class _trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:3201 */
class _trt__GetCompatibleVideoSourceConfigurationsResponse;	/* onvif.h:3204 */
class _trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:3207 */
class _trt__GetCompatibleAudioEncoderConfigurationsResponse;	/* onvif.h:3210 */
class _trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:3213 */
class _trt__GetCompatibleAudioSourceConfigurationsResponse;	/* onvif.h:3216 */
class _trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:3219 */
class _trt__GetCompatibleVideoAnalyticsConfigurationsResponse;	/* onvif.h:3222 */
class _trt__GetCompatibleMetadataConfigurations;	/* onvif.h:3225 */
class _trt__GetCompatibleMetadataConfigurationsResponse;	/* onvif.h:3228 */
class _trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:3231 */
class _trt__GetCompatibleAudioOutputConfigurationsResponse;	/* onvif.h:3234 */
class _trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:3237 */
class _trt__GetCompatibleAudioDecoderConfigurationsResponse;	/* onvif.h:3240 */
class _trt__SetVideoEncoderConfiguration;	/* onvif.h:3243 */
class _trt__SetVideoEncoderConfigurationResponse;	/* onvif.h:3246 */
class _trt__SetVideoSourceConfiguration;	/* onvif.h:3249 */
class _trt__SetVideoSourceConfigurationResponse;	/* onvif.h:3252 */
class _trt__SetAudioEncoderConfiguration;	/* onvif.h:3255 */
class _trt__SetAudioEncoderConfigurationResponse;	/* onvif.h:3258 */
class _trt__SetAudioSourceConfiguration;	/* onvif.h:3261 */
class _trt__SetAudioSourceConfigurationResponse;	/* onvif.h:3264 */
class _trt__SetVideoAnalyticsConfiguration;	/* onvif.h:3267 */
class _trt__SetVideoAnalyticsConfigurationResponse;	/* onvif.h:3270 */
class _trt__SetMetadataConfiguration;	/* onvif.h:3273 */
class _trt__SetMetadataConfigurationResponse;	/* onvif.h:3276 */
class _trt__SetAudioOutputConfiguration;	/* onvif.h:3279 */
class _trt__SetAudioOutputConfigurationResponse;	/* onvif.h:3282 */
class _trt__SetAudioDecoderConfiguration;	/* onvif.h:3285 */
class _trt__SetAudioDecoderConfigurationResponse;	/* onvif.h:3288 */
class _trt__GetVideoSourceConfigurationOptions;	/* onvif.h:3291 */
class _trt__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:3294 */
class _trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:3297 */
class _trt__GetVideoEncoderConfigurationOptionsResponse;	/* onvif.h:3300 */
class _trt__GetAudioSourceConfigurationOptions;	/* onvif.h:3303 */
class _trt__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:3306 */
class _trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:3309 */
class _trt__GetAudioEncoderConfigurationOptionsResponse;	/* onvif.h:3312 */
class _trt__GetMetadataConfigurationOptions;	/* onvif.h:3315 */
class _trt__GetMetadataConfigurationOptionsResponse;	/* onvif.h:3318 */
class _trt__GetAudioOutputConfigurationOptions;	/* onvif.h:3321 */
class _trt__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:3324 */
class _trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:3327 */
class _trt__GetAudioDecoderConfigurationOptionsResponse;	/* onvif.h:3330 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:3333 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse;	/* onvif.h:3336 */
class _trt__GetStreamUri;	/* onvif.h:3339 */
class _trt__GetStreamUriResponse;	/* onvif.h:3342 */
class _trt__StartMulticastStreaming;	/* onvif.h:3345 */
class _trt__StartMulticastStreamingResponse;	/* onvif.h:3348 */
class _trt__StopMulticastStreaming;	/* onvif.h:3351 */
class _trt__StopMulticastStreamingResponse;	/* onvif.h:3354 */
class _trt__SetSynchronizationPoint;	/* onvif.h:3357 */
class _trt__SetSynchronizationPointResponse;	/* onvif.h:3360 */
class _trt__GetSnapshotUri;	/* onvif.h:3363 */
class _trt__GetSnapshotUriResponse;	/* onvif.h:3366 */
class _trt__GetVideoSourceModes;	/* onvif.h:3369 */
class _trt__GetVideoSourceModesResponse;	/* onvif.h:3372 */
class _trt__SetVideoSourceMode;	/* onvif.h:3375 */
class _trt__SetVideoSourceModeResponse;	/* onvif.h:3378 */
class _trt__GetOSDs;	/* onvif.h:3381 */
class _trt__GetOSDsResponse;	/* onvif.h:3384 */
class _trt__GetOSD;	/* onvif.h:3387 */
class _trt__GetOSDResponse;	/* onvif.h:3390 */
class _trt__SetOSD;	/* onvif.h:3393 */
class _trt__SetOSDResponse;	/* onvif.h:3396 */
class _trt__GetOSDOptions;	/* onvif.h:3399 */
class _trt__GetOSDOptionsResponse;	/* onvif.h:3402 */
class _trt__CreateOSD;	/* onvif.h:3405 */
class _trt__CreateOSDResponse;	/* onvif.h:3408 */
class _trt__DeleteOSD;	/* onvif.h:3411 */
class _trt__DeleteOSDResponse;	/* onvif.h:3414 */
class tptz__Capabilities;	/* onvif.h:3417 */
class _tptz__GetServiceCapabilities;	/* onvif.h:3420 */
class _tptz__GetServiceCapabilitiesResponse;	/* onvif.h:3423 */
class _tptz__GetNodes;	/* onvif.h:3426 */
class _tptz__GetNodesResponse;	/* onvif.h:3429 */
class _tptz__GetNode;	/* onvif.h:3432 */
class _tptz__GetNodeResponse;	/* onvif.h:3435 */
class _tptz__GetConfigurations;	/* onvif.h:3438 */
class _tptz__GetConfigurationsResponse;	/* onvif.h:3441 */
class _tptz__GetConfiguration;	/* onvif.h:3444 */
class _tptz__GetConfigurationResponse;	/* onvif.h:3447 */
class _tptz__SetConfiguration;	/* onvif.h:3450 */
class __tptz__SetConfigurationResponse_sequence;	/* onvif.h:34217 */
class _tptz__SetConfigurationResponse;	/* onvif.h:3453 */
class _tptz__GetConfigurationOptions;	/* onvif.h:3456 */
class _tptz__GetConfigurationOptionsResponse;	/* onvif.h:3459 */
class _tptz__SendAuxiliaryCommand;	/* onvif.h:3462 */
class _tptz__SendAuxiliaryCommandResponse;	/* onvif.h:3465 */
class _tptz__GetPresets;	/* onvif.h:3468 */
class _tptz__GetPresetsResponse;	/* onvif.h:3471 */
class _tptz__SetPreset;	/* onvif.h:3474 */
class _tptz__SetPresetResponse;	/* onvif.h:3477 */
class _tptz__RemovePreset;	/* onvif.h:3480 */
class _tptz__RemovePresetResponse;	/* onvif.h:3483 */
class _tptz__GotoPreset;	/* onvif.h:3486 */
class _tptz__GotoPresetResponse;	/* onvif.h:3489 */
class _tptz__GetStatus;	/* onvif.h:3492 */
class _tptz__GetStatusResponse;	/* onvif.h:3495 */
class _tptz__GotoHomePosition;	/* onvif.h:3498 */
class _tptz__GotoHomePositionResponse;	/* onvif.h:3501 */
class _tptz__SetHomePosition;	/* onvif.h:3504 */
class _tptz__SetHomePositionResponse;	/* onvif.h:3507 */
class _tptz__ContinuousMove;	/* onvif.h:3510 */
class _tptz__ContinuousMoveResponse;	/* onvif.h:3513 */
class _tptz__RelativeMove;	/* onvif.h:3516 */
class _tptz__RelativeMoveResponse;	/* onvif.h:3519 */
class _tptz__AbsoluteMove;	/* onvif.h:3522 */
class _tptz__AbsoluteMoveResponse;	/* onvif.h:3525 */
class _tptz__Stop;	/* onvif.h:3528 */
class _tptz__StopResponse;	/* onvif.h:3531 */
class _tptz__GetPresetTours;	/* onvif.h:3534 */
class _tptz__GetPresetToursResponse;	/* onvif.h:3537 */
class _tptz__GetPresetTour;	/* onvif.h:3540 */
class _tptz__GetPresetTourResponse;	/* onvif.h:3543 */
class _tptz__GetPresetTourOptions;	/* onvif.h:3546 */
class _tptz__GetPresetTourOptionsResponse;	/* onvif.h:3549 */
class _tptz__CreatePresetTour;	/* onvif.h:3552 */
class _tptz__CreatePresetTourResponse;	/* onvif.h:3555 */
class _tptz__ModifyPresetTour;	/* onvif.h:3558 */
class _tptz__ModifyPresetTourResponse;	/* onvif.h:3561 */
class _tptz__OperatePresetTour;	/* onvif.h:3564 */
class _tptz__OperatePresetTourResponse;	/* onvif.h:3567 */
class _tptz__RemovePresetTour;	/* onvif.h:3570 */
class _tptz__RemovePresetTourResponse;	/* onvif.h:3573 */
class _tptz__GetCompatibleConfigurations;	/* onvif.h:3576 */
class _tptz__GetCompatibleConfigurationsResponse;	/* onvif.h:3579 */
class trv__Capabilities;	/* onvif.h:3582 */
class _trv__GetServiceCapabilities;	/* onvif.h:3585 */
class _trv__GetServiceCapabilitiesResponse;	/* onvif.h:3588 */
class _trv__GetReceivers;	/* onvif.h:3591 */
class _trv__GetReceiversResponse;	/* onvif.h:3594 */
class _trv__GetReceiver;	/* onvif.h:3597 */
class _trv__GetReceiverResponse;	/* onvif.h:3600 */
class _trv__CreateReceiver;	/* onvif.h:3603 */
class _trv__CreateReceiverResponse;	/* onvif.h:3606 */
class _trv__DeleteReceiver;	/* onvif.h:3609 */
class _trv__DeleteReceiverResponse;	/* onvif.h:3612 */
class _trv__ConfigureReceiver;	/* onvif.h:3615 */
class _trv__ConfigureReceiverResponse;	/* onvif.h:3618 */
class _trv__SetReceiverMode;	/* onvif.h:3621 */
class _trv__SetReceiverModeResponse;	/* onvif.h:3624 */
class _trv__GetReceiverState;	/* onvif.h:3627 */
class _trv__GetReceiverStateResponse;	/* onvif.h:3630 */
class trc__Capabilities;	/* onvif.h:3633 */
class trc__RecordingOptions;	/* onvif.h:3636 */
class trc__JobOptions;	/* onvif.h:3639 */
class trc__TrackOptions;	/* onvif.h:3642 */
class _trc__GetServiceCapabilities;	/* onvif.h:3645 */
class _trc__GetServiceCapabilitiesResponse;	/* onvif.h:3648 */
class _trc__CreateRecording;	/* onvif.h:3651 */
class _trc__CreateRecordingResponse;	/* onvif.h:3654 */
class _trc__DeleteRecording;	/* onvif.h:3657 */
class _trc__DeleteRecordingResponse;	/* onvif.h:3660 */
class _trc__GetRecordings;	/* onvif.h:3663 */
class _trc__GetRecordingsResponse;	/* onvif.h:3666 */
class _trc__SetRecordingConfiguration;	/* onvif.h:3669 */
class _trc__SetRecordingConfigurationResponse;	/* onvif.h:3672 */
class _trc__GetRecordingConfiguration;	/* onvif.h:3675 */
class _trc__GetRecordingConfigurationResponse;	/* onvif.h:3678 */
class _trc__CreateTrack;	/* onvif.h:3681 */
class _trc__CreateTrackResponse;	/* onvif.h:3684 */
class _trc__DeleteTrack;	/* onvif.h:3687 */
class _trc__DeleteTrackResponse;	/* onvif.h:3690 */
class _trc__GetTrackConfiguration;	/* onvif.h:3693 */
class _trc__GetTrackConfigurationResponse;	/* onvif.h:3696 */
class _trc__SetTrackConfiguration;	/* onvif.h:3699 */
class _trc__SetTrackConfigurationResponse;	/* onvif.h:3702 */
class _trc__CreateRecordingJob;	/* onvif.h:3705 */
class _trc__CreateRecordingJobResponse;	/* onvif.h:3708 */
class _trc__DeleteRecordingJob;	/* onvif.h:3711 */
class _trc__DeleteRecordingJobResponse;	/* onvif.h:3714 */
class _trc__GetRecordingJobs;	/* onvif.h:3717 */
class _trc__GetRecordingJobsResponse;	/* onvif.h:3720 */
class _trc__SetRecordingJobConfiguration;	/* onvif.h:3723 */
class _trc__SetRecordingJobConfigurationResponse;	/* onvif.h:3726 */
class _trc__GetRecordingJobConfiguration;	/* onvif.h:3729 */
class _trc__GetRecordingJobConfigurationResponse;	/* onvif.h:3732 */
class _trc__SetRecordingJobMode;	/* onvif.h:3735 */
class _trc__SetRecordingJobModeResponse;	/* onvif.h:3738 */
class _trc__GetRecordingJobState;	/* onvif.h:3741 */
class _trc__GetRecordingJobStateResponse;	/* onvif.h:3744 */
class _trc__GetRecordingOptions;	/* onvif.h:3747 */
class _trc__GetRecordingOptionsResponse;	/* onvif.h:3750 */
class _trc__ExportRecordedData;	/* onvif.h:3753 */
class _trc__ExportRecordedDataResponse_Extension;	/* onvif.h:36790 */
class _trc__ExportRecordedDataResponse;	/* onvif.h:3756 */
class _trc__StopExportRecordedData;	/* onvif.h:3759 */
class _trc__StopExportRecordedDataResponse;	/* onvif.h:3762 */
class _trc__GetExportRecordedDataState;	/* onvif.h:3765 */
class _trc__GetExportRecordedDataStateResponse;	/* onvif.h:3768 */
class tse__Capabilities;	/* onvif.h:3771 */
class _tse__GetServiceCapabilities;	/* onvif.h:3774 */
class _tse__GetServiceCapabilitiesResponse;	/* onvif.h:3777 */
class _tse__GetRecordingSummary;	/* onvif.h:3780 */
class _tse__GetRecordingSummaryResponse;	/* onvif.h:3783 */
class _tse__GetRecordingInformation;	/* onvif.h:3786 */
class _tse__GetRecordingInformationResponse;	/* onvif.h:3789 */
class _tse__GetMediaAttributes;	/* onvif.h:3792 */
class _tse__GetMediaAttributesResponse;	/* onvif.h:3795 */
class _tse__FindRecordings;	/* onvif.h:3798 */
class _tse__FindRecordingsResponse;	/* onvif.h:3801 */
class _tse__GetRecordingSearchResults;	/* onvif.h:3804 */
class _tse__GetRecordingSearchResultsResponse;	/* onvif.h:3807 */
class _tse__FindEvents;	/* onvif.h:3810 */
class _tse__FindEventsResponse;	/* onvif.h:3813 */
class _tse__GetEventSearchResults;	/* onvif.h:3816 */
class _tse__GetEventSearchResultsResponse;	/* onvif.h:3819 */
class _tse__FindPTZPosition;	/* onvif.h:3822 */
class _tse__FindPTZPositionResponse;	/* onvif.h:3825 */
class _tse__GetPTZPositionSearchResults;	/* onvif.h:3828 */
class _tse__GetPTZPositionSearchResultsResponse;	/* onvif.h:3831 */
class _tse__FindMetadata;	/* onvif.h:3834 */
class _tse__FindMetadataResponse;	/* onvif.h:3837 */
class _tse__GetMetadataSearchResults;	/* onvif.h:3840 */
class _tse__GetMetadataSearchResultsResponse;	/* onvif.h:3843 */
class _tse__GetSearchState;	/* onvif.h:3846 */
class _tse__GetSearchStateResponse;	/* onvif.h:3849 */
class _tse__EndSearch;	/* onvif.h:3852 */
class _tse__EndSearchResponse;	/* onvif.h:3855 */
class trp__Capabilities;	/* onvif.h:3858 */
class _trp__GetServiceCapabilities;	/* onvif.h:3861 */
class _trp__GetServiceCapabilitiesResponse;	/* onvif.h:3864 */
class _trp__GetReplayUri;	/* onvif.h:3867 */
class _trp__GetReplayUriResponse;	/* onvif.h:3870 */
class _trp__SetReplayConfiguration;	/* onvif.h:3873 */
class _trp__SetReplayConfigurationResponse;	/* onvif.h:3876 */
class _trp__GetReplayConfiguration;	/* onvif.h:3879 */
class _trp__GetReplayConfigurationResponse;	/* onvif.h:3882 */
class tds__StorageConfiguration;	/* onvif.h:429 */
class tt__VideoSource;	/* onvif.h:981 */
class tt__AudioSource;	/* onvif.h:990 */
class tt__VideoSourceConfiguration;	/* onvif.h:1005 */
class tt__VideoEncoderConfiguration;	/* onvif.h:1044 */
class tt__JpegOptions2;	/* onvif.h:1071 */
class tt__Mpeg4Options2;	/* onvif.h:1077 */
class tt__H264Options2;	/* onvif.h:1083 */
class tt__VideoEncoder2Configuration;	/* onvif.h:1086 */
class tt__AudioSourceConfiguration;	/* onvif.h:1098 */
class tt__AudioEncoderConfiguration;	/* onvif.h:1107 */
class tt__AudioEncoder2Configuration;	/* onvif.h:1116 */
class tt__VideoAnalyticsConfiguration;	/* onvif.h:1122 */
class tt__MetadataConfiguration;	/* onvif.h:1125 */
class tt__VideoOutput;	/* onvif.h:1152 */
class tt__VideoOutputConfiguration;	/* onvif.h:1158 */
class tt__AudioOutput;	/* onvif.h:1179 */
class tt__AudioOutputConfiguration;	/* onvif.h:1182 */
class tt__AudioDecoderConfiguration;	/* onvif.h:1188 */
class tt__NetworkInterface;	/* onvif.h:1221 */
class tt__CertificateUsage;	/* onvif.h:1533 */
class tt__RelayOutput;	/* onvif.h:1560 */
class tt__DigitalInput;	/* onvif.h:1563 */
class tt__PTZNode;	/* onvif.h:1566 */
class tt__PTZConfiguration;	/* onvif.h:1581 */
class tt__Object;	/* onvif.h:1989 */
class tt__EventFilter;	/* onvif.h:2178 */
class tt__AnalyticsEngine;	/* onvif.h:2286 */
class tt__AnalyticsEngineInput;	/* onvif.h:2304 */
class tt__AnalyticsEngineControl;	/* onvif.h:2319 */
class tt__OSDConfiguration;	/* onvif.h:2391 */
class wsnt__SubscribeCreationFailedFaultType;	/* onvif.h:2439 */
class wsnt__InvalidFilterFaultType;	/* onvif.h:2442 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* onvif.h:2445 */
class wsnt__InvalidTopicExpressionFaultType;	/* onvif.h:2448 */
class wsnt__TopicNotSupportedFaultType;	/* onvif.h:2451 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* onvif.h:2454 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* onvif.h:2457 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* onvif.h:2460 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* onvif.h:2463 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* onvif.h:2466 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* onvif.h:2469 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* onvif.h:2472 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* onvif.h:2475 */
class wsnt__UnableToGetMessagesFaultType;	/* onvif.h:2478 */
class wsnt__UnableToDestroyPullPointFaultType;	/* onvif.h:2481 */
class wsnt__UnableToCreatePullPointFaultType;	/* onvif.h:2484 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* onvif.h:2487 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* onvif.h:2490 */
class wsnt__PauseFailedFaultType;	/* onvif.h:2493 */
class wsnt__ResumeFailedFaultType;	/* onvif.h:2496 */
class _wstop__TopicNamespaceType_Topic;	/* onvif.h:41611 */
class wstop__TopicNamespaceType;	/* onvif.h:2577 */
class wstop__TopicType;	/* onvif.h:2580 */
class wstop__TopicSetType;	/* onvif.h:2583 */
class wsrfr__ResourceUnknownFaultType;	/* onvif.h:2631 */
class wsrfr__ResourceUnavailableFaultType;	/* onvif.h:2634 */
class tmd__SerialPort;	/* onvif.h:2721 */
class tt__OSDReference;	/* onvif.h:2343 */
struct __tdn__Hello;	/* onvif.h:43718 */
struct __tdn__Bye;	/* onvif.h:43784 */
struct __tdn__Probe;	/* onvif.h:43850 */
struct __tds__GetServices;	/* onvif.h:43935 */
struct __tds__GetServiceCapabilities;	/* onvif.h:44003 */
struct __tds__GetDeviceInformation;	/* onvif.h:44070 */
struct __tds__SetSystemDateAndTime;	/* onvif.h:44151 */
struct __tds__GetSystemDateAndTime;	/* onvif.h:44224 */
struct __tds__SetSystemFactoryDefault;	/* onvif.h:44291 */
struct __tds__UpgradeSystemFirmware;	/* onvif.h:44364 */
struct __tds__SystemReboot;	/* onvif.h:44431 */
struct __tds__RestoreSystem;	/* onvif.h:44506 */
struct __tds__GetSystemBackup;	/* onvif.h:44580 */
struct __tds__GetSystemLog;	/* onvif.h:44648 */
struct __tds__GetSystemSupportInformation;	/* onvif.h:44715 */
struct __tds__GetScopes;	/* onvif.h:44797 */
struct __tds__SetScopes;	/* onvif.h:44872 */
struct __tds__AddScopes;	/* onvif.h:44943 */
struct __tds__RemoveScopes;	/* onvif.h:45016 */
struct __tds__GetDiscoveryMode;	/* onvif.h:45087 */
struct __tds__SetDiscoveryMode;	/* onvif.h:45159 */
struct __tds__GetRemoteDiscoveryMode;	/* onvif.h:45232 */
struct __tds__SetRemoteDiscoveryMode;	/* onvif.h:45305 */
struct __tds__GetDPAddresses;	/* onvif.h:45376 */
struct __tds__GetEndpointReference;	/* onvif.h:45449 */
struct __tds__GetRemoteUser;	/* onvif.h:45522 */
struct __tds__SetRemoteUser;	/* onvif.h:45600 */
struct __tds__GetUsers;	/* onvif.h:45671 */
struct __tds__CreateUsers;	/* onvif.h:45750 */
struct __tds__DeleteUsers;	/* onvif.h:45824 */
struct __tds__SetUser;	/* onvif.h:45896 */
struct __tds__GetWsdlUrl;	/* onvif.h:45970 */
struct __tds__GetCapabilities;	/* onvif.h:46046 */
struct __tds__SetDPAddresses;	/* onvif.h:46118 */
struct __tds__GetHostname;	/* onvif.h:46188 */
struct __tds__SetHostname;	/* onvif.h:46262 */
struct __tds__SetHostnameFromDHCP;	/* onvif.h:46329 */
struct __tds__GetDNS;	/* onvif.h:46398 */
struct __tds__SetDNS;	/* onvif.h:46467 */
struct __tds__GetNTP;	/* onvif.h:46537 */
struct __tds__SetNTP;	/* onvif.h:46614 */
struct __tds__GetDynamicDNS;	/* onvif.h:46685 */
struct __tds__SetDynamicDNS;	/* onvif.h:46756 */
struct __tds__GetNetworkInterfaces;	/* onvif.h:46827 */
struct __tds__SetNetworkInterfaces;	/* onvif.h:46903 */
struct __tds__GetNetworkProtocols;	/* onvif.h:46973 */
struct __tds__SetNetworkProtocols;	/* onvif.h:47043 */
struct __tds__GetNetworkDefaultGateway;	/* onvif.h:47113 */
struct __tds__SetNetworkDefaultGateway;	/* onvif.h:47182 */
struct __tds__GetZeroConfiguration;	/* onvif.h:47256 */
struct __tds__SetZeroConfiguration;	/* onvif.h:47324 */
struct __tds__GetIPAddressFilter;	/* onvif.h:47395 */
struct __tds__SetIPAddressFilter;	/* onvif.h:47468 */
struct __tds__AddIPAddressFilter;	/* onvif.h:47540 */
struct __tds__RemoveIPAddressFilter;	/* onvif.h:47612 */
struct __tds__GetAccessPolicy;	/* onvif.h:47693 */
struct __tds__SetAccessPolicy;	/* onvif.h:47765 */
struct __tds__CreateCertificate;	/* onvif.h:47847 */
struct __tds__GetCertificates;	/* onvif.h:47926 */
struct __tds__GetCertificatesStatus;	/* onvif.h:47996 */
struct __tds__SetCertificatesStatus;	/* onvif.h:48068 */
struct __tds__DeleteCertificates;	/* onvif.h:48143 */
struct __tds__GetPkcs10Request;	/* onvif.h:48223 */
struct __tds__LoadCertificates;	/* onvif.h:48313 */
struct __tds__GetClientCertificateMode;	/* onvif.h:48383 */
struct __tds__SetClientCertificateMode;	/* onvif.h:48453 */
struct __tds__GetRelayOutputs;	/* onvif.h:48522 */
struct __tds__SetRelayOutputSettings;	/* onvif.h:48591 */
struct __tds__SetRelayOutputState;	/* onvif.h:48660 */
struct __tds__SendAuxiliaryCommand;	/* onvif.h:48758 */
struct __tds__GetCACertificates;	/* onvif.h:48836 */
struct __tds__LoadCertificateWithPrivateKey;	/* onvif.h:48926 */
struct __tds__GetCertificateInformation;	/* onvif.h:49003 */
struct __tds__LoadCACertificates;	/* onvif.h:49087 */
struct __tds__CreateDot1XConfiguration;	/* onvif.h:49162 */
struct __tds__SetDot1XConfiguration;	/* onvif.h:49233 */
struct __tds__GetDot1XConfiguration;	/* onvif.h:49308 */
struct __tds__GetDot1XConfigurations;	/* onvif.h:49386 */
struct __tds__DeleteDot1XConfiguration;	/* onvif.h:49458 */
struct __tds__GetDot11Capabilities;	/* onvif.h:49526 */
struct __tds__GetDot11Status;	/* onvif.h:49595 */
struct __tds__ScanAvailableDot11Networks;	/* onvif.h:49664 */
struct __tds__GetSystemUris;	/* onvif.h:49750 */
struct __tds__StartFirmwareUpgrade;	/* onvif.h:49845 */
struct __tds__StartSystemRestore;	/* onvif.h:49939 */
struct __tds__GetStorageConfigurations;	/* onvif.h:50009 */
struct __tds__CreateStorageConfiguration;	/* onvif.h:50080 */
struct __tds__GetStorageConfiguration;	/* onvif.h:50150 */
struct __tds__SetStorageConfiguration;	/* onvif.h:50219 */
struct __tds__DeleteStorageConfiguration;	/* onvif.h:50289 */
struct __tds__GetServices_;	/* onvif.h:50356 */
struct __tds__GetServiceCapabilities_;	/* onvif.h:50424 */
struct __tds__GetDeviceInformation_;	/* onvif.h:50491 */
struct __tds__SetSystemDateAndTime_;	/* onvif.h:50572 */
struct __tds__GetSystemDateAndTime_;	/* onvif.h:50645 */
struct __tds__SetSystemFactoryDefault_;	/* onvif.h:50712 */
struct __tds__UpgradeSystemFirmware_;	/* onvif.h:50785 */
struct __tds__SystemReboot_;	/* onvif.h:50852 */
struct __tds__RestoreSystem_;	/* onvif.h:50927 */
struct __tds__GetSystemBackup_;	/* onvif.h:51001 */
struct __tds__GetSystemLog_;	/* onvif.h:51069 */
struct __tds__GetSystemSupportInformation_;	/* onvif.h:51136 */
struct __tds__GetScopes_;	/* onvif.h:51218 */
struct __tds__SetScopes_;	/* onvif.h:51293 */
struct __tds__AddScopes_;	/* onvif.h:51364 */
struct __tds__RemoveScopes_;	/* onvif.h:51437 */
struct __tds__GetDiscoveryMode_;	/* onvif.h:51508 */
struct __tds__SetDiscoveryMode_;	/* onvif.h:51580 */
struct __tds__GetRemoteDiscoveryMode_;	/* onvif.h:51653 */
struct __tds__SetRemoteDiscoveryMode_;	/* onvif.h:51726 */
struct __tds__GetDPAddresses_;	/* onvif.h:51797 */
struct __tds__GetEndpointReference_;	/* onvif.h:51870 */
struct __tds__GetRemoteUser_;	/* onvif.h:51943 */
struct __tds__SetRemoteUser_;	/* onvif.h:52021 */
struct __tds__GetUsers_;	/* onvif.h:52092 */
struct __tds__CreateUsers_;	/* onvif.h:52171 */
struct __tds__DeleteUsers_;	/* onvif.h:52245 */
struct __tds__SetUser_;	/* onvif.h:52317 */
struct __tds__GetWsdlUrl_;	/* onvif.h:52391 */
struct __tds__GetCapabilities_;	/* onvif.h:52467 */
struct __tds__SetDPAddresses_;	/* onvif.h:52539 */
struct __tds__GetHostname_;	/* onvif.h:52609 */
struct __tds__SetHostname_;	/* onvif.h:52683 */
struct __tds__SetHostnameFromDHCP_;	/* onvif.h:52750 */
struct __tds__GetDNS_;	/* onvif.h:52819 */
struct __tds__SetDNS_;	/* onvif.h:52888 */
struct __tds__GetNTP_;	/* onvif.h:52958 */
struct __tds__SetNTP_;	/* onvif.h:53035 */
struct __tds__GetDynamicDNS_;	/* onvif.h:53106 */
struct __tds__SetDynamicDNS_;	/* onvif.h:53177 */
struct __tds__GetNetworkInterfaces_;	/* onvif.h:53248 */
struct __tds__SetNetworkInterfaces_;	/* onvif.h:53324 */
struct __tds__GetNetworkProtocols_;	/* onvif.h:53394 */
struct __tds__SetNetworkProtocols_;	/* onvif.h:53464 */
struct __tds__GetNetworkDefaultGateway_;	/* onvif.h:53534 */
struct __tds__SetNetworkDefaultGateway_;	/* onvif.h:53603 */
struct __tds__GetZeroConfiguration_;	/* onvif.h:53677 */
struct __tds__SetZeroConfiguration_;	/* onvif.h:53745 */
struct __tds__GetIPAddressFilter_;	/* onvif.h:53816 */
struct __tds__SetIPAddressFilter_;	/* onvif.h:53889 */
struct __tds__AddIPAddressFilter_;	/* onvif.h:53961 */
struct __tds__RemoveIPAddressFilter_;	/* onvif.h:54033 */
struct __tds__GetAccessPolicy_;	/* onvif.h:54114 */
struct __tds__SetAccessPolicy_;	/* onvif.h:54186 */
struct __tds__CreateCertificate_;	/* onvif.h:54268 */
struct __tds__GetCertificates_;	/* onvif.h:54347 */
struct __tds__GetCertificatesStatus_;	/* onvif.h:54417 */
struct __tds__SetCertificatesStatus_;	/* onvif.h:54489 */
struct __tds__DeleteCertificates_;	/* onvif.h:54564 */
struct __tds__GetPkcs10Request_;	/* onvif.h:54644 */
struct __tds__LoadCertificates_;	/* onvif.h:54734 */
struct __tds__GetClientCertificateMode_;	/* onvif.h:54804 */
struct __tds__SetClientCertificateMode_;	/* onvif.h:54874 */
struct __tds__GetRelayOutputs_;	/* onvif.h:54943 */
struct __tds__SetRelayOutputSettings_;	/* onvif.h:55012 */
struct __tds__SetRelayOutputState_;	/* onvif.h:55081 */
struct __tds__SendAuxiliaryCommand_;	/* onvif.h:55179 */
struct __tds__GetCACertificates_;	/* onvif.h:55257 */
struct __tds__LoadCertificateWithPrivateKey_;	/* onvif.h:55347 */
struct __tds__GetCertificateInformation_;	/* onvif.h:55424 */
struct __tds__LoadCACertificates_;	/* onvif.h:55508 */
struct __tds__CreateDot1XConfiguration_;	/* onvif.h:55583 */
struct __tds__SetDot1XConfiguration_;	/* onvif.h:55654 */
struct __tds__GetDot1XConfiguration_;	/* onvif.h:55729 */
struct __tds__GetDot1XConfigurations_;	/* onvif.h:55807 */
struct __tds__DeleteDot1XConfiguration_;	/* onvif.h:55879 */
struct __tds__GetDot11Capabilities_;	/* onvif.h:55947 */
struct __tds__GetDot11Status_;	/* onvif.h:56016 */
struct __tds__ScanAvailableDot11Networks_;	/* onvif.h:56085 */
struct __tds__GetSystemUris_;	/* onvif.h:56171 */
struct __tds__StartFirmwareUpgrade_;	/* onvif.h:56266 */
struct __tds__StartSystemRestore_;	/* onvif.h:56360 */
struct __tds__GetStorageConfigurations_;	/* onvif.h:56430 */
struct __tds__CreateStorageConfiguration_;	/* onvif.h:56501 */
struct __tds__GetStorageConfiguration_;	/* onvif.h:56571 */
struct __tds__SetStorageConfiguration_;	/* onvif.h:56640 */
struct __tds__DeleteStorageConfiguration_;	/* onvif.h:56710 */
struct __tev__PullMessages;	/* onvif.h:56809 */
struct __tev__Seek;	/* onvif.h:56890 */
struct __tev__SetSynchronizationPoint;	/* onvif.h:56972 */
struct __tev__GetServiceCapabilities;	/* onvif.h:57040 */
struct __tev__CreatePullPointSubscription;	/* onvif.h:57149 */
struct __tev__GetEventProperties;	/* onvif.h:57223 */
struct __tev__Renew;	/* onvif.h:57295 */
struct __tev__Unsubscribe;	/* onvif.h:57367 */
struct __tev__Subscribe;	/* onvif.h:57469 */
struct __tev__GetCurrentMessage;	/* onvif.h:57553 */
struct __tev__Notify;	/* onvif.h:57615 */
struct __tev__GetMessages;	/* onvif.h:57687 */
struct __tev__DestroyPullPoint;	/* onvif.h:57759 */
struct __tev__Notify_;	/* onvif.h:57821 */
struct __tev__CreatePullPoint;	/* onvif.h:57890 */
struct __tev__Renew_;	/* onvif.h:57962 */
struct __tev__Unsubscribe_;	/* onvif.h:58034 */
struct __tev__PauseSubscription;	/* onvif.h:58106 */
struct __tev__ResumeSubscription;	/* onvif.h:58178 */
struct __timg__GetServiceCapabilities;	/* onvif.h:58264 */
struct __timg__GetImagingSettings;	/* onvif.h:58331 */
struct __timg__SetImagingSettings;	/* onvif.h:58398 */
struct __timg__GetOptions;	/* onvif.h:58475 */
struct __timg__Move;	/* onvif.h:58564 */
struct __timg__Stop;	/* onvif.h:58634 */
struct __timg__GetStatus;	/* onvif.h:58703 */
struct __timg__GetMoveOptions;	/* onvif.h:58770 */
struct __tls__GetServiceCapabilities;	/* onvif.h:58856 */
struct __tls__GetLayout;	/* onvif.h:58927 */
struct __tls__SetLayout;	/* onvif.h:59003 */
struct __tls__GetDisplayOptions;	/* onvif.h:59074 */
struct __tls__GetPaneConfigurations;	/* onvif.h:59149 */
struct __tls__GetPaneConfiguration;	/* onvif.h:59216 */
struct __tls__SetPaneConfigurations;	/* onvif.h:59287 */
struct __tls__SetPaneConfiguration;	/* onvif.h:59354 */
struct __tls__CreatePaneConfiguration;	/* onvif.h:59427 */
struct __tls__DeletePaneConfiguration;	/* onvif.h:59498 */
struct __tmd__GetServiceCapabilities;	/* onvif.h:59584 */
struct __tmd__GetRelayOutputOptions;	/* onvif.h:59676 */
struct __tmd__GetAudioSources;	/* onvif.h:59745 */
struct __tmd__GetAudioOutputs;	/* onvif.h:59814 */
struct __tmd__GetVideoSources;	/* onvif.h:59883 */
struct __tmd__GetVideoOutputs;	/* onvif.h:59952 */
struct __tmd__GetVideoSourceConfiguration;	/* onvif.h:60020 */
struct __tmd__GetVideoOutputConfiguration;	/* onvif.h:60088 */
struct __tmd__GetAudioSourceConfiguration;	/* onvif.h:60156 */
struct __tmd__GetAudioOutputConfiguration;	/* onvif.h:60225 */
struct __tmd__SetVideoSourceConfiguration;	/* onvif.h:60293 */
struct __tmd__SetVideoOutputConfiguration;	/* onvif.h:60361 */
struct __tmd__SetAudioSourceConfiguration;	/* onvif.h:60429 */
struct __tmd__SetAudioOutputConfiguration;	/* onvif.h:60497 */
struct __tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:60565 */
struct __tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:60634 */
struct __tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:60702 */
struct __tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:60770 */
struct __tmd__GetRelayOutputs;	/* onvif.h:60837 */
struct __tmd__SetRelayOutputSettings;	/* onvif.h:60926 */
struct __tmd__SetRelayOutputState;	/* onvif.h:60993 */
struct __tmd__GetDigitalInputs;	/* onvif.h:61060 */
struct __tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:61127 */
struct __tmd__SetDigitalInputConfigurations;	/* onvif.h:61194 */
struct __tmd__GetSerialPorts;	/* onvif.h:61260 */
struct __tmd__GetSerialPortConfiguration;	/* onvif.h:61326 */
struct __tmd__SetSerialPortConfiguration;	/* onvif.h:61392 */
struct __tmd__GetSerialPortConfigurationOptions;	/* onvif.h:61458 */
struct __tmd__SendReceiveSerialCommand;	/* onvif.h:61524 */
struct __tptz__GetServiceCapabilities;	/* onvif.h:61609 */
struct __tptz__GetConfigurations;	/* onvif.h:61705 */
struct __tptz__GetPresets;	/* onvif.h:61775 */
struct __tptz__SetPreset;	/* onvif.h:61860 */
struct __tptz__RemovePreset;	/* onvif.h:61934 */
struct __tptz__GotoPreset;	/* onvif.h:62004 */
struct __tptz__GetStatus;	/* onvif.h:62074 */
struct __tptz__GetConfiguration;	/* onvif.h:62170 */
struct __tptz__GetNodes;	/* onvif.h:62248 */
struct __tptz__GetNode;	/* onvif.h:62317 */
struct __tptz__SetConfiguration;	/* onvif.h:62386 */
struct __tptz__GetConfigurationOptions;	/* onvif.h:62465 */
struct __tptz__GotoHomePosition;	/* onvif.h:62534 */
struct __tptz__SetHomePosition;	/* onvif.h:62606 */
struct __tptz__ContinuousMove;	/* onvif.h:62676 */
struct __tptz__RelativeMove;	/* onvif.h:62751 */
struct __tptz__SendAuxiliaryCommand;	/* onvif.h:62823 */
struct __tptz__AbsoluteMove;	/* onvif.h:62897 */
struct __tptz__Stop;	/* onvif.h:62967 */
struct __tptz__GetPresetTours;	/* onvif.h:63034 */
struct __tptz__GetPresetTour;	/* onvif.h:63101 */
struct __tptz__GetPresetTourOptions;	/* onvif.h:63168 */
struct __tptz__CreatePresetTour;	/* onvif.h:63235 */
struct __tptz__ModifyPresetTour;	/* onvif.h:63302 */
struct __tptz__OperatePresetTour;	/* onvif.h:63369 */
struct __tptz__RemovePresetTour;	/* onvif.h:63436 */
struct __tptz__GetCompatibleConfigurations;	/* onvif.h:63511 */
struct __trc__GetServiceCapabilities;	/* onvif.h:63597 */
struct __trc__CreateRecording;	/* onvif.h:63684 */
struct __trc__DeleteRecording;	/* onvif.h:63764 */
struct __trc__GetRecordings;	/* onvif.h:63834 */
struct __trc__SetRecordingConfiguration;	/* onvif.h:63901 */
struct __trc__GetRecordingConfiguration;	/* onvif.h:63968 */
struct __trc__GetRecordingOptions;	/* onvif.h:64037 */
struct __trc__CreateTrack;	/* onvif.h:64110 */
struct __trc__DeleteTrack;	/* onvif.h:64181 */
struct __trc__GetTrackConfiguration;	/* onvif.h:64248 */
struct __trc__SetTrackConfiguration;	/* onvif.h:64315 */
struct __trc__CreateRecordingJob;	/* onvif.h:64390 */
struct __trc__DeleteRecordingJob;	/* onvif.h:64463 */
struct __trc__GetRecordingJobs;	/* onvif.h:64530 */
struct __trc__SetRecordingJobConfiguration;	/* onvif.h:64602 */
struct __trc__GetRecordingJobConfiguration;	/* onvif.h:64670 */
struct __trc__SetRecordingJobMode;	/* onvif.h:64741 */
struct __trc__GetRecordingJobState;	/* onvif.h:64810 */
struct __trc__ExportRecordedData;	/* onvif.h:64880 */
struct __trc__StopExportRecordedData;	/* onvif.h:64949 */
struct __trc__GetExportRecordedDataState;	/* onvif.h:65019 */
struct __trp__GetServiceCapabilities;	/* onvif.h:65105 */
struct __trp__GetReplayUri;	/* onvif.h:65179 */
struct __trp__GetReplayConfiguration;	/* onvif.h:65250 */
struct __trp__SetReplayConfiguration;	/* onvif.h:65321 */
struct __trt__GetServiceCapabilities;	/* onvif.h:65407 */
struct __trt__GetVideoSources;	/* onvif.h:65474 */
struct __trt__GetAudioSources;	/* onvif.h:65541 */
struct __trt__GetAudioOutputs;	/* onvif.h:65608 */
struct __trt__CreateProfile;	/* onvif.h:65679 */
struct __trt__GetProfile;	/* onvif.h:65747 */
struct __trt__GetProfiles;	/* onvif.h:65819 */
struct __trt__AddVideoEncoderConfiguration;	/* onvif.h:65893 */
struct __trt__AddVideoSourceConfiguration;	/* onvif.h:65963 */
struct __trt__AddAudioEncoderConfiguration;	/* onvif.h:66037 */
struct __trt__AddAudioSourceConfiguration;	/* onvif.h:66107 */
struct __trt__AddPTZConfiguration;	/* onvif.h:66181 */
struct __trt__AddVideoAnalyticsConfiguration;	/* onvif.h:66258 */
struct __trt__AddMetadataConfiguration;	/* onvif.h:66329 */
struct __trt__AddAudioOutputConfiguration;	/* onvif.h:66398 */
struct __trt__AddAudioDecoderConfiguration;	/* onvif.h:66467 */
struct __trt__RemoveVideoEncoderConfiguration;	/* onvif.h:66537 */
struct __trt__RemoveVideoSourceConfiguration;	/* onvif.h:66609 */
struct __trt__RemoveAudioEncoderConfiguration;	/* onvif.h:66680 */
struct __trt__RemoveAudioSourceConfiguration;	/* onvif.h:66753 */
struct __trt__RemovePTZConfiguration;	/* onvif.h:66823 */
struct __trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:66893 */
struct __trt__RemoveMetadataConfiguration;	/* onvif.h:66962 */
struct __trt__RemoveAudioOutputConfiguration;	/* onvif.h:67031 */
struct __trt__RemoveAudioDecoderConfiguration;	/* onvif.h:67100 */
struct __trt__DeleteProfile;	/* onvif.h:67168 */
struct __trt__GetVideoSourceConfigurations;	/* onvif.h:67237 */
struct __trt__GetVideoEncoderConfigurations;	/* onvif.h:67307 */
struct __trt__GetAudioSourceConfigurations;	/* onvif.h:67377 */
struct __trt__GetAudioEncoderConfigurations;	/* onvif.h:67446 */
struct __trt__GetVideoAnalyticsConfigurations;	/* onvif.h:67515 */
struct __trt__GetMetadataConfigurations;	/* onvif.h:67583 */
struct __trt__GetAudioOutputConfigurations;	/* onvif.h:67651 */
struct __trt__GetAudioDecoderConfigurations;	/* onvif.h:67721 */
struct __trt__GetVideoSourceConfiguration;	/* onvif.h:67789 */
struct __trt__GetVideoEncoderConfiguration;	/* onvif.h:67857 */
struct __trt__GetAudioSourceConfiguration;	/* onvif.h:67925 */
struct __trt__GetAudioEncoderConfiguration;	/* onvif.h:67993 */
struct __trt__GetVideoAnalyticsConfiguration;	/* onvif.h:68061 */
struct __trt__GetMetadataConfiguration;	/* onvif.h:68129 */
struct __trt__GetAudioOutputConfiguration;	/* onvif.h:68197 */
struct __trt__GetAudioDecoderConfiguration;	/* onvif.h:68265 */
struct __trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:68336 */
struct __trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:68409 */
struct __trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:68480 */
struct __trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:68551 */
struct __trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:68622 */
struct __trt__GetCompatibleMetadataConfigurations;	/* onvif.h:68693 */
struct __trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:68763 */
struct __trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:68833 */
struct __trt__SetVideoSourceConfiguration;	/* onvif.h:68905 */
struct __trt__SetVideoEncoderConfiguration;	/* onvif.h:68981 */
struct __trt__SetAudioSourceConfiguration;	/* onvif.h:69055 */
struct __trt__SetAudioEncoderConfiguration;	/* onvif.h:69130 */
struct __trt__SetVideoAnalyticsConfiguration;	/* onvif.h:69207 */
struct __trt__SetMetadataConfiguration;	/* onvif.h:69283 */
struct __trt__SetAudioOutputConfiguration;	/* onvif.h:69352 */
struct __trt__SetAudioDecoderConfiguration;	/* onvif.h:69421 */
struct __trt__GetVideoSourceConfigurationOptions;	/* onvif.h:69494 */
struct __trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:69575 */
struct __trt__GetAudioSourceConfigurationOptions;	/* onvif.h:69648 */
struct __trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:69717 */
struct __trt__GetMetadataConfigurationOptions;	/* onvif.h:69785 */
struct __trt__GetAudioOutputConfigurationOptions;	/* onvif.h:69853 */
struct __trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:69922 */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:69991 */
struct __trt__GetStreamUri;	/* onvif.h:70082 */
struct __trt__StartMulticastStreaming;	/* onvif.h:70156 */
struct __trt__StopMulticastStreaming;	/* onvif.h:70223 */
struct __trt__SetSynchronizationPoint;	/* onvif.h:70307 */
struct __trt__GetSnapshotUri;	/* onvif.h:70384 */
struct __trt__GetVideoSourceModes;	/* onvif.h:70453 */
struct __trt__SetVideoSourceMode;	/* onvif.h:70523 */
struct __trt__GetOSDs;	/* onvif.h:70590 */
struct __trt__GetOSD;	/* onvif.h:70657 */
struct __trt__GetOSDOptions;	/* onvif.h:70724 */
struct __trt__SetOSD;	/* onvif.h:70791 */
struct __trt__CreateOSD;	/* onvif.h:70858 */
struct __trt__DeleteOSD;	/* onvif.h:70925 */
struct __trv__GetServiceCapabilities;	/* onvif.h:71011 */
struct __trv__GetReceivers;	/* onvif.h:71081 */
struct __trv__GetReceiver;	/* onvif.h:71151 */
struct __trv__CreateReceiver;	/* onvif.h:71222 */
struct __trv__DeleteReceiver;	/* onvif.h:71294 */
struct __trv__ConfigureReceiver;	/* onvif.h:71364 */
struct __trv__SetReceiverMode;	/* onvif.h:71435 */
struct __trv__GetReceiverState;	/* onvif.h:71507 */
struct __tse__GetServiceCapabilities;	/* onvif.h:71593 */
struct __tse__GetRecordingSummary;	/* onvif.h:71662 */
struct __tse__GetRecordingInformation;	/* onvif.h:71732 */
struct __tse__GetMediaAttributes;	/* onvif.h:71809 */
struct __tse__FindRecordings;	/* onvif.h:71898 */
struct __tse__GetRecordingSearchResults;	/* onvif.h:71984 */
struct __tse__FindEvents;	/* onvif.h:72075 */
struct __tse__GetEventSearchResults;	/* onvif.h:72159 */
struct __tse__FindPTZPosition;	/* onvif.h:72248 */
struct __tse__GetPTZPositionSearchResults;	/* onvif.h:72333 */
struct __tse__GetSearchState;	/* onvif.h:72401 */
struct __tse__EndSearch;	/* onvif.h:72483 */
struct __tse__FindMetadata;	/* onvif.h:72573 */
struct __tse__GetMetadataSearchResults;	/* onvif.h:72658 */

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (9)
/* wsu:Timestamp complex type: */
struct _wsu__Timestamp
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Created;	/* optional element of XSD type xsd:string */
	char *Expires;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 9; } /* = unique type id SOAP_TYPE__wsu__Timestamp */
	         _wsu__Timestamp();
	virtual ~_wsu__Timestamp() { }
	friend _wsu__Timestamp *soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:114 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (11)
/* wsse:UsernameToken complex type: */
struct _wsse__UsernameToken
{
public:
	char *Username;	/* optional element of XSD type xsd:string */
	struct _wsse__Password *Password;	/* optional element of XSD type wsse:Password */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Created;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__wsse__UsernameToken */
	         _wsse__UsernameToken();
	virtual ~_wsse__UsernameToken() { }
	friend _wsse__UsernameToken *soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:125 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (14)
/* wsse:BinarySecurityToken simple type: */
struct _wsse__BinarySecurityToken
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__wsse__BinarySecurityToken */
	         _wsse__BinarySecurityToken();
	virtual ~_wsse__BinarySecurityToken() { }
	friend _wsse__BinarySecurityToken *soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:135 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (15)
/* wsse:Reference complex type: */
struct _wsse__Reference
{
public:
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__wsse__Reference */
	         _wsse__Reference();
	virtual ~_wsse__Reference() { }
	friend _wsse__Reference *soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:143 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (16)
/* wsse:Embedded complex type: */
struct _wsse__Embedded
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__wsse__Embedded */
	         _wsse__Embedded();
	virtual ~_wsse__Embedded() { }
	friend _wsse__Embedded *soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:152 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (17)
/* wsse:KeyIdentifier simple type: */
struct _wsse__KeyIdentifier
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__wsse__KeyIdentifier */
	         _wsse__KeyIdentifier();
	virtual ~_wsse__KeyIdentifier() { }
	friend _wsse__KeyIdentifier *soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:162 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (18)
/* wsse:SecurityTokenReference complex type: */
struct _wsse__SecurityTokenReference
{
public:
	struct _wsse__Reference *Reference;	/* optional element of XSD type wsse:Reference */
	struct _wsse__KeyIdentifier *KeyIdentifier;	/* optional element of XSD type wsse:KeyIdentifier */
	struct _wsse__Embedded *Embedded;	/* optional element of XSD type wsse:Embedded */
	struct ds__X509DataType *ds__X509Data;	/* optional element of XSD type ds:X509DataType */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *wsc__Instance;	/* optional attribute of XSD type xsd:string */
	char *Usage;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 18; } /* = unique type id SOAP_TYPE__wsse__SecurityTokenReference */
	         _wsse__SecurityTokenReference();
	virtual ~_wsse__SecurityTokenReference() { }
	friend _wsse__SecurityTokenReference *soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (24)
/* ds:SignatureType complex type: */
struct ds__SignatureType
{
public:
	struct ds__SignedInfoType *SignedInfo;	/* optional element of XSD type ds:SignedInfoType */
	char *SignatureValue;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *KeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_ds__SignatureType */
	         ds__SignatureType();
	virtual ~ds__SignatureType() { }
	friend ds__SignatureType *soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (34)
/* c14n:InclusiveNamespaces complex type: */
struct _c14n__InclusiveNamespaces
{
public:
	char *PrefixList;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
	         _c14n__InclusiveNamespaces();
	virtual ~_c14n__InclusiveNamespaces() { }
	friend _c14n__InclusiveNamespaces *soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:74 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (35)
/* ds:TransformType complex type: */
struct ds__TransformType
{
public:
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
	char *__any;
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_ds__TransformType */
	         ds__TransformType();
	virtual ~ds__TransformType() { }
	friend ds__TransformType *soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:49 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (27)
/* ds:KeyInfoType complex type: */
struct ds__KeyInfoType
{
public:
	char *KeyName;	/* optional element of XSD type xsd:string */
	struct ds__KeyValueType *KeyValue;	/* optional element of XSD type ds:KeyValueType */
	struct ds__RetrievalMethodType *RetrievalMethod;	/* optional element of XSD type ds:RetrievalMethodType */
	struct ds__X509DataType *X509Data;	/* optional element of XSD type ds:X509DataType */
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_ds__KeyInfoType */
	         ds__KeyInfoType();
	virtual ~ds__KeyInfoType() { }
	friend ds__KeyInfoType *soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (25)
/* ds:SignedInfoType complex type: */
struct ds__SignedInfoType
{
public:
	struct ds__CanonicalizationMethodType *CanonicalizationMethod;	/* required element of XSD type ds:CanonicalizationMethodType */
	struct ds__SignatureMethodType *SignatureMethod;	/* required element of XSD type ds:SignatureMethodType */
	int __sizeReference;	/* sequence of elements <Reference> of XSD type ds:ReferenceType */
	struct ds__ReferenceType **Reference;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_ds__SignedInfoType */
	         ds__SignedInfoType();
	virtual ~ds__SignedInfoType() { }
	friend ds__SignedInfoType *soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:60 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (30)
/* ds:CanonicalizationMethodType complex type: */
struct ds__CanonicalizationMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
public:
	int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
	         ds__CanonicalizationMethodType();
	virtual ~ds__CanonicalizationMethodType() { }
	friend ds__CanonicalizationMethodType *soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:63 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (31)
/* ds:SignatureMethodType complex type: */
struct ds__SignatureMethodType
{
public:
	int *HMACOutputLength;	/* optional element of XSD type xsd:int */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_ds__SignatureMethodType */
	         ds__SignatureMethodType();
	virtual ~ds__SignatureMethodType() { }
	friend ds__SignatureMethodType *soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:66 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (32)
/* ds:ReferenceType complex type: */
struct ds__ReferenceType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	struct ds__DigestMethodType *DigestMethod;	/* required element of XSD type ds:DigestMethodType */
	char *DigestValue;	/* required element of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_ds__ReferenceType */
	         ds__ReferenceType();
	virtual ~ds__ReferenceType() { }
	friend ds__ReferenceType *soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:69 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (33)
/* ds:TransformsType complex type: */
struct ds__TransformsType
{
public:
	int __sizeTransform;	/* sequence of elements <Transform> of XSD type ds:TransformType */
	struct ds__TransformType *Transform;
public:
	int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_ds__TransformsType */
	         ds__TransformsType();
	virtual ~ds__TransformsType() { }
	friend ds__TransformsType *soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:80 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (38)
/* ds:DigestMethodType complex type: */
struct ds__DigestMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_ds__DigestMethodType */
	         ds__DigestMethodType();
	virtual ~ds__DigestMethodType() { }
	friend ds__DigestMethodType *soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:86 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (39)
/* ds:KeyValueType complex type: */
struct ds__KeyValueType
{
public:
	struct ds__DSAKeyValueType *DSAKeyValue;	/* optional element of XSD type ds:DSAKeyValueType */
	struct ds__RSAKeyValueType *RSAKeyValue;	/* optional element of XSD type ds:RSAKeyValueType */
public:
	int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_ds__KeyValueType */
	         ds__KeyValueType();
	virtual ~ds__KeyValueType() { }
	friend ds__KeyValueType *soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:87 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (41)
/* ds:RetrievalMethodType complex type: */
struct ds__RetrievalMethodType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_ds__RetrievalMethodType */
	         ds__RetrievalMethodType();
	virtual ~ds__RetrievalMethodType() { }
	friend ds__RetrievalMethodType *soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:165 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (22)
/* ds:X509DataType complex type: */
struct ds__X509DataType
{
public:
	struct ds__X509IssuerSerialType *X509IssuerSerial;	/* optional element of XSD type ds:X509IssuerSerialType */
	char *X509SKI;	/* optional element of XSD type xsd:string */
	char *X509SubjectName;	/* optional element of XSD type xsd:string */
	char *X509Certificate;	/* optional element of XSD type xsd:string */
	char *X509CRL;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_ds__X509DataType */
	         ds__X509DataType();
	virtual ~ds__X509DataType() { }
	friend ds__X509DataType *soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:103 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (45)
/* ds:X509IssuerSerialType complex type: */
struct ds__X509IssuerSerialType
{
public:
	char *X509IssuerName;	/* required element of XSD type xsd:string */
	char *X509SerialNumber;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ds__X509IssuerSerialType */
	         ds__X509IssuerSerialType();
	virtual ~ds__X509IssuerSerialType() { }
	friend ds__X509IssuerSerialType *soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:124 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (46)
/* ds:DSAKeyValueType complex type: */
struct ds__DSAKeyValueType
{
public:
	char *G;	/* optional element of XSD type xsd:string */
	char *Y;	/* required element of XSD type xsd:string */
	char *J;	/* optional element of XSD type xsd:string */
	char *P;	/* required element of XSD type xsd:string */
	char *Q;	/* required element of XSD type xsd:string */
	char *Seed;	/* required element of XSD type xsd:string */
	char *PgenCounter;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_ds__DSAKeyValueType */
	         ds__DSAKeyValueType();
	virtual ~ds__DSAKeyValueType() { }
	friend ds__DSAKeyValueType *soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:127 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (47)
/* ds:RSAKeyValueType complex type: */
struct ds__RSAKeyValueType
{
public:
	char *Modulus;	/* required element of XSD type xsd:string */
	char *Exponent;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ds__RSAKeyValueType */
	         ds__RSAKeyValueType();
	virtual ~ds__RSAKeyValueType() { }
	friend ds__RSAKeyValueType *soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (69)
/* xenc:EncryptionPropertyType complex type: */
struct xenc__EncryptionPropertyType
{
public:
	char *Target;	/* optional attribute of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
	         xenc__EncryptionPropertyType();
	virtual ~xenc__EncryptionPropertyType() { }
	friend xenc__EncryptionPropertyType *soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (59)
/* xenc:EncryptedType complex type: */
struct xenc__EncryptedType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_xenc__EncryptedType */
	         xenc__EncryptedType();
	virtual ~xenc__EncryptedType() { }
	friend xenc__EncryptedType *soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (60)
/* xenc:EncryptionMethodType complex type: */
struct xenc__EncryptionMethodType
{
public:
	int *KeySize;	/* optional element of XSD type xsd:int */
	char *OAEPparams;	/* optional element of XSD type xsd:string */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct ds__DigestMethodType *ds__DigestMethod;	/* optional element of XSD type ds:DigestMethodType */
	char *__mixed;
public:
	int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_xenc__EncryptionMethodType */
	         xenc__EncryptionMethodType();
	virtual ~xenc__EncryptionMethodType() { }
	friend xenc__EncryptionMethodType *soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (61)
/* xenc:CipherDataType complex type: */
struct xenc__CipherDataType
{
public:
	char *CipherValue;	/* optional element of XSD type xsd:string */
	struct xenc__CipherReferenceType *CipherReference;	/* optional element of XSD type xenc:CipherReferenceType */
public:
	int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_xenc__CipherDataType */
	         xenc__CipherDataType();
	virtual ~xenc__CipherDataType() { }
	friend xenc__CipherDataType *soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (62)
/* xenc:CipherReferenceType complex type: */
struct xenc__CipherReferenceType
{
public:
	struct xenc__TransformsType *Transforms;	/* optional element of XSD type xenc:TransformsType */
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_xenc__CipherReferenceType */
	         xenc__CipherReferenceType();
	virtual ~xenc__CipherReferenceType() { }
	friend xenc__CipherReferenceType *soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (63)
/* xenc:TransformsType complex type: */
struct xenc__TransformsType
{
public:
	struct ds__TransformType ds__Transform;	/* required element of XSD type ds:Transform */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_xenc__TransformsType */
	         xenc__TransformsType();
	virtual ~xenc__TransformsType() { }
	friend xenc__TransformsType *soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (66)
/* xenc:AgreementMethodType complex type: */
struct xenc__AgreementMethodType
{
public:
	char *KA_Nonce;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *OriginatorKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	struct ds__KeyInfoType *RecipientKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	char *__mixed;
public:
	int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_xenc__AgreementMethodType */
	         xenc__AgreementMethodType();
	virtual ~xenc__AgreementMethodType() { }
	friend xenc__AgreementMethodType *soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (67)
/* xenc:ReferenceType complex type: */
struct xenc__ReferenceType
{
public:
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_xenc__ReferenceType */
	         xenc__ReferenceType();
	virtual ~xenc__ReferenceType() { }
	friend xenc__ReferenceType *soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (68)
/* xenc:EncryptionPropertiesType complex type: */
struct xenc__EncryptionPropertiesType
{
public:
	int __sizeEncryptionProperty;	/* sequence of elements <EncryptionProperty> of XSD type xenc:EncryptionPropertyType */
	struct xenc__EncryptionPropertyType *EncryptionProperty;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
	         xenc__EncryptionPropertiesType();
	virtual ~xenc__EncryptionPropertiesType() { }
	friend xenc__EncryptionPropertiesType *soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (78)
/* Operation wrapper: */
struct __xenc__union_ReferenceList
{
public:
	struct xenc__ReferenceType *DataReference;	/* optional element of XSD type xenc:ReferenceType */
	struct xenc__ReferenceType *KeyReference;	/* optional element of XSD type xenc:ReferenceType */
public:
	int soap_type() const { return 78; } /* = unique type id SOAP_TYPE___xenc__union_ReferenceList */
	         __xenc__union_ReferenceList();
	virtual ~__xenc__union_ReferenceList() { }
	friend __xenc__union_ReferenceList *soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (70)
/* xenc:ReferenceList complex type: */
struct _xenc__ReferenceList
{
public:
	int __size_ReferenceList;	/* sequence of elements <-union-ReferenceList> of XSD type -xenc:union-ReferenceList */
	struct __xenc__union_ReferenceList *__union_ReferenceList;
public:
	int soap_type() const { return 70; } /* = unique type id SOAP_TYPE__xenc__ReferenceList */
	         _xenc__ReferenceList();
	virtual ~_xenc__ReferenceList() { }
	friend _xenc__ReferenceList *soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (64)
/* xenc:EncryptedDataType complex type: */
struct xenc__EncryptedDataType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_xenc__EncryptedDataType */
	         xenc__EncryptedDataType();
	virtual ~xenc__EncryptedDataType() { }
	friend xenc__EncryptedDataType *soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (65)
/* xenc:EncryptedKeyType complex type: */
struct xenc__EncryptedKeyType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
	struct _xenc__ReferenceList *ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	char *CarriedKeyName;	/* optional element of XSD type xsd:string */
	char *Recipient;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_xenc__EncryptedKeyType */
	         xenc__EncryptedKeyType();
	virtual ~xenc__EncryptedKeyType() { }
	friend xenc__EncryptedKeyType *soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (84)
/* wsc:SecurityContextTokenType complex type: */
struct wsc__SecurityContextTokenType
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Identifier;	/* optional element of XSD type xsd:string */
	char *Instance;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
	         wsc__SecurityContextTokenType();
	virtual ~wsc__SecurityContextTokenType() { }
	friend wsc__SecurityContextTokenType *soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (90)
/* xsd:choice complex type: */
union _wsc__union_DerivedKeyTokenType
{
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)
	ULONG64 Generation;
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)
	ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (88)
/* Operation wrapper: */
struct __wsc__DerivedKeyTokenType_sequence
{
public:
	int __union_DerivedKeyTokenType;	/* union discriminant (of union defined below) */
	union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
	ULONG64 *Length;	/* optional element of XSD type xsd:unsignedLong */
public:
	int soap_type() const { return 88; } /* = unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
	         __wsc__DerivedKeyTokenType_sequence();
	virtual ~__wsc__DerivedKeyTokenType_sequence() { }
	friend __wsc__DerivedKeyTokenType_sequence *soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (85)
/* wsc:DerivedKeyTokenType complex type: */
struct wsc__DerivedKeyTokenType
{
public:
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	struct wsc__PropertiesType *Properties;	/* optional element of XSD type wsc:PropertiesType */
	struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
	char *Label;	/* optional element of XSD type xsd:string */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
	         wsc__DerivedKeyTokenType();
	virtual ~wsc__DerivedKeyTokenType() { }
	friend wsc__DerivedKeyTokenType *soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (86)
/* wsc:PropertiesType complex type: */
struct wsc__PropertiesType
{
public:
	int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_wsc__PropertiesType */
	         wsc__PropertiesType();
	virtual ~wsc__PropertiesType() { }
	friend wsc__PropertiesType *soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:177 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (93)
/* wsse:Security complex type: */
struct _wsse__Security
{
public:
	struct _wsu__Timestamp *wsu__Timestamp;	/* optional element of XSD type wsu:Timestamp */
	struct _wsse__UsernameToken *UsernameToken;	/* optional element of XSD type wsse:UsernameToken */
	struct _wsse__BinarySecurityToken *BinarySecurityToken;	/* optional element of XSD type wsse:BinarySecurityToken */
	struct xenc__EncryptedKeyType *xenc__EncryptedKey;	/* optional element of XSD type xenc:EncryptedKeyType */
	struct _xenc__ReferenceList *xenc__ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;	/* optional element of XSD type wsc:SecurityContextTokenType */
	struct ds__SignatureType *ds__Signature;	/* optional element of XSD type ds:SignatureType */
	char *SOAP_ENV__actor;	/* optional attribute of XSD type xsd:string */
	char *SOAP_ENV__role;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 93; } /* = unique type id SOAP_TYPE__wsse__Security */
	         _wsse__Security();
	virtual ~_wsse__Security() { }
	friend _wsse__Security *soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:115 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (12)
/* wsse:Password simple type: */
struct _wsse__Password
{
public:
	char *__item;	/* mixed XML content */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 12; } /* = unique type id SOAP_TYPE__wsse__Password */
	         _wsse__Password();
	virtual ~_wsse__Password() { }
	friend _wsse__Password *soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (100)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	struct _wsse__Security *wsse__Security;	/* mustUnderstand */
	char *wsa5__MessageID;	/* optional element of XSD type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of XSD type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of XSD type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct chan__ChannelInstanceType *chan__ChannelInstance;	/* optional element of XSD type chan:ChannelInstanceType */
	struct wsdd__AppSequenceType *wsdd__AppSequence;	/* optional element of XSD type wsdd:AppSequenceType */
public:
	int soap_type() const { return 100; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
	friend SOAP_ENV__Header *soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:63 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (105)
/* wsa5:EndpointReferenceType complex type: */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of XSD type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 105; } /* = unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
	         wsa5__EndpointReferenceType();
	virtual ~wsa5__EndpointReferenceType() { }
	friend wsa5__EndpointReferenceType *soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:66 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (106)
/* wsa5:ReferenceParametersType complex type: */
struct wsa5__ReferenceParametersType
{
public:
	int *chan__ChannelInstance;	/* optional element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 106; } /* = unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
	         wsa5__ReferenceParametersType();
	virtual ~wsa5__ReferenceParametersType() { }
	friend wsa5__ReferenceParametersType *soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:69 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (107)
/* wsa5:MetadataType complex type: */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE_wsa5__MetadataType */
	         wsa5__MetadataType();
	virtual ~wsa5__MetadataType() { }
	friend wsa5__MetadataType *soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:84 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (109)
/* wsa5:ProblemActionType complex type: */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of XSD type xsd:string */
	char *SoapAction;	/* optional element of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 109; } /* = unique type id SOAP_TYPE_wsa5__ProblemActionType */
	         wsa5__ProblemActionType();
	virtual ~wsa5__ProblemActionType() { }
	friend wsa5__ProblemActionType *soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:72 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (108)
/* wsa5:RelatesToType simple type: */
struct wsa5__RelatesToType
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 108; } /* = unique type id SOAP_TYPE_wsa5__RelatesToType */
	         wsa5__RelatesToType();
	virtual ~wsa5__RelatesToType() { }
	friend wsa5__RelatesToType *soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:258 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (132)
/* chan:ChannelInstanceType simple type: */
struct chan__ChannelInstanceType
{
public:
	int __item;	/* mixed XML content */
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/* optional attribute of XSD type wsa5:IsReferenceParameter */
public:
	int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_chan__ChannelInstanceType */
	         chan__ChannelInstanceType();
	virtual ~chan__ChannelInstanceType() { }
	friend chan__ChannelInstanceType *soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:282 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (140)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 140; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
	friend SOAP_ENV__Code *soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (142)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 142; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
	friend SOAP_ENV__Reason *soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:288 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (146)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 146; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
	friend SOAP_ENV__Fault *soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsdd.h:55 */
#ifndef SOAP_TYPE_wsdd__HelloType
#define SOAP_TYPE_wsdd__HelloType (147)
/* wsdd:HelloType complex type: */
struct wsdd__HelloType
{
public:
	struct wsa5__EndpointReferenceType wsa5__EndpointReference;	/* required element of XSD type wsa5:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE_wsdd__HelloType */
	         wsdd__HelloType();
	virtual ~wsdd__HelloType() { }
	friend wsdd__HelloType *soap_instantiate_wsdd__HelloType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:58 */
#ifndef SOAP_TYPE_wsdd__ByeType
#define SOAP_TYPE_wsdd__ByeType (148)
/* wsdd:ByeType complex type: */
struct wsdd__ByeType
{
public:
	struct wsa5__EndpointReferenceType wsa5__EndpointReference;	/* required element of XSD type wsa5:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int *MetadataVersion;	/* optional element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 148; } /* = unique type id SOAP_TYPE_wsdd__ByeType */
	         wsdd__ByeType();
	virtual ~wsdd__ByeType() { }
	friend wsdd__ByeType *soap_instantiate_wsdd__ByeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:61 */
#ifndef SOAP_TYPE_wsdd__ProbeType
#define SOAP_TYPE_wsdd__ProbeType (149)
/* wsdd:ProbeType complex type: */
struct wsdd__ProbeType
{
public:
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
public:
	int soap_type() const { return 149; } /* = unique type id SOAP_TYPE_wsdd__ProbeType */
	         wsdd__ProbeType();
	virtual ~wsdd__ProbeType() { }
	friend wsdd__ProbeType *soap_instantiate_wsdd__ProbeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:64 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchesType
#define SOAP_TYPE_wsdd__ProbeMatchesType (150)
/* wsdd:ProbeMatchesType complex type: */
struct wsdd__ProbeMatchesType
{
public:
	int __sizeProbeMatch;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ProbeMatch> of XSD type wsdd:ProbeMatchType */
	struct wsdd__ProbeMatchType *ProbeMatch;
public:
	int soap_type() const { return 150; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchesType */
	         wsdd__ProbeMatchesType();
	virtual ~wsdd__ProbeMatchesType() { }
	friend wsdd__ProbeMatchesType *soap_instantiate_wsdd__ProbeMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:67 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchType
#define SOAP_TYPE_wsdd__ProbeMatchType (151)
/* wsdd:ProbeMatchType complex type: */
struct wsdd__ProbeMatchType
{
public:
	struct wsa5__EndpointReferenceType wsa5__EndpointReference;	/* required element of XSD type wsa5:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchType */
	         wsdd__ProbeMatchType();
	virtual ~wsdd__ProbeMatchType() { }
	friend wsdd__ProbeMatchType *soap_instantiate_wsdd__ProbeMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:70 */
#ifndef SOAP_TYPE_wsdd__ResolveType
#define SOAP_TYPE_wsdd__ResolveType (152)
/* wsdd:ResolveType complex type: */
struct wsdd__ResolveType
{
public:
	struct wsa5__EndpointReferenceType wsa5__EndpointReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReference */
public:
	int soap_type() const { return 152; } /* = unique type id SOAP_TYPE_wsdd__ResolveType */
	         wsdd__ResolveType();
	virtual ~wsdd__ResolveType() { }
	friend wsdd__ResolveType *soap_instantiate_wsdd__ResolveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:73 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchesType
#define SOAP_TYPE_wsdd__ResolveMatchesType (153)
/* wsdd:ResolveMatchesType complex type: */
struct wsdd__ResolveMatchesType
{
public:
	struct wsdd__ResolveMatchType *ResolveMatch;	/* optional element of XSD type wsdd:ResolveMatchType */
public:
	int soap_type() const { return 153; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchesType */
	         wsdd__ResolveMatchesType();
	virtual ~wsdd__ResolveMatchesType() { }
	friend wsdd__ResolveMatchesType *soap_instantiate_wsdd__ResolveMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:76 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchType
#define SOAP_TYPE_wsdd__ResolveMatchType (154)
/* wsdd:ResolveMatchType complex type: */
struct wsdd__ResolveMatchType
{
public:
	struct wsa5__EndpointReferenceType wsa5__EndpointReference;	/* required element of XSD type wsa5:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 154; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchType */
	         wsdd__ResolveMatchType();
	virtual ~wsdd__ResolveMatchType() { }
	friend wsdd__ResolveMatchType *soap_instantiate_wsdd__ResolveMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:82 */
#ifndef SOAP_TYPE_wsdd__SecurityType
#define SOAP_TYPE_wsdd__SecurityType (156)
/* wsdd:SecurityType complex type: */
struct wsdd__SecurityType
{
public:
	struct wsdd__SigType *Sig;	/* optional element of XSD type wsdd:SigType */
public:
	int soap_type() const { return 156; } /* = unique type id SOAP_TYPE_wsdd__SecurityType */
	         wsdd__SecurityType();
	virtual ~wsdd__SecurityType() { }
	friend wsdd__SecurityType *soap_instantiate_wsdd__SecurityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:85 */
#ifndef SOAP_TYPE_wsdd__SigType
#define SOAP_TYPE_wsdd__SigType (157)
/* wsdd:SigType complex type: */
struct wsdd__SigType
{
public:
	char *Scheme;	/* required attribute of XSD type xsd:string */
	char *KeyId;	/* optional attribute of XSD type xsd:string */
	char *Refs;	/* required attribute of XSD type xsd:string */
	char *Sig;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 157; } /* = unique type id SOAP_TYPE_wsdd__SigType */
	         wsdd__SigType();
	virtual ~wsdd__SigType() { }
	friend wsdd__SigType *soap_instantiate_wsdd__SigType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:79 */
#ifndef SOAP_TYPE_wsdd__ScopesType
#define SOAP_TYPE_wsdd__ScopesType (155)
/* wsdd:ScopesType simple type: */
struct wsdd__ScopesType
{
public:
	char *__item;	/* mixed XML content */
	char *MatchBy;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE_wsdd__ScopesType */
	         wsdd__ScopesType();
	virtual ~wsdd__ScopesType() { }
	friend wsdd__ScopesType *soap_instantiate_wsdd__ScopesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd.h:88 */
#ifndef SOAP_TYPE_wsdd__AppSequenceType
#define SOAP_TYPE_wsdd__AppSequenceType (158)
/* wsdd:AppSequenceType complex type: */
struct wsdd__AppSequenceType
{
public:
	unsigned int InstanceId;	/* required attribute of XSD type xsd:unsignedInt */
	char *SequenceId;	/* optional attribute of XSD type xsd:string */
	unsigned int MessageNumber;	/* required attribute of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_wsdd__AppSequenceType */
	         wsdd__AppSequenceType();
	virtual ~wsdd__AppSequenceType() { }
	friend wsdd__AppSequenceType *soap_instantiate_wsdd__AppSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:67 */
#ifndef SOAP_TYPE___wsdd__Hello
#define SOAP_TYPE___wsdd__Hello (172)
/* Operation wrapper: */
struct __wsdd__Hello
{
public:
	struct wsdd__HelloType *wsdd__Hello;	/* optional element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 172; } /* = unique type id SOAP_TYPE___wsdd__Hello */
	         __wsdd__Hello();
	virtual ~__wsdd__Hello() { }
	friend __wsdd__Hello *soap_instantiate___wsdd__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:76 */
#ifndef SOAP_TYPE___wsdd__Bye
#define SOAP_TYPE___wsdd__Bye (175)
/* Operation wrapper: */
struct __wsdd__Bye
{
public:
	struct wsdd__ByeType *wsdd__Bye;	/* optional element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE___wsdd__Bye */
	         __wsdd__Bye();
	virtual ~__wsdd__Bye() { }
	friend __wsdd__Bye *soap_instantiate___wsdd__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:85 */
#ifndef SOAP_TYPE___wsdd__Probe
#define SOAP_TYPE___wsdd__Probe (178)
/* Operation wrapper: */
struct __wsdd__Probe
{
public:
	struct wsdd__ProbeType *wsdd__Probe;	/* optional element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 178; } /* = unique type id SOAP_TYPE___wsdd__Probe */
	         __wsdd__Probe();
	virtual ~__wsdd__Probe() { }
	friend __wsdd__Probe *soap_instantiate___wsdd__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:94 */
#ifndef SOAP_TYPE___wsdd__ProbeMatches
#define SOAP_TYPE___wsdd__ProbeMatches (181)
/* Operation wrapper: */
struct __wsdd__ProbeMatches
{
public:
	struct wsdd__ProbeMatchesType *wsdd__ProbeMatches;	/* optional element of XSD type wsdd:ProbeMatchesType */
public:
	int soap_type() const { return 181; } /* = unique type id SOAP_TYPE___wsdd__ProbeMatches */
	         __wsdd__ProbeMatches();
	virtual ~__wsdd__ProbeMatches() { }
	friend __wsdd__ProbeMatches *soap_instantiate___wsdd__ProbeMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:103 */
#ifndef SOAP_TYPE___wsdd__Resolve
#define SOAP_TYPE___wsdd__Resolve (184)
/* Operation wrapper: */
struct __wsdd__Resolve
{
public:
	struct wsdd__ResolveType *wsdd__Resolve;	/* optional element of XSD type wsdd:ResolveType */
public:
	int soap_type() const { return 184; } /* = unique type id SOAP_TYPE___wsdd__Resolve */
	         __wsdd__Resolve();
	virtual ~__wsdd__Resolve() { }
	friend __wsdd__Resolve *soap_instantiate___wsdd__Resolve(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:112 */
#ifndef SOAP_TYPE___wsdd__ResolveMatches
#define SOAP_TYPE___wsdd__ResolveMatches (187)
/* Operation wrapper: */
struct __wsdd__ResolveMatches
{
public:
	struct wsdd__ResolveMatchesType *wsdd__ResolveMatches;	/* optional element of XSD type wsdd:ResolveMatchesType */
public:
	int soap_type() const { return 187; } /* = unique type id SOAP_TYPE___wsdd__ResolveMatches */
	         __wsdd__ResolveMatches();
	virtual ~__wsdd__ResolveMatches() { }
	friend __wsdd__ResolveMatches *soap_instantiate___wsdd__ResolveMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xop.h:58 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (188)
/* base64Binary schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 188; } /* = unique type id SOAP_TYPE__xop__Include */
	         _xop__Include();
	virtual ~_xop__Include() { }
	friend _xop__Include *soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:246 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (191)
/* Type xsd__anyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anyType simple type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyType (191)
	virtual int soap_type(void) const { return 191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
	virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
	friend xsd__anyType *soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:249 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (193)
/* SOAP-ENV:Envelope complex type: */
struct SOAP_ENV__Envelope
{
public:
	struct SOAP_ENV__Header *SOAP_ENV__Header;	/* optional element of XSD type SOAP-ENV:Header */
	char *SOAP_ENV__Body;	/* optional element of XSD type xsd:anyType */
public:
	int soap_type() const { return 193; } /* = unique type id SOAP_TYPE_SOAP_ENV__Envelope */
	         SOAP_ENV__Envelope();
	virtual ~SOAP_ENV__Envelope() { }
	friend SOAP_ENV__Envelope *soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:255 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (197)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (197)
	virtual int soap_type(void) const { return 197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend xsd__base64Binary *soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:266 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (202)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary (202)
	virtual int soap_type(void) const { return 202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
	virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
	friend xsd__hexBinary *soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:274 */
#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (204)
/* Type xsd__NCName_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:NCName simple type: */
class SOAP_CMAC xsd__NCName_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__NCName_ (204)
	virtual int soap_type(void) const { return 204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__NCName_, default initialized and not managed by a soap context
	virtual xsd__NCName_ *soap_alloc(void) const { return SOAP_NEW(xsd__NCName_); }
	         xsd__NCName_() { xsd__NCName_::soap_default(NULL); }
	virtual ~xsd__NCName_() { }
	friend xsd__NCName_ *soap_instantiate_xsd__NCName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:281 */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (205)
/* Type xsd__QName_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:QName simple type: */
class SOAP_CMAC xsd__QName_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__QName_ (205)
	virtual int soap_type(void) const { return 205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
	virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW(xsd__QName_); }
	         xsd__QName_() { xsd__QName_::soap_default(NULL); }
	virtual ~xsd__QName_() { }
	friend xsd__QName_ *soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:291 */
#ifndef SOAP_TYPE_xsd__anySimpleType_
#define SOAP_TYPE_xsd__anySimpleType_ (207)
/* Type xsd__anySimpleType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anySimpleType simple type: */
class SOAP_CMAC xsd__anySimpleType_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anySimpleType_ (207)
	virtual int soap_type(void) const { return 207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anySimpleType_, default initialized and not managed by a soap context
	virtual xsd__anySimpleType_ *soap_alloc(void) const { return SOAP_NEW(xsd__anySimpleType_); }
	         xsd__anySimpleType_() { xsd__anySimpleType_::soap_default(NULL); }
	virtual ~xsd__anySimpleType_() { }
	friend xsd__anySimpleType_ *soap_instantiate_xsd__anySimpleType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:301 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (209)
/* Type xsd__anyURI_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anyURI simple type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyURI_ (209)
	virtual int soap_type(void) const { return 209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
	virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
	         xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
	virtual ~xsd__anyURI_() { }
	friend xsd__anyURI_ *soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:308 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (210)
/* Type xsd__base64Binary_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:base64Binary simple type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary_ (210)
	virtual int soap_type(void) const { return 210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
	virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
	friend xsd__base64Binary_ *soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:315 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (211)
/* Type xsd__boolean is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:boolean simple type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__boolean (211)
	virtual int soap_type(void) const { return 211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
	virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
	friend xsd__boolean *soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:322 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (213)
/* Type xsd__dateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:dateTime simple type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__dateTime (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
	virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
	friend xsd__dateTime *soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:329 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (215)
/* Type xsd__duration_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:duration simple type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
	LONG64 __item;	/* external (custom serializer) */	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__duration_ (215)
	virtual int soap_type(void) const { return 215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
	virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
	         xsd__duration_() { xsd__duration_::soap_default(NULL); }
	virtual ~xsd__duration_() { }
	friend xsd__duration_ *soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:336 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (216)
/* Type xsd__float is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:float simple type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__float (216)
	virtual int soap_type(void) const { return 216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__float, default initialized and not managed by a soap context
	virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
	friend xsd__float *soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:343 */
#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (218)
/* Type xsd__hexBinary_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:hexBinary simple type: */
class SOAP_CMAC xsd__hexBinary_ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary_ (218)
	virtual int soap_type(void) const { return 218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary_, default initialized and not managed by a soap context
	virtual xsd__hexBinary_ *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary_); }
	         xsd__hexBinary_() { xsd__hexBinary_::soap_default(NULL); }
	virtual ~xsd__hexBinary_() { }
	friend xsd__hexBinary_ *soap_instantiate_xsd__hexBinary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:350 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (219)
/* Type xsd__int is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:int simple type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__int (219)
	virtual int soap_type(void) const { return 219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__int, default initialized and not managed by a soap context
	virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
	friend xsd__int *soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:360 */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (221)
/* Type xsd__integer_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:integer simple type: */
class SOAP_CMAC xsd__integer_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__integer_ (221)
	virtual int soap_type(void) const { return 221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__integer_, default initialized and not managed by a soap context
	virtual xsd__integer_ *soap_alloc(void) const { return SOAP_NEW(xsd__integer_); }
	         xsd__integer_() { xsd__integer_::soap_default(NULL); }
	virtual ~xsd__integer_() { }
	friend xsd__integer_ *soap_instantiate_xsd__integer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:370 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (223)
/* Type xsd__nonNegativeInteger_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:nonNegativeInteger simple type: */
class SOAP_CMAC xsd__nonNegativeInteger_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__nonNegativeInteger_ (223)
	virtual int soap_type(void) const { return 223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__nonNegativeInteger_, default initialized and not managed by a soap context
	virtual xsd__nonNegativeInteger_ *soap_alloc(void) const { return SOAP_NEW(xsd__nonNegativeInteger_); }
	         xsd__nonNegativeInteger_() { xsd__nonNegativeInteger_::soap_default(NULL); }
	virtual ~xsd__nonNegativeInteger_() { }
	friend xsd__nonNegativeInteger_ *soap_instantiate_xsd__nonNegativeInteger_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:377 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (224)
/* Type xsd__string is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:string simple type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__string (224)
	virtual int soap_type(void) const { return 224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__string, default initialized and not managed by a soap context
	virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
	friend xsd__string *soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:387 */
#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (226)
/* Type xsd__token_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:token simple type: */
class SOAP_CMAC xsd__token_ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__token_ (226)
	virtual int soap_type(void) const { return 226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__token_, default initialized and not managed by a soap context
	virtual xsd__token_ *soap_alloc(void) const { return SOAP_NEW(xsd__token_); }
	         xsd__token_() { xsd__token_::soap_default(NULL); }
	virtual ~xsd__token_() { }
	friend xsd__token_ *soap_instantiate_xsd__token_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4095 */
#ifndef SOAP_TYPE_tds__StorageType_
#define SOAP_TYPE_tds__StorageType_ (1398)
/* Type tds__StorageType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:StorageType simple type: */
class SOAP_CMAC tds__StorageType_ : public xsd__anyType
{
public:
	enum tds__StorageType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageType_ (1398)
	virtual int soap_type(void) const { return 1398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageType_, default initialized and not managed by a soap context
	virtual tds__StorageType_ *soap_alloc(void) const { return SOAP_NEW(tds__StorageType_); }
	         tds__StorageType_() { tds__StorageType_::soap_default(NULL); }
	virtual ~tds__StorageType_() { }
	friend tds__StorageType_ *soap_instantiate_tds__StorageType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4120 */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (1400)
/* Type tt__ReferenceToken__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReferenceToken simple type: */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReferenceToken__ (1400)
	virtual int soap_type(void) const { return 1400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReferenceToken__, default initialized and not managed by a soap context
	virtual tt__ReferenceToken__ *soap_alloc(void) const { return SOAP_NEW(tt__ReferenceToken__); }
	         tt__ReferenceToken__() { tt__ReferenceToken__::soap_default(NULL); }
	virtual ~tt__ReferenceToken__() { }
	friend tt__ReferenceToken__ *soap_instantiate_tt__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4135 */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (1402)
/* Type tt__Name__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Name simple type: */
class SOAP_CMAC tt__Name__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Name__ (1402)
	virtual int soap_type(void) const { return 1402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Name__, default initialized and not managed by a soap context
	virtual tt__Name__ *soap_alloc(void) const { return SOAP_NEW(tt__Name__); }
	         tt__Name__() { tt__Name__::soap_default(NULL); }
	virtual ~tt__Name__() { }
	friend tt__Name__ *soap_instantiate_tt__Name__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4152 */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (1404)
/* Type tt__RotateMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateMode simple type: */
class SOAP_CMAC tt__RotateMode_ : public xsd__anyType
{
public:
	enum tt__RotateMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateMode_ (1404)
	virtual int soap_type(void) const { return 1404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateMode_, default initialized and not managed by a soap context
	virtual tt__RotateMode_ *soap_alloc(void) const { return SOAP_NEW(tt__RotateMode_); }
	         tt__RotateMode_() { tt__RotateMode_::soap_default(NULL); }
	virtual ~tt__RotateMode_() { }
	friend tt__RotateMode_ *soap_instantiate_tt__RotateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4169 */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (1406)
/* Type tt__VideoEncoding_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoding simple type: */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType
{
public:
	enum tt__VideoEncoding __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoding_ (1406)
	virtual int soap_type(void) const { return 1406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoding_, default initialized and not managed by a soap context
	virtual tt__VideoEncoding_ *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoding_); }
	         tt__VideoEncoding_() { tt__VideoEncoding_::soap_default(NULL); }
	virtual ~tt__VideoEncoding_() { }
	friend tt__VideoEncoding_ *soap_instantiate_tt__VideoEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4185 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (1408)
/* Type tt__Mpeg4Profile_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Profile simple type: */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType
{
public:
	enum tt__Mpeg4Profile __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Profile_ (1408)
	virtual int soap_type(void) const { return 1408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Profile_, default initialized and not managed by a soap context
	virtual tt__Mpeg4Profile_ *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Profile_); }
	         tt__Mpeg4Profile_() { tt__Mpeg4Profile_::soap_default(NULL); }
	virtual ~tt__Mpeg4Profile_() { }
	friend tt__Mpeg4Profile_ *soap_instantiate_tt__Mpeg4Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4203 */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (1410)
/* Type tt__H264Profile_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Profile simple type: */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType
{
public:
	enum tt__H264Profile __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Profile_ (1410)
	virtual int soap_type(void) const { return 1410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Profile_, default initialized and not managed by a soap context
	virtual tt__H264Profile_ *soap_alloc(void) const { return SOAP_NEW(tt__H264Profile_); }
	         tt__H264Profile_() { tt__H264Profile_::soap_default(NULL); }
	virtual ~tt__H264Profile_() { }
	friend tt__H264Profile_ *soap_instantiate_tt__H264Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4224 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames_
#define SOAP_TYPE_tt__VideoEncodingMimeNames_ (1412)
/* Type tt__VideoEncodingMimeNames_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncodingMimeNames simple type: */
class SOAP_CMAC tt__VideoEncodingMimeNames_ : public xsd__anyType
{
public:
	enum tt__VideoEncodingMimeNames __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncodingMimeNames_ (1412)
	virtual int soap_type(void) const { return 1412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncodingMimeNames_, default initialized and not managed by a soap context
	virtual tt__VideoEncodingMimeNames_ *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncodingMimeNames_); }
	         tt__VideoEncodingMimeNames_() { tt__VideoEncodingMimeNames_::soap_default(NULL); }
	virtual ~tt__VideoEncodingMimeNames_() { }
	friend tt__VideoEncodingMimeNames_ *soap_instantiate_tt__VideoEncodingMimeNames_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4245 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles_
#define SOAP_TYPE_tt__VideoEncodingProfiles_ (1414)
/* Type tt__VideoEncodingProfiles_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncodingProfiles simple type: */
class SOAP_CMAC tt__VideoEncodingProfiles_ : public xsd__anyType
{
public:
	enum tt__VideoEncodingProfiles __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncodingProfiles_ (1414)
	virtual int soap_type(void) const { return 1414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncodingProfiles_, default initialized and not managed by a soap context
	virtual tt__VideoEncodingProfiles_ *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncodingProfiles_); }
	         tt__VideoEncodingProfiles_() { tt__VideoEncodingProfiles_::soap_default(NULL); }
	virtual ~tt__VideoEncodingProfiles_() { }
	friend tt__VideoEncodingProfiles_ *soap_instantiate_tt__VideoEncodingProfiles_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4262 */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (1416)
/* Type tt__AudioEncoding_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoding simple type: */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType
{
public:
	enum tt__AudioEncoding __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoding_ (1416)
	virtual int soap_type(void) const { return 1416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoding_, default initialized and not managed by a soap context
	virtual tt__AudioEncoding_ *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoding_); }
	         tt__AudioEncoding_() { tt__AudioEncoding_::soap_default(NULL); }
	virtual ~tt__AudioEncoding_() { }
	friend tt__AudioEncoding_ *soap_instantiate_tt__AudioEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4282 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames_
#define SOAP_TYPE_tt__AudioEncodingMimeNames_ (1418)
/* Type tt__AudioEncodingMimeNames_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncodingMimeNames simple type: */
class SOAP_CMAC tt__AudioEncodingMimeNames_ : public xsd__anyType
{
public:
	enum tt__AudioEncodingMimeNames __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncodingMimeNames_ (1418)
	virtual int soap_type(void) const { return 1418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncodingMimeNames_, default initialized and not managed by a soap context
	virtual tt__AudioEncodingMimeNames_ *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncodingMimeNames_); }
	         tt__AudioEncodingMimeNames_() { tt__AudioEncodingMimeNames_::soap_default(NULL); }
	virtual ~tt__AudioEncodingMimeNames_() { }
	friend tt__AudioEncodingMimeNames_ *soap_instantiate_tt__AudioEncodingMimeNames_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4299 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType_
#define SOAP_TYPE_tt__MetadataCompressionType_ (1420)
/* Type tt__MetadataCompressionType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataCompressionType simple type: */
class SOAP_CMAC tt__MetadataCompressionType_ : public xsd__anyType
{
public:
	enum tt__MetadataCompressionType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataCompressionType_ (1420)
	virtual int soap_type(void) const { return 1420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataCompressionType_, default initialized and not managed by a soap context
	virtual tt__MetadataCompressionType_ *soap_alloc(void) const { return SOAP_NEW(tt__MetadataCompressionType_); }
	         tt__MetadataCompressionType_() { tt__MetadataCompressionType_::soap_default(NULL); }
	virtual ~tt__MetadataCompressionType_() { }
	friend tt__MetadataCompressionType_ *soap_instantiate_tt__MetadataCompressionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4315 */
#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (1422)
/* Type tt__StreamType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StreamType simple type: */
class SOAP_CMAC tt__StreamType_ : public xsd__anyType
{
public:
	enum tt__StreamType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamType_ (1422)
	virtual int soap_type(void) const { return 1422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamType_, default initialized and not managed by a soap context
	virtual tt__StreamType_ *soap_alloc(void) const { return SOAP_NEW(tt__StreamType_); }
	         tt__StreamType_() { tt__StreamType_::soap_default(NULL); }
	virtual ~tt__StreamType_() { }
	friend tt__StreamType_ *soap_instantiate_tt__StreamType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4333 */
#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (1424)
/* Type tt__TransportProtocol_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TransportProtocol simple type: */
class SOAP_CMAC tt__TransportProtocol_ : public xsd__anyType
{
public:
	enum tt__TransportProtocol __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransportProtocol_ (1424)
	virtual int soap_type(void) const { return 1424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransportProtocol_, default initialized and not managed by a soap context
	virtual tt__TransportProtocol_ *soap_alloc(void) const { return SOAP_NEW(tt__TransportProtocol_); }
	         tt__TransportProtocol_() { tt__TransportProtocol_::soap_default(NULL); }
	virtual ~tt__TransportProtocol_() { }
	friend tt__TransportProtocol_ *soap_instantiate_tt__TransportProtocol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4349 */
#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (1426)
/* Type tt__ScopeDefinition_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ScopeDefinition simple type: */
class SOAP_CMAC tt__ScopeDefinition_ : public xsd__anyType
{
public:
	enum tt__ScopeDefinition __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ScopeDefinition_ (1426)
	virtual int soap_type(void) const { return 1426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ScopeDefinition_, default initialized and not managed by a soap context
	virtual tt__ScopeDefinition_ *soap_alloc(void) const { return SOAP_NEW(tt__ScopeDefinition_); }
	         tt__ScopeDefinition_() { tt__ScopeDefinition_::soap_default(NULL); }
	virtual ~tt__ScopeDefinition_() { }
	friend tt__ScopeDefinition_ *soap_instantiate_tt__ScopeDefinition_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4365 */
#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (1428)
/* Type tt__DiscoveryMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DiscoveryMode simple type: */
class SOAP_CMAC tt__DiscoveryMode_ : public xsd__anyType
{
public:
	enum tt__DiscoveryMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DiscoveryMode_ (1428)
	virtual int soap_type(void) const { return 1428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DiscoveryMode_, default initialized and not managed by a soap context
	virtual tt__DiscoveryMode_ *soap_alloc(void) const { return SOAP_NEW(tt__DiscoveryMode_); }
	         tt__DiscoveryMode_() { tt__DiscoveryMode_::soap_default(NULL); }
	virtual ~tt__DiscoveryMode_() { }
	friend tt__DiscoveryMode_ *soap_instantiate_tt__DiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4377 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (1430)
/* Type tt__NetworkInterfaceConfigPriority__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceConfigPriority simple type: */
class SOAP_CMAC tt__NetworkInterfaceConfigPriority__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (1430)
	virtual int soap_type(void) const { return 1430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConfigPriority__, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConfigPriority__ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConfigPriority__); }
	         tt__NetworkInterfaceConfigPriority__() { tt__NetworkInterfaceConfigPriority__::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConfigPriority__() { }
	friend tt__NetworkInterfaceConfigPriority__ *soap_instantiate_tt__NetworkInterfaceConfigPriority__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4393 */
#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (1432)
/* Type tt__Duplex_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Duplex simple type: */
class SOAP_CMAC tt__Duplex_ : public xsd__anyType
{
public:
	enum tt__Duplex __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Duplex_ (1432)
	virtual int soap_type(void) const { return 1432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Duplex_, default initialized and not managed by a soap context
	virtual tt__Duplex_ *soap_alloc(void) const { return SOAP_NEW(tt__Duplex_); }
	         tt__Duplex_() { tt__Duplex_::soap_default(NULL); }
	virtual ~tt__Duplex_() { }
	friend tt__Duplex_ *soap_instantiate_tt__Duplex_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4407 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (1434)
/* Type tt__IANA_IfTypes__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IANA-IfTypes simple type: */
class SOAP_CMAC tt__IANA_IfTypes__ : public xsd__anyType
{
public:
	int __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IANA_IfTypes__ (1434)
	virtual int soap_type(void) const { return 1434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IANA_IfTypes__, default initialized and not managed by a soap context
	virtual tt__IANA_IfTypes__ *soap_alloc(void) const { return SOAP_NEW(tt__IANA_IfTypes__); }
	         tt__IANA_IfTypes__() { tt__IANA_IfTypes__::soap_default(NULL); }
	virtual ~tt__IANA_IfTypes__() { }
	friend tt__IANA_IfTypes__ *soap_instantiate_tt__IANA_IfTypes__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4425 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (1436)
/* Type tt__IPv6DHCPConfiguration_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6DHCPConfiguration simple type: */
class SOAP_CMAC tt__IPv6DHCPConfiguration_ : public xsd__anyType
{
public:
	enum tt__IPv6DHCPConfiguration __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6DHCPConfiguration_ (1436)
	virtual int soap_type(void) const { return 1436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6DHCPConfiguration_, default initialized and not managed by a soap context
	virtual tt__IPv6DHCPConfiguration_ *soap_alloc(void) const { return SOAP_NEW(tt__IPv6DHCPConfiguration_); }
	         tt__IPv6DHCPConfiguration_() { tt__IPv6DHCPConfiguration_::soap_default(NULL); }
	virtual ~tt__IPv6DHCPConfiguration_() { }
	friend tt__IPv6DHCPConfiguration_ *soap_instantiate_tt__IPv6DHCPConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4442 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (1438)
/* Type tt__NetworkProtocolType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocolType simple type: */
class SOAP_CMAC tt__NetworkProtocolType_ : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolType_ (1438)
	virtual int soap_type(void) const { return 1438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolType_, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolType_ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolType_); }
	         tt__NetworkProtocolType_() { tt__NetworkProtocolType_::soap_default(NULL); }
	virtual ~tt__NetworkProtocolType_() { }
	friend tt__NetworkProtocolType_ *soap_instantiate_tt__NetworkProtocolType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4459 */
#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (1440)
/* Type tt__NetworkHostType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHostType simple type: */
class SOAP_CMAC tt__NetworkHostType_ : public xsd__anyType
{
public:
	enum tt__NetworkHostType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostType_ (1440)
	virtual int soap_type(void) const { return 1440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostType_, default initialized and not managed by a soap context
	virtual tt__NetworkHostType_ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostType_); }
	         tt__NetworkHostType_() { tt__NetworkHostType_::soap_default(NULL); }
	virtual ~tt__NetworkHostType_() { }
	friend tt__NetworkHostType_ *soap_instantiate_tt__NetworkHostType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4470 */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (1442)
/* Type tt__IPv4Address__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4Address simple type: */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Address__ (1442)
	virtual int soap_type(void) const { return 1442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Address__, default initialized and not managed by a soap context
	virtual tt__IPv4Address__ *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Address__); }
	         tt__IPv4Address__() { tt__IPv4Address__::soap_default(NULL); }
	virtual ~tt__IPv4Address__() { }
	friend tt__IPv4Address__ *soap_instantiate_tt__IPv4Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4481 */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (1444)
/* Type tt__IPv6Address__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6Address simple type: */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Address__ (1444)
	virtual int soap_type(void) const { return 1444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Address__, default initialized and not managed by a soap context
	virtual tt__IPv6Address__ *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Address__); }
	         tt__IPv6Address__() { tt__IPv6Address__::soap_default(NULL); }
	virtual ~tt__IPv6Address__() { }
	friend tt__IPv6Address__ *soap_instantiate_tt__IPv6Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4492 */
#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (1446)
/* Type tt__HwAddress__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HwAddress simple type: */
class SOAP_CMAC tt__HwAddress__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HwAddress__ (1446)
	virtual int soap_type(void) const { return 1446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HwAddress__, default initialized and not managed by a soap context
	virtual tt__HwAddress__ *soap_alloc(void) const { return SOAP_NEW(tt__HwAddress__); }
	         tt__HwAddress__() { tt__HwAddress__::soap_default(NULL); }
	virtual ~tt__HwAddress__() { }
	friend tt__HwAddress__ *soap_instantiate_tt__HwAddress__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4508 */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (1448)
/* Type tt__IPType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPType simple type: */
class SOAP_CMAC tt__IPType_ : public xsd__anyType
{
public:
	enum tt__IPType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPType_ (1448)
	virtual int soap_type(void) const { return 1448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPType_, default initialized and not managed by a soap context
	virtual tt__IPType_ *soap_alloc(void) const { return SOAP_NEW(tt__IPType_); }
	         tt__IPType_() { tt__IPType_::soap_default(NULL); }
	virtual ~tt__IPType_() { }
	friend tt__IPType_ *soap_instantiate_tt__IPType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4519 */
#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (1450)
/* Type tt__DNSName__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSName simple type: */
class SOAP_CMAC tt__DNSName__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSName__ (1450)
	virtual int soap_type(void) const { return 1450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSName__, default initialized and not managed by a soap context
	virtual tt__DNSName__ *soap_alloc(void) const { return SOAP_NEW(tt__DNSName__); }
	         tt__DNSName__() { tt__DNSName__::soap_default(NULL); }
	virtual ~tt__DNSName__() { }
	friend tt__DNSName__ *soap_instantiate_tt__DNSName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4530 */
#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (1452)
/* Type tt__Domain__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Domain simple type: */
class SOAP_CMAC tt__Domain__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Domain__ (1452)
	virtual int soap_type(void) const { return 1452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Domain__, default initialized and not managed by a soap context
	virtual tt__Domain__ *soap_alloc(void) const { return SOAP_NEW(tt__Domain__); }
	         tt__Domain__() { tt__Domain__::soap_default(NULL); }
	virtual ~tt__Domain__() { }
	friend tt__Domain__ *soap_instantiate_tt__Domain__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4546 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (1454)
/* Type tt__IPAddressFilterType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilterType simple type: */
class SOAP_CMAC tt__IPAddressFilterType_ : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterType_ (1454)
	virtual int soap_type(void) const { return 1454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterType_, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterType_ *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterType_); }
	         tt__IPAddressFilterType_() { tt__IPAddressFilterType_::soap_default(NULL); }
	virtual ~tt__IPAddressFilterType_() { }
	friend tt__IPAddressFilterType_ *soap_instantiate_tt__IPAddressFilterType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4563 */
#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (1456)
/* Type tt__DynamicDNSType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSType simple type: */
class SOAP_CMAC tt__DynamicDNSType_ : public xsd__anyType
{
public:
	enum tt__DynamicDNSType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSType_ (1456)
	virtual int soap_type(void) const { return 1456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSType_, default initialized and not managed by a soap context
	virtual tt__DynamicDNSType_ *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSType_); }
	         tt__DynamicDNSType_() { tt__DynamicDNSType_::soap_default(NULL); }
	virtual ~tt__DynamicDNSType_() { }
	friend tt__DynamicDNSType_ *soap_instantiate_tt__DynamicDNSType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4575 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType__
#define SOAP_TYPE_tt__Dot11SSIDType__ (1458)
/* Type tt__Dot11SSIDType__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SSIDType simple type: */
class SOAP_CMAC tt__Dot11SSIDType__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SSIDType__ (1458)
	virtual int soap_type(void) const { return 1458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SSIDType__, default initialized and not managed by a soap context
	virtual tt__Dot11SSIDType__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SSIDType__); }
	         tt__Dot11SSIDType__() { tt__Dot11SSIDType__::soap_default(NULL); }
	virtual ~tt__Dot11SSIDType__() { }
	friend tt__Dot11SSIDType__ *soap_instantiate_tt__Dot11SSIDType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4592 */
#ifndef SOAP_TYPE_tt__Dot11StationMode_
#define SOAP_TYPE_tt__Dot11StationMode_ (1460)
/* Type tt__Dot11StationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11StationMode simple type: */
class SOAP_CMAC tt__Dot11StationMode_ : public xsd__anyType
{
public:
	enum tt__Dot11StationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11StationMode_ (1460)
	virtual int soap_type(void) const { return 1460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11StationMode_, default initialized and not managed by a soap context
	virtual tt__Dot11StationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11StationMode_); }
	         tt__Dot11StationMode_() { tt__Dot11StationMode_::soap_default(NULL); }
	virtual ~tt__Dot11StationMode_() { }
	friend tt__Dot11StationMode_ *soap_instantiate_tt__Dot11StationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4611 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode_
#define SOAP_TYPE_tt__Dot11SecurityMode_ (1462)
/* Type tt__Dot11SecurityMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityMode simple type: */
class SOAP_CMAC tt__Dot11SecurityMode_ : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityMode_ (1462)
	virtual int soap_type(void) const { return 1462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityMode_, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityMode_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityMode_); }
	         tt__Dot11SecurityMode_() { tt__Dot11SecurityMode_::soap_default(NULL); }
	virtual ~tt__Dot11SecurityMode_() { }
	friend tt__Dot11SecurityMode_ *soap_instantiate_tt__Dot11SecurityMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4629 */
#ifndef SOAP_TYPE_tt__Dot11Cipher_
#define SOAP_TYPE_tt__Dot11Cipher_ (1464)
/* Type tt__Dot11Cipher_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Cipher simple type: */
class SOAP_CMAC tt__Dot11Cipher_ : public xsd__anyType
{
public:
	enum tt__Dot11Cipher __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Cipher_ (1464)
	virtual int soap_type(void) const { return 1464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Cipher_, default initialized and not managed by a soap context
	virtual tt__Dot11Cipher_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Cipher_); }
	         tt__Dot11Cipher_() { tt__Dot11Cipher_::soap_default(NULL); }
	virtual ~tt__Dot11Cipher_() { }
	friend tt__Dot11Cipher_ *soap_instantiate_tt__Dot11Cipher_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4641 */
#ifndef SOAP_TYPE_tt__Dot11PSK__
#define SOAP_TYPE_tt__Dot11PSK__ (1466)
/* Type tt__Dot11PSK__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSK simple type: */
class SOAP_CMAC tt__Dot11PSK__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSK__ (1466)
	virtual int soap_type(void) const { return 1466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSK__, default initialized and not managed by a soap context
	virtual tt__Dot11PSK__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSK__); }
	         tt__Dot11PSK__() { tt__Dot11PSK__::soap_default(NULL); }
	virtual ~tt__Dot11PSK__() { }
	friend tt__Dot11PSK__ *soap_instantiate_tt__Dot11PSK__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4653 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase__
#define SOAP_TYPE_tt__Dot11PSKPassphrase__ (1468)
/* Type tt__Dot11PSKPassphrase__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKPassphrase simple type: */
class SOAP_CMAC tt__Dot11PSKPassphrase__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKPassphrase__ (1468)
	virtual int soap_type(void) const { return 1468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKPassphrase__, default initialized and not managed by a soap context
	virtual tt__Dot11PSKPassphrase__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKPassphrase__); }
	         tt__Dot11PSKPassphrase__() { tt__Dot11PSKPassphrase__::soap_default(NULL); }
	virtual ~tt__Dot11PSKPassphrase__() { }
	friend tt__Dot11PSKPassphrase__ *soap_instantiate_tt__Dot11PSKPassphrase__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4673 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength_
#define SOAP_TYPE_tt__Dot11SignalStrength_ (1470)
/* Type tt__Dot11SignalStrength_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SignalStrength simple type: */
class SOAP_CMAC tt__Dot11SignalStrength_ : public xsd__anyType
{
public:
	enum tt__Dot11SignalStrength __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SignalStrength_ (1470)
	virtual int soap_type(void) const { return 1470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SignalStrength_, default initialized and not managed by a soap context
	virtual tt__Dot11SignalStrength_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SignalStrength_); }
	         tt__Dot11SignalStrength_() { tt__Dot11SignalStrength_::soap_default(NULL); }
	virtual ~tt__Dot11SignalStrength_() { }
	friend tt__Dot11SignalStrength_ *soap_instantiate_tt__Dot11SignalStrength_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4691 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (1472)
/* Type tt__Dot11AuthAndMangementSuite_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AuthAndMangementSuite simple type: */
class SOAP_CMAC tt__Dot11AuthAndMangementSuite_ : public xsd__anyType
{
public:
	enum tt__Dot11AuthAndMangementSuite __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (1472)
	virtual int soap_type(void) const { return 1472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AuthAndMangementSuite_, default initialized and not managed by a soap context
	virtual tt__Dot11AuthAndMangementSuite_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AuthAndMangementSuite_); }
	         tt__Dot11AuthAndMangementSuite_() { tt__Dot11AuthAndMangementSuite_::soap_default(NULL); }
	virtual ~tt__Dot11AuthAndMangementSuite_() { }
	friend tt__Dot11AuthAndMangementSuite_ *soap_instantiate_tt__Dot11AuthAndMangementSuite_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4712 */
#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (1474)
/* Type tt__CapabilityCategory_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilityCategory simple type: */
class SOAP_CMAC tt__CapabilityCategory_ : public xsd__anyType
{
public:
	enum tt__CapabilityCategory __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilityCategory_ (1474)
	virtual int soap_type(void) const { return 1474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilityCategory_, default initialized and not managed by a soap context
	virtual tt__CapabilityCategory_ *soap_alloc(void) const { return SOAP_NEW(tt__CapabilityCategory_); }
	         tt__CapabilityCategory_() { tt__CapabilityCategory_::soap_default(NULL); }
	virtual ~tt__CapabilityCategory_() { }
	friend tt__CapabilityCategory_ *soap_instantiate_tt__CapabilityCategory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4737 */
#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (1476)
/* Type tt__SystemLogType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogType simple type: */
class SOAP_CMAC tt__SystemLogType_ : public xsd__anyType
{
public:
	enum tt__SystemLogType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogType_ (1476)
	virtual int soap_type(void) const { return 1476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogType_, default initialized and not managed by a soap context
	virtual tt__SystemLogType_ *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogType_); }
	         tt__SystemLogType_() { tt__SystemLogType_::soap_default(NULL); }
	virtual ~tt__SystemLogType_() { }
	friend tt__SystemLogType_ *soap_instantiate_tt__SystemLogType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4762 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (1478)
/* Type tt__FactoryDefaultType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FactoryDefaultType simple type: */
class SOAP_CMAC tt__FactoryDefaultType_ : public xsd__anyType
{
public:
	enum tt__FactoryDefaultType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FactoryDefaultType_ (1478)
	virtual int soap_type(void) const { return 1478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FactoryDefaultType_, default initialized and not managed by a soap context
	virtual tt__FactoryDefaultType_ *soap_alloc(void) const { return SOAP_NEW(tt__FactoryDefaultType_); }
	         tt__FactoryDefaultType_() { tt__FactoryDefaultType_::soap_default(NULL); }
	virtual ~tt__FactoryDefaultType_() { }
	friend tt__FactoryDefaultType_ *soap_instantiate_tt__FactoryDefaultType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4784 */
#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (1480)
/* Type tt__SetDateTimeType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SetDateTimeType simple type: */
class SOAP_CMAC tt__SetDateTimeType_ : public xsd__anyType
{
public:
	enum tt__SetDateTimeType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SetDateTimeType_ (1480)
	virtual int soap_type(void) const { return 1480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SetDateTimeType_, default initialized and not managed by a soap context
	virtual tt__SetDateTimeType_ *soap_alloc(void) const { return SOAP_NEW(tt__SetDateTimeType_); }
	         tt__SetDateTimeType_() { tt__SetDateTimeType_::soap_default(NULL); }
	virtual ~tt__SetDateTimeType_() { }
	friend tt__SetDateTimeType_ *soap_instantiate_tt__SetDateTimeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4803 */
#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (1482)
/* Type tt__UserLevel_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:UserLevel simple type: */
class SOAP_CMAC tt__UserLevel_ : public xsd__anyType
{
public:
	enum tt__UserLevel __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserLevel_ (1482)
	virtual int soap_type(void) const { return 1482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserLevel_, default initialized and not managed by a soap context
	virtual tt__UserLevel_ *soap_alloc(void) const { return SOAP_NEW(tt__UserLevel_); }
	         tt__UserLevel_() { tt__UserLevel_::soap_default(NULL); }
	virtual ~tt__UserLevel_() { }
	friend tt__UserLevel_ *soap_instantiate_tt__UserLevel_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4819 */
#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (1484)
/* Type tt__RelayLogicalState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayLogicalState simple type: */
class SOAP_CMAC tt__RelayLogicalState_ : public xsd__anyType
{
public:
	enum tt__RelayLogicalState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayLogicalState_ (1484)
	virtual int soap_type(void) const { return 1484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayLogicalState_, default initialized and not managed by a soap context
	virtual tt__RelayLogicalState_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayLogicalState_); }
	         tt__RelayLogicalState_() { tt__RelayLogicalState_::soap_default(NULL); }
	virtual ~tt__RelayLogicalState_() { }
	friend tt__RelayLogicalState_ *soap_instantiate_tt__RelayLogicalState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4835 */
#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (1486)
/* Type tt__RelayIdleState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayIdleState simple type: */
class SOAP_CMAC tt__RelayIdleState_ : public xsd__anyType
{
public:
	enum tt__RelayIdleState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayIdleState_ (1486)
	virtual int soap_type(void) const { return 1486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayIdleState_, default initialized and not managed by a soap context
	virtual tt__RelayIdleState_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayIdleState_); }
	         tt__RelayIdleState_() { tt__RelayIdleState_::soap_default(NULL); }
	virtual ~tt__RelayIdleState_() { }
	friend tt__RelayIdleState_ *soap_instantiate_tt__RelayIdleState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4851 */
#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (1488)
/* Type tt__RelayMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayMode simple type: */
class SOAP_CMAC tt__RelayMode_ : public xsd__anyType
{
public:
	enum tt__RelayMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayMode_ (1488)
	virtual int soap_type(void) const { return 1488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayMode_, default initialized and not managed by a soap context
	virtual tt__RelayMode_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayMode_); }
	         tt__RelayMode_() { tt__RelayMode_::soap_default(NULL); }
	virtual ~tt__RelayMode_() { }
	friend tt__RelayMode_ *soap_instantiate_tt__RelayMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4867 */
#ifndef SOAP_TYPE_tt__DigitalIdleState_
#define SOAP_TYPE_tt__DigitalIdleState_ (1490)
/* Type tt__DigitalIdleState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DigitalIdleState simple type: */
class SOAP_CMAC tt__DigitalIdleState_ : public xsd__anyType
{
public:
	enum tt__DigitalIdleState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DigitalIdleState_ (1490)
	virtual int soap_type(void) const { return 1490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DigitalIdleState_, default initialized and not managed by a soap context
	virtual tt__DigitalIdleState_ *soap_alloc(void) const { return SOAP_NEW(tt__DigitalIdleState_); }
	         tt__DigitalIdleState_() { tt__DigitalIdleState_::soap_default(NULL); }
	virtual ~tt__DigitalIdleState_() { }
	friend tt__DigitalIdleState_ *soap_instantiate_tt__DigitalIdleState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4884 */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (1492)
/* Type tt__EFlipMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipMode simple type: */
class SOAP_CMAC tt__EFlipMode_ : public xsd__anyType
{
public:
	enum tt__EFlipMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipMode_ (1492)
	virtual int soap_type(void) const { return 1492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipMode_, default initialized and not managed by a soap context
	virtual tt__EFlipMode_ *soap_alloc(void) const { return SOAP_NEW(tt__EFlipMode_); }
	         tt__EFlipMode_() { tt__EFlipMode_::soap_default(NULL); }
	virtual ~tt__EFlipMode_() { }
	friend tt__EFlipMode_ *soap_instantiate_tt__EFlipMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4902 */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (1494)
/* Type tt__ReverseMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseMode simple type: */
class SOAP_CMAC tt__ReverseMode_ : public xsd__anyType
{
public:
	enum tt__ReverseMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseMode_ (1494)
	virtual int soap_type(void) const { return 1494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseMode_, default initialized and not managed by a soap context
	virtual tt__ReverseMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ReverseMode_); }
	         tt__ReverseMode_() { tt__ReverseMode_::soap_default(NULL); }
	virtual ~tt__ReverseMode_() { }
	friend tt__ReverseMode_ *soap_instantiate_tt__ReverseMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4914 */
#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (1496)
/* Type tt__AuxiliaryData__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AuxiliaryData simple type: */
class SOAP_CMAC tt__AuxiliaryData__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AuxiliaryData__ (1496)
	virtual int soap_type(void) const { return 1496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AuxiliaryData__, default initialized and not managed by a soap context
	virtual tt__AuxiliaryData__ *soap_alloc(void) const { return SOAP_NEW(tt__AuxiliaryData__); }
	         tt__AuxiliaryData__() { tt__AuxiliaryData__::soap_default(NULL); }
	virtual ~tt__AuxiliaryData__() { }
	friend tt__AuxiliaryData__ *soap_instantiate_tt__AuxiliaryData__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4931 */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (1498)
/* Type tt__MoveStatus_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveStatus simple type: */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType
{
public:
	enum tt__MoveStatus __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveStatus_ (1498)
	virtual int soap_type(void) const { return 1498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveStatus_, default initialized and not managed by a soap context
	virtual tt__MoveStatus_ *soap_alloc(void) const { return SOAP_NEW(tt__MoveStatus_); }
	         tt__MoveStatus_() { tt__MoveStatus_::soap_default(NULL); }
	virtual ~tt__MoveStatus_() { }
	friend tt__MoveStatus_ *soap_instantiate_tt__MoveStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4949 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState_
#define SOAP_TYPE_tt__PTZPresetTourState_ (1500)
/* Type tt__PTZPresetTourState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourState simple type: */
class SOAP_CMAC tt__PTZPresetTourState_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourState_ (1500)
	virtual int soap_type(void) const { return 1500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourState_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourState_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourState_); }
	         tt__PTZPresetTourState_() { tt__PTZPresetTourState_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourState_() { }
	friend tt__PTZPresetTourState_ *soap_instantiate_tt__PTZPresetTourState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4966 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection_
#define SOAP_TYPE_tt__PTZPresetTourDirection_ (1502)
/* Type tt__PTZPresetTourDirection_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourDirection simple type: */
class SOAP_CMAC tt__PTZPresetTourDirection_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourDirection __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourDirection_ (1502)
	virtual int soap_type(void) const { return 1502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourDirection_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourDirection_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourDirection_); }
	         tt__PTZPresetTourDirection_() { tt__PTZPresetTourDirection_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourDirection_() { }
	friend tt__PTZPresetTourDirection_ *soap_instantiate_tt__PTZPresetTourDirection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4984 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation_
#define SOAP_TYPE_tt__PTZPresetTourOperation_ (1504)
/* Type tt__PTZPresetTourOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourOperation simple type: */
class SOAP_CMAC tt__PTZPresetTourOperation_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOperation_ (1504)
	virtual int soap_type(void) const { return 1504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOperation_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOperation_); }
	         tt__PTZPresetTourOperation_() { tt__PTZPresetTourOperation_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOperation_() { }
	friend tt__PTZPresetTourOperation_ *soap_instantiate_tt__PTZPresetTourOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5000 */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (1506)
/* Type tt__AutoFocusMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AutoFocusMode simple type: */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType
{
public:
	enum tt__AutoFocusMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AutoFocusMode_ (1506)
	virtual int soap_type(void) const { return 1506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AutoFocusMode_, default initialized and not managed by a soap context
	virtual tt__AutoFocusMode_ *soap_alloc(void) const { return SOAP_NEW(tt__AutoFocusMode_); }
	         tt__AutoFocusMode_() { tt__AutoFocusMode_::soap_default(NULL); }
	virtual ~tt__AutoFocusMode_() { }
	friend tt__AutoFocusMode_ *soap_instantiate_tt__AutoFocusMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5016 */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (1508)
/* Type tt__WideDynamicMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicMode simple type: */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType
{
public:
	enum tt__WideDynamicMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicMode_ (1508)
	virtual int soap_type(void) const { return 1508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicMode_, default initialized and not managed by a soap context
	virtual tt__WideDynamicMode_ *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicMode_); }
	         tt__WideDynamicMode_() { tt__WideDynamicMode_::soap_default(NULL); }
	virtual ~tt__WideDynamicMode_() { }
	friend tt__WideDynamicMode_ *soap_instantiate_tt__WideDynamicMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5041 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (1510)
/* Type tt__BacklightCompensationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationMode simple type: */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationMode_ (1510)
	virtual int soap_type(void) const { return 1510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationMode_, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationMode_); }
	         tt__BacklightCompensationMode_() { tt__BacklightCompensationMode_::soap_default(NULL); }
	virtual ~tt__BacklightCompensationMode_() { }
	friend tt__BacklightCompensationMode_ *soap_instantiate_tt__BacklightCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5057 */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (1512)
/* Type tt__ExposurePriority_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposurePriority simple type: */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType
{
public:
	enum tt__ExposurePriority __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposurePriority_ (1512)
	virtual int soap_type(void) const { return 1512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposurePriority_, default initialized and not managed by a soap context
	virtual tt__ExposurePriority_ *soap_alloc(void) const { return SOAP_NEW(tt__ExposurePriority_); }
	         tt__ExposurePriority_() { tt__ExposurePriority_::soap_default(NULL); }
	virtual ~tt__ExposurePriority_() { }
	friend tt__ExposurePriority_ *soap_instantiate_tt__ExposurePriority_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5073 */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (1514)
/* Type tt__ExposureMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureMode simple type: */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType
{
public:
	enum tt__ExposureMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureMode_ (1514)
	virtual int soap_type(void) const { return 1514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureMode_, default initialized and not managed by a soap context
	virtual tt__ExposureMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ExposureMode_); }
	         tt__ExposureMode_() { tt__ExposureMode_::soap_default(NULL); }
	virtual ~tt__ExposureMode_() { }
	friend tt__ExposureMode_ *soap_instantiate_tt__ExposureMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5089 */
#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (1516)
/* Type tt__Enabled_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Enabled simple type: */
class SOAP_CMAC tt__Enabled_ : public xsd__anyType
{
public:
	enum tt__Enabled __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Enabled_ (1516)
	virtual int soap_type(void) const { return 1516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Enabled_, default initialized and not managed by a soap context
	virtual tt__Enabled_ *soap_alloc(void) const { return SOAP_NEW(tt__Enabled_); }
	         tt__Enabled_() { tt__Enabled_::soap_default(NULL); }
	virtual ~tt__Enabled_() { }
	friend tt__Enabled_ *soap_instantiate_tt__Enabled_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5105 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (1518)
/* Type tt__WhiteBalanceMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceMode simple type: */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceMode_ (1518)
	virtual int soap_type(void) const { return 1518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceMode_, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceMode_ *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceMode_); }
	         tt__WhiteBalanceMode_() { tt__WhiteBalanceMode_::soap_default(NULL); }
	virtual ~tt__WhiteBalanceMode_() { }
	friend tt__WhiteBalanceMode_ *soap_instantiate_tt__WhiteBalanceMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5122 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (1520)
/* Type tt__IrCutFilterMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterMode simple type: */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterMode_ (1520)
	virtual int soap_type(void) const { return 1520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterMode_, default initialized and not managed by a soap context
	virtual tt__IrCutFilterMode_ *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterMode_); }
	         tt__IrCutFilterMode_() { tt__IrCutFilterMode_::soap_default(NULL); }
	virtual ~tt__IrCutFilterMode_() { }
	friend tt__IrCutFilterMode_ *soap_instantiate_tt__IrCutFilterMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5140 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (1522)
/* Type tt__ImageStabilizationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationMode simple type: */
class SOAP_CMAC tt__ImageStabilizationMode_ : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationMode_ (1522)
	virtual int soap_type(void) const { return 1522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationMode_, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationMode_); }
	         tt__ImageStabilizationMode_() { tt__ImageStabilizationMode_::soap_default(NULL); }
	virtual ~tt__ImageStabilizationMode_() { }
	friend tt__ImageStabilizationMode_ *soap_instantiate_tt__ImageStabilizationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5158 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ (1524)
/* Type tt__IrCutFilterAutoBoundaryType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterAutoBoundaryType simple type: */
class SOAP_CMAC tt__IrCutFilterAutoBoundaryType_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterAutoBoundaryType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ (1524)
	virtual int soap_type(void) const { return 1524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoBoundaryType_, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoBoundaryType_ *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoBoundaryType_); }
	         tt__IrCutFilterAutoBoundaryType_() { tt__IrCutFilterAutoBoundaryType_::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoBoundaryType_() { }
	friend tt__IrCutFilterAutoBoundaryType_ *soap_instantiate_tt__IrCutFilterAutoBoundaryType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5175 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode_
#define SOAP_TYPE_tt__ToneCompensationMode_ (1526)
/* Type tt__ToneCompensationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ToneCompensationMode simple type: */
class SOAP_CMAC tt__ToneCompensationMode_ : public xsd__anyType
{
public:
	enum tt__ToneCompensationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationMode_ (1526)
	virtual int soap_type(void) const { return 1526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationMode_, default initialized and not managed by a soap context
	virtual tt__ToneCompensationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationMode_); }
	         tt__ToneCompensationMode_() { tt__ToneCompensationMode_::soap_default(NULL); }
	virtual ~tt__ToneCompensationMode_() { }
	friend tt__ToneCompensationMode_ *soap_instantiate_tt__ToneCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5192 */
#ifndef SOAP_TYPE_tt__DefoggingMode_
#define SOAP_TYPE_tt__DefoggingMode_ (1528)
/* Type tt__DefoggingMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DefoggingMode simple type: */
class SOAP_CMAC tt__DefoggingMode_ : public xsd__anyType
{
public:
	enum tt__DefoggingMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingMode_ (1528)
	virtual int soap_type(void) const { return 1528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingMode_, default initialized and not managed by a soap context
	virtual tt__DefoggingMode_ *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingMode_); }
	         tt__DefoggingMode_() { tt__DefoggingMode_::soap_default(NULL); }
	virtual ~tt__DefoggingMode_() { }
	friend tt__DefoggingMode_ *soap_instantiate_tt__DefoggingMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5203 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation__
#define SOAP_TYPE_tt__TopicNamespaceLocation__ (1530)
/* Type tt__TopicNamespaceLocation__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TopicNamespaceLocation simple type: */
class SOAP_CMAC tt__TopicNamespaceLocation__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TopicNamespaceLocation__ (1530)
	virtual int soap_type(void) const { return 1530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TopicNamespaceLocation__, default initialized and not managed by a soap context
	virtual tt__TopicNamespaceLocation__ *soap_alloc(void) const { return SOAP_NEW(tt__TopicNamespaceLocation__); }
	         tt__TopicNamespaceLocation__() { tt__TopicNamespaceLocation__::soap_default(NULL); }
	virtual ~tt__TopicNamespaceLocation__() { }
	friend tt__TopicNamespaceLocation__ *soap_instantiate_tt__TopicNamespaceLocation__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5220 */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (1532)
/* Type tt__PropertyOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PropertyOperation simple type: */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType
{
public:
	enum tt__PropertyOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PropertyOperation_ (1532)
	virtual int soap_type(void) const { return 1532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PropertyOperation_, default initialized and not managed by a soap context
	virtual tt__PropertyOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__PropertyOperation_); }
	         tt__PropertyOperation_() { tt__PropertyOperation_::soap_default(NULL); }
	virtual ~tt__PropertyOperation_() { }
	friend tt__PropertyOperation_ *soap_instantiate_tt__PropertyOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5237 */
#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (1534)
/* Type tt__Direction_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Direction simple type: */
class SOAP_CMAC tt__Direction_ : public xsd__anyType
{
public:
	enum tt__Direction __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Direction_ (1534)
	virtual int soap_type(void) const { return 1534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Direction_, default initialized and not managed by a soap context
	virtual tt__Direction_ *soap_alloc(void) const { return SOAP_NEW(tt__Direction_); }
	         tt__Direction_() { tt__Direction_::soap_default(NULL); }
	virtual ~tt__Direction_() { }
	friend tt__Direction_ *soap_instantiate_tt__Direction_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5256 */
#ifndef SOAP_TYPE_tt__ClassType_
#define SOAP_TYPE_tt__ClassType_ (1536)
/* Type tt__ClassType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassType simple type: */
class SOAP_CMAC tt__ClassType_ : public xsd__anyType
{
public:
	enum tt__ClassType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassType_ (1536)
	virtual int soap_type(void) const { return 1536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassType_, default initialized and not managed by a soap context
	virtual tt__ClassType_ *soap_alloc(void) const { return SOAP_NEW(tt__ClassType_); }
	         tt__ClassType_() { tt__ClassType_::soap_default(NULL); }
	virtual ~tt__ClassType_() { }
	friend tt__ClassType_ *soap_instantiate_tt__ClassType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5289 */
#ifndef SOAP_TYPE_tt__ReceiverMode_
#define SOAP_TYPE_tt__ReceiverMode_ (1538)
/* Type tt__ReceiverMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverMode simple type: */
class SOAP_CMAC tt__ReceiverMode_ : public xsd__anyType
{
public:
	enum tt__ReceiverMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverMode_ (1538)
	virtual int soap_type(void) const { return 1538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverMode_, default initialized and not managed by a soap context
	virtual tt__ReceiverMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverMode_); }
	         tt__ReceiverMode_() { tt__ReceiverMode_::soap_default(NULL); }
	virtual ~tt__ReceiverMode_() { }
	friend tt__ReceiverMode_ *soap_instantiate_tt__ReceiverMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5322 */
#ifndef SOAP_TYPE_tt__ReceiverState_
#define SOAP_TYPE_tt__ReceiverState_ (1540)
/* Type tt__ReceiverState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverState simple type: */
class SOAP_CMAC tt__ReceiverState_ : public xsd__anyType
{
public:
	enum tt__ReceiverState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverState_ (1540)
	virtual int soap_type(void) const { return 1540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverState_, default initialized and not managed by a soap context
	virtual tt__ReceiverState_ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverState_); }
	         tt__ReceiverState_() { tt__ReceiverState_::soap_default(NULL); }
	virtual ~tt__ReceiverState_() { }
	friend tt__ReceiverState_ *soap_instantiate_tt__ReceiverState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5333 */
#ifndef SOAP_TYPE_tt__Description__
#define SOAP_TYPE_tt__Description__ (1542)
/* Type tt__Description__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Description simple type: */
class SOAP_CMAC tt__Description__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Description__ (1542)
	virtual int soap_type(void) const { return 1542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Description__, default initialized and not managed by a soap context
	virtual tt__Description__ *soap_alloc(void) const { return SOAP_NEW(tt__Description__); }
	         tt__Description__() { tt__Description__::soap_default(NULL); }
	virtual ~tt__Description__() { }
	friend tt__Description__ *soap_instantiate_tt__Description__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5344 */
#ifndef SOAP_TYPE_tt__XPathExpression__
#define SOAP_TYPE_tt__XPathExpression__ (1544)
/* Type tt__XPathExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:XPathExpression simple type: */
class SOAP_CMAC tt__XPathExpression__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__XPathExpression__ (1544)
	virtual int soap_type(void) const { return 1544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__XPathExpression__, default initialized and not managed by a soap context
	virtual tt__XPathExpression__ *soap_alloc(void) const { return SOAP_NEW(tt__XPathExpression__); }
	         tt__XPathExpression__() { tt__XPathExpression__::soap_default(NULL); }
	virtual ~tt__XPathExpression__() { }
	friend tt__XPathExpression__ *soap_instantiate_tt__XPathExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5374 */
#ifndef SOAP_TYPE_tt__SearchState_
#define SOAP_TYPE_tt__SearchState_ (1546)
/* Type tt__SearchState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchState simple type: */
class SOAP_CMAC tt__SearchState_ : public xsd__anyType
{
public:
	enum tt__SearchState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchState_ (1546)
	virtual int soap_type(void) const { return 1546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchState_, default initialized and not managed by a soap context
	virtual tt__SearchState_ *soap_alloc(void) const { return SOAP_NEW(tt__SearchState_); }
	         tt__SearchState_() { tt__SearchState_::soap_default(NULL); }
	virtual ~tt__SearchState_() { }
	friend tt__SearchState_ *soap_instantiate_tt__SearchState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5397 */
#ifndef SOAP_TYPE_tt__RecordingStatus_
#define SOAP_TYPE_tt__RecordingStatus_ (1548)
/* Type tt__RecordingStatus_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingStatus simple type: */
class SOAP_CMAC tt__RecordingStatus_ : public xsd__anyType
{
public:
	enum tt__RecordingStatus __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingStatus_ (1548)
	virtual int soap_type(void) const { return 1548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingStatus_, default initialized and not managed by a soap context
	virtual tt__RecordingStatus_ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingStatus_); }
	         tt__RecordingStatus_() { tt__RecordingStatus_::soap_default(NULL); }
	virtual ~tt__RecordingStatus_() { }
	friend tt__RecordingStatus_ *soap_instantiate_tt__RecordingStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5418 */
#ifndef SOAP_TYPE_tt__TrackType_
#define SOAP_TYPE_tt__TrackType_ (1550)
/* Type tt__TrackType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackType simple type: */
class SOAP_CMAC tt__TrackType_ : public xsd__anyType
{
public:
	enum tt__TrackType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackType_ (1550)
	virtual int soap_type(void) const { return 1550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackType_, default initialized and not managed by a soap context
	virtual tt__TrackType_ *soap_alloc(void) const { return SOAP_NEW(tt__TrackType_); }
	         tt__TrackType_() { tt__TrackType_::soap_default(NULL); }
	virtual ~tt__TrackType_() { }
	friend tt__TrackType_ *soap_instantiate_tt__TrackType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5429 */
#ifndef SOAP_TYPE_tt__RecordingJobMode__
#define SOAP_TYPE_tt__RecordingJobMode__ (1552)
/* Type tt__RecordingJobMode__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobMode simple type: */
class SOAP_CMAC tt__RecordingJobMode__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobMode__ (1552)
	virtual int soap_type(void) const { return 1552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobMode__, default initialized and not managed by a soap context
	virtual tt__RecordingJobMode__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobMode__); }
	         tt__RecordingJobMode__() { tt__RecordingJobMode__::soap_default(NULL); }
	virtual ~tt__RecordingJobMode__() { }
	friend tt__RecordingJobMode__ *soap_instantiate_tt__RecordingJobMode__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5440 */
#ifndef SOAP_TYPE_tt__RecordingJobState__
#define SOAP_TYPE_tt__RecordingJobState__ (1554)
/* Type tt__RecordingJobState__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobState simple type: */
class SOAP_CMAC tt__RecordingJobState__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobState__ (1554)
	virtual int soap_type(void) const { return 1554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobState__, default initialized and not managed by a soap context
	virtual tt__RecordingJobState__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobState__); }
	         tt__RecordingJobState__() { tt__RecordingJobState__::soap_default(NULL); }
	virtual ~tt__RecordingJobState__() { }
	friend tt__RecordingJobState__ *soap_instantiate_tt__RecordingJobState__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5460 */
#ifndef SOAP_TYPE_tt__ModeOfOperation_
#define SOAP_TYPE_tt__ModeOfOperation_ (1556)
/* Type tt__ModeOfOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ModeOfOperation simple type: */
class SOAP_CMAC tt__ModeOfOperation_ : public xsd__anyType
{
public:
	enum tt__ModeOfOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ModeOfOperation_ (1556)
	virtual int soap_type(void) const { return 1556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ModeOfOperation_, default initialized and not managed by a soap context
	virtual tt__ModeOfOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__ModeOfOperation_); }
	         tt__ModeOfOperation_() { tt__ModeOfOperation_::soap_default(NULL); }
	virtual ~tt__ModeOfOperation_() { }
	friend tt__ModeOfOperation_ *soap_instantiate_tt__ModeOfOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5475 */
#ifndef SOAP_TYPE_tt__AudioClassType__
#define SOAP_TYPE_tt__AudioClassType__ (1558)
/* Type tt__AudioClassType__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioClassType simple type: */
class SOAP_CMAC tt__AudioClassType__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassType__ (1558)
	virtual int soap_type(void) const { return 1558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassType__, default initialized and not managed by a soap context
	virtual tt__AudioClassType__ *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassType__); }
	         tt__AudioClassType__() { tt__AudioClassType__::soap_default(NULL); }
	virtual ~tt__AudioClassType__() { }
	friend tt__AudioClassType__ *soap_instantiate_tt__AudioClassType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5492 */
#ifndef SOAP_TYPE_tt__OSDType_
#define SOAP_TYPE_tt__OSDType_ (1560)
/* Type tt__OSDType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDType simple type: */
class SOAP_CMAC tt__OSDType_ : public xsd__anyType
{
public:
	enum tt__OSDType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDType_ (1560)
	virtual int soap_type(void) const { return 1560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDType_, default initialized and not managed by a soap context
	virtual tt__OSDType_ *soap_alloc(void) const { return SOAP_NEW(tt__OSDType_); }
	         tt__OSDType_() { tt__OSDType_::soap_default(NULL); }
	virtual ~tt__OSDType_() { }
	friend tt__OSDType_ *soap_instantiate_tt__OSDType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5531 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression__
#define SOAP_TYPE_wstop__FullTopicExpression__ (1562)
/* Type wstop__FullTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:FullTopicExpression simple type: */
class SOAP_CMAC wstop__FullTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__FullTopicExpression__ (1562)
	virtual int soap_type(void) const { return 1562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__FullTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__FullTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__FullTopicExpression__); }
	         wstop__FullTopicExpression__() { wstop__FullTopicExpression__::soap_default(NULL); }
	virtual ~wstop__FullTopicExpression__() { }
	friend wstop__FullTopicExpression__ *soap_instantiate_wstop__FullTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5547 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (1564)
/* Type wstop__ConcreteTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ConcreteTopicExpression simple type: */
class SOAP_CMAC wstop__ConcreteTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ConcreteTopicExpression__ (1564)
	virtual int soap_type(void) const { return 1564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ConcreteTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__ConcreteTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__ConcreteTopicExpression__); }
	         wstop__ConcreteTopicExpression__() { wstop__ConcreteTopicExpression__::soap_default(NULL); }
	virtual ~wstop__ConcreteTopicExpression__() { }
	friend wstop__ConcreteTopicExpression__ *soap_instantiate_wstop__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5562 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression__
#define SOAP_TYPE_wstop__SimpleTopicExpression__ (1566)
/* Type wstop__SimpleTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:SimpleTopicExpression simple type: */
class SOAP_CMAC wstop__SimpleTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__SimpleTopicExpression__ (1566)
	virtual int soap_type(void) const { return 1566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__SimpleTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__SimpleTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__SimpleTopicExpression__); }
	         wstop__SimpleTopicExpression__() { wstop__SimpleTopicExpression__::soap_default(NULL); }
	virtual ~wstop__SimpleTopicExpression__() { }
	friend wstop__SimpleTopicExpression__ *soap_instantiate_wstop__SimpleTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5633 */
#ifndef SOAP_TYPE_tmd__SerialPortType_
#define SOAP_TYPE_tmd__SerialPortType_ (1568)
/* Type tmd__SerialPortType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortType simple type: */
class SOAP_CMAC tmd__SerialPortType_ : public xsd__anyType
{
public:
	enum tmd__SerialPortType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortType_ (1568)
	virtual int soap_type(void) const { return 1568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortType_, default initialized and not managed by a soap context
	virtual tmd__SerialPortType_ *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortType_); }
	         tmd__SerialPortType_() { tmd__SerialPortType_::soap_default(NULL); }
	virtual ~tmd__SerialPortType_() { }
	friend tmd__SerialPortType_ *soap_instantiate_tmd__SerialPortType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5656 */
#ifndef SOAP_TYPE_tmd__ParityBit_
#define SOAP_TYPE_tmd__ParityBit_ (1570)
/* Type tmd__ParityBit_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:ParityBit simple type: */
class SOAP_CMAC tmd__ParityBit_ : public xsd__anyType
{
public:
	enum tmd__ParityBit __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__ParityBit_ (1570)
	virtual int soap_type(void) const { return 1570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__ParityBit_, default initialized and not managed by a soap context
	virtual tmd__ParityBit_ *soap_alloc(void) const { return SOAP_NEW(tmd__ParityBit_); }
	         tmd__ParityBit_() { tmd__ParityBit_::soap_default(NULL); }
	virtual ~tmd__ParityBit_() { }
	friend tmd__ParityBit_ *soap_instantiate_tmd__ParityBit_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5731 */
#ifndef SOAP_TYPE_tt__ReceiverReference__
#define SOAP_TYPE_tt__ReceiverReference__ (1572)
/* Type tt__ReceiverReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverReference simple type: */
class SOAP_CMAC tt__ReceiverReference__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverReference__ (1572)
	virtual int soap_type(void) const { return 1572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverReference__, default initialized and not managed by a soap context
	virtual tt__ReceiverReference__ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverReference__); }
	         tt__ReceiverReference__() { tt__ReceiverReference__::soap_default(NULL); }
	virtual ~tt__ReceiverReference__() { }
	friend tt__ReceiverReference__ *soap_instantiate_tt__ReceiverReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5742 */
#ifndef SOAP_TYPE_tt__RecordingReference__
#define SOAP_TYPE_tt__RecordingReference__ (1574)
/* Type tt__RecordingReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingReference simple type: */
class SOAP_CMAC tt__RecordingReference__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingReference__ (1574)
	virtual int soap_type(void) const { return 1574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingReference__, default initialized and not managed by a soap context
	virtual tt__RecordingReference__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingReference__); }
	         tt__RecordingReference__() { tt__RecordingReference__::soap_default(NULL); }
	virtual ~tt__RecordingReference__() { }
	friend tt__RecordingReference__ *soap_instantiate_tt__RecordingReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5753 */
#ifndef SOAP_TYPE_tt__TrackReference__
#define SOAP_TYPE_tt__TrackReference__ (1576)
/* Type tt__TrackReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackReference simple type: */
class SOAP_CMAC tt__TrackReference__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackReference__ (1576)
	virtual int soap_type(void) const { return 1576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackReference__, default initialized and not managed by a soap context
	virtual tt__TrackReference__ *soap_alloc(void) const { return SOAP_NEW(tt__TrackReference__); }
	         tt__TrackReference__() { tt__TrackReference__::soap_default(NULL); }
	virtual ~tt__TrackReference__() { }
	friend tt__TrackReference__ *soap_instantiate_tt__TrackReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5764 */
#ifndef SOAP_TYPE_tt__JobToken__
#define SOAP_TYPE_tt__JobToken__ (1578)
/* Type tt__JobToken__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JobToken simple type: */
class SOAP_CMAC tt__JobToken__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JobToken__ (1578)
	virtual int soap_type(void) const { return 1578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JobToken__, default initialized and not managed by a soap context
	virtual tt__JobToken__ *soap_alloc(void) const { return SOAP_NEW(tt__JobToken__); }
	         tt__JobToken__() { tt__JobToken__::soap_default(NULL); }
	virtual ~tt__JobToken__() { }
	friend tt__JobToken__ *soap_instantiate_tt__JobToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5775 */
#ifndef SOAP_TYPE_tt__RecordingJobReference__
#define SOAP_TYPE_tt__RecordingJobReference__ (1580)
/* Type tt__RecordingJobReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobReference simple type: */
class SOAP_CMAC tt__RecordingJobReference__ : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobReference__ (1580)
	virtual int soap_type(void) const { return 1580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobReference__, default initialized and not managed by a soap context
	virtual tt__RecordingJobReference__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobReference__); }
	         tt__RecordingJobReference__() { tt__RecordingJobReference__::soap_default(NULL); }
	virtual ~tt__RecordingJobReference__() { }
	friend tt__RecordingJobReference__ *soap_instantiate_tt__RecordingJobReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5958 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1581)
/* tds:Service-Capabilities complex type: */
class SOAP_CMAC _tds__Service_Capabilities
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__Service_Capabilities (1581)
	virtual int soap_type(void) const { return 1581; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
	virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__Service_Capabilities); }
	         _tds__Service_Capabilities() { _tds__Service_Capabilities::soap_default(NULL); }
	virtual ~_tds__Service_Capabilities() { }
	friend _tds__Service_Capabilities *soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:405 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (228)
/* Type tds__Service is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:Service complex type: */
class SOAP_CMAC tds__Service : public xsd__anyType
{
public:
	std::string Namespace;	/* required element of XSD type xsd:anyURI */
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	_tds__Service_Capabilities *Capabilities;	/* optional element of XSD type tds:Service-Capabilities */
	tt__OnvifVersion *Version;	/* required element of XSD type tt:OnvifVersion */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__Service (228)
	virtual int soap_type(void) const { return 228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__Service, default initialized and not managed by a soap context
	virtual tds__Service *soap_alloc(void) const { return SOAP_NEW(tds__Service); }
	         tds__Service() { tds__Service::soap_default(NULL); }
	virtual ~tds__Service() { }
	friend tds__Service *soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:408 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (229)
/* Type tds__DeviceServiceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:DeviceServiceCapabilities complex type: */
class SOAP_CMAC tds__DeviceServiceCapabilities : public xsd__anyType
{
public:
	tds__NetworkCapabilities *Network;	/* required element of XSD type tds:NetworkCapabilities */
	tds__SecurityCapabilities *Security;	/* required element of XSD type tds:SecurityCapabilities */
	tds__SystemCapabilities *System;	/* required element of XSD type tds:SystemCapabilities */
	tds__MiscCapabilities *Misc;	/* optional element of XSD type tds:MiscCapabilities */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__DeviceServiceCapabilities (229)
	virtual int soap_type(void) const { return 229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
	virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__DeviceServiceCapabilities); }
	         tds__DeviceServiceCapabilities() { tds__DeviceServiceCapabilities::soap_default(NULL); }
	virtual ~tds__DeviceServiceCapabilities() { }
	friend tds__DeviceServiceCapabilities *soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:411 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (230)
/* Type tds__NetworkCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:NetworkCapabilities simple type: */
class SOAP_CMAC tds__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional attribute of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional attribute of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional attribute of XSD type xsd:boolean */
	bool *DynDNS;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot11Configuration;	/* optional attribute of XSD type xsd:boolean */
	int *Dot1XConfigurations;	/* optional attribute of XSD type xsd:int */
	bool *HostnameFromDHCP;	/* optional attribute of XSD type xsd:boolean */
	int *NTP;	/* optional attribute of XSD type xsd:int */
	bool *DHCPv6;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__NetworkCapabilities (230)
	virtual int soap_type(void) const { return 230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__NetworkCapabilities); }
	         tds__NetworkCapabilities() { tds__NetworkCapabilities::soap_default(NULL); }
	virtual ~tds__NetworkCapabilities() { }
	friend tds__NetworkCapabilities *soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:414 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (231)
/* Type tds__SecurityCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:SecurityCapabilities simple type: */
class SOAP_CMAC tds__SecurityCapabilities : public xsd__anyType
{
public:
	bool *TLS1_x002e0;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e1;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e2;	/* optional attribute of XSD type xsd:boolean */
	bool *OnboardKeyGeneration;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessPolicyConfig;	/* optional attribute of XSD type xsd:boolean */
	bool *DefaultAccessPolicy;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot1X;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteUserHandling;	/* optional attribute of XSD type xsd:boolean */
	bool *X_x002e509Token;	/* optional attribute of XSD type xsd:boolean */
	bool *SAMLToken;	/* optional attribute of XSD type xsd:boolean */
	bool *KerberosToken;	/* optional attribute of XSD type xsd:boolean */
	bool *UsernameToken;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpDigest;	/* optional attribute of XSD type xsd:boolean */
	bool *RELToken;	/* optional attribute of XSD type xsd:boolean */
	std::string *SupportedEAPMethods;	/* optional attribute of XSD type tds:EAPMethodTypes */
	int *MaxUsers;	/* optional attribute of XSD type xsd:int */
	int *MaxUserNameLength;	/* optional attribute of XSD type xsd:int */
	int *MaxPasswordLength;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SecurityCapabilities (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SecurityCapabilities); }
	         tds__SecurityCapabilities() { tds__SecurityCapabilities::soap_default(NULL); }
	virtual ~tds__SecurityCapabilities() { }
	friend tds__SecurityCapabilities *soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:417 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (232)
/* Type tds__SystemCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:SystemCapabilities simple type: */
class SOAP_CMAC tds__SystemCapabilities : public xsd__anyType
{
public:
	bool *DiscoveryResolve;	/* optional attribute of XSD type xsd:boolean */
	bool *DiscoveryBye;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteDiscovery;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *FirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpFirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional attribute of XSD type xsd:boolean */
	bool *StorageConfiguration;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SystemCapabilities (232)
	virtual int soap_type(void) const { return 232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
	virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SystemCapabilities); }
	         tds__SystemCapabilities() { tds__SystemCapabilities::soap_default(NULL); }
	virtual ~tds__SystemCapabilities() { }
	friend tds__SystemCapabilities *soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:420 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (233)
/* Type tds__MiscCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:MiscCapabilities simple type: */
class SOAP_CMAC tds__MiscCapabilities : public xsd__anyType
{
public:
	std::string *AuxiliaryCommands;	/* optional attribute of XSD type tt:StringAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__MiscCapabilities (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
	virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__MiscCapabilities); }
	         tds__MiscCapabilities() { tds__MiscCapabilities::soap_default(NULL); }
	virtual ~tds__MiscCapabilities() { }
	friend tds__MiscCapabilities *soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:6340 */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1593)
/* tds:UserCredential-Extension complex type: */
class SOAP_CMAC _tds__UserCredential_Extension
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UserCredential_Extension (1593)
	virtual int soap_type(void) const { return 1593; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UserCredential_Extension, default initialized and not managed by a soap context
	virtual _tds__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__UserCredential_Extension); }
	         _tds__UserCredential_Extension() { _tds__UserCredential_Extension::soap_default(NULL); }
	virtual ~_tds__UserCredential_Extension() { }
	friend _tds__UserCredential_Extension *soap_instantiate__tds__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:423 */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (234)
/* Type tds__UserCredential is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:UserCredential complex type: */
class SOAP_CMAC tds__UserCredential : public xsd__anyType
{
public:
	std::string UserName;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	_tds__UserCredential_Extension *Extension;	/* optional element of XSD type tds:UserCredential-Extension */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__UserCredential (234)
	virtual int soap_type(void) const { return 234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__UserCredential, default initialized and not managed by a soap context
	virtual tds__UserCredential *soap_alloc(void) const { return SOAP_NEW(tds__UserCredential); }
	         tds__UserCredential() { tds__UserCredential::soap_default(NULL); }
	virtual ~tds__UserCredential() { }
	friend tds__UserCredential *soap_instantiate_tds__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:6391 */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1597)
/* tds:StorageConfigurationData-Extension complex type: */
class SOAP_CMAC _tds__StorageConfigurationData_Extension
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StorageConfigurationData_Extension (1597)
	virtual int soap_type(void) const { return 1597; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StorageConfigurationData_Extension, default initialized and not managed by a soap context
	virtual _tds__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__StorageConfigurationData_Extension); }
	         _tds__StorageConfigurationData_Extension() { _tds__StorageConfigurationData_Extension::soap_default(NULL); }
	virtual ~_tds__StorageConfigurationData_Extension() { }
	friend _tds__StorageConfigurationData_Extension *soap_instantiate__tds__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:426 */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (235)
/* Type tds__StorageConfigurationData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:StorageConfigurationData complex type: */
class SOAP_CMAC tds__StorageConfigurationData : public xsd__anyType
{
public:
	std::string *LocalPath;	/* optional element of XSD type xsd:anyURI */
	std::string *StorageUri;	/* optional element of XSD type xsd:anyURI */
	tds__UserCredential *User;	/* optional element of XSD type tds:UserCredential */
	_tds__StorageConfigurationData_Extension *Extension;	/* optional element of XSD type tds:StorageConfigurationData-Extension */
	std::string type;	/* required attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfigurationData (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfigurationData, default initialized and not managed by a soap context
	virtual tds__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfigurationData); }
	         tds__StorageConfigurationData() { tds__StorageConfigurationData::soap_default(NULL); }
	virtual ~tds__StorageConfigurationData() { }
	friend tds__StorageConfigurationData *soap_instantiate_tds__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:432 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (237)
/* tds:GetServices complex type: */
class SOAP_CMAC _tds__GetServices
{
public:
	bool IncludeCapability;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServices (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
	virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW(_tds__GetServices); }
	         _tds__GetServices() { _tds__GetServices::soap_default(NULL); }
	virtual ~_tds__GetServices() { }
	friend _tds__GetServices *soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:435 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (238)
/* tds:GetServicesResponse complex type: */
class SOAP_CMAC _tds__GetServicesResponse
{
public:
	std::vector<tds__Service *> Service;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:Service */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServicesResponse (238)
	virtual int soap_type(void) const { return 238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServicesResponse); }
	         _tds__GetServicesResponse() { _tds__GetServicesResponse::soap_default(NULL); }
	virtual ~_tds__GetServicesResponse() { }
	friend _tds__GetServicesResponse *soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:438 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (239)
/* tds:GetServiceCapabilities complex type: */
class SOAP_CMAC _tds__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilities (239)
	virtual int soap_type(void) const { return 239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilities); }
	         _tds__GetServiceCapabilities() { _tds__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilities() { }
	friend _tds__GetServiceCapabilities *soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:441 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (240)
/* tds:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse
{
public:
	tds__DeviceServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:DeviceServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilitiesResponse (240)
	virtual int soap_type(void) const { return 240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilitiesResponse); }
	         _tds__GetServiceCapabilitiesResponse() { _tds__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilitiesResponse() { }
	friend _tds__GetServiceCapabilitiesResponse *soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:444 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (241)
/* tds:GetDeviceInformation complex type: */
class SOAP_CMAC _tds__GetDeviceInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformation (241)
	virtual int soap_type(void) const { return 241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformation); }
	         _tds__GetDeviceInformation() { _tds__GetDeviceInformation::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformation() { }
	friend _tds__GetDeviceInformation *soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:447 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (242)
/* tds:GetDeviceInformationResponse complex type: */
class SOAP_CMAC _tds__GetDeviceInformationResponse
{
public:
	std::string Manufacturer;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	std::string Model;	/* required element of XSD type xsd:string */
	std::string FirmwareVersion;	/* required element of XSD type xsd:string */
	std::string SerialNumber;	/* required element of XSD type xsd:string */
	std::string HardwareId;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformationResponse (242)
	virtual int soap_type(void) const { return 242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformationResponse); }
	         _tds__GetDeviceInformationResponse() { _tds__GetDeviceInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformationResponse() { }
	friend _tds__GetDeviceInformationResponse *soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:450 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (243)
/* tds:SetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTime (243)
	virtual int soap_type(void) const { return 243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTime); }
	         _tds__SetSystemDateAndTime() { _tds__SetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTime() { }
	friend _tds__SetSystemDateAndTime *soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:453 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (244)
/* tds:SetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTimeResponse (244)
	virtual int soap_type(void) const { return 244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTimeResponse); }
	         _tds__SetSystemDateAndTimeResponse() { _tds__SetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTimeResponse() { }
	friend _tds__SetSystemDateAndTimeResponse *soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:456 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (245)
/* tds:GetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTime
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTime (245)
	virtual int soap_type(void) const { return 245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTime); }
	         _tds__GetSystemDateAndTime() { _tds__GetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTime() { }
	friend _tds__GetSystemDateAndTime *soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:459 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (246)
/* tds:GetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse
{
public:
	tt__SystemDateTime *SystemDateAndTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemDateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTimeResponse (246)
	virtual int soap_type(void) const { return 246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTimeResponse); }
	         _tds__GetSystemDateAndTimeResponse() { _tds__GetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTimeResponse() { }
	friend _tds__GetSystemDateAndTimeResponse *soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:462 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (247)
/* tds:SetSystemFactoryDefault complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefault
{
public:
	enum tt__FactoryDefaultType FactoryDefault;	/* required element of XSD type tt:FactoryDefaultType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefault (247)
	virtual int soap_type(void) const { return 247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefault); }
	         _tds__SetSystemFactoryDefault() { _tds__SetSystemFactoryDefault::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefault() { }
	friend _tds__SetSystemFactoryDefault *soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:465 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (248)
/* tds:SetSystemFactoryDefaultResponse complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefaultResponse); }
	         _tds__SetSystemFactoryDefaultResponse() { _tds__SetSystemFactoryDefaultResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefaultResponse() { }
	friend _tds__SetSystemFactoryDefaultResponse *soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:468 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (249)
/* tds:UpgradeSystemFirmware complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmware
{
public:
	tt__AttachmentData *Firmware;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmware (249)
	virtual int soap_type(void) const { return 249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmware); }
	         _tds__UpgradeSystemFirmware() { _tds__UpgradeSystemFirmware::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmware() { }
	friend _tds__UpgradeSystemFirmware *soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:471 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (250)
/* tds:UpgradeSystemFirmwareResponse complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse
{
public:
	std::string *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (250)
	virtual int soap_type(void) const { return 250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmwareResponse); }
	         _tds__UpgradeSystemFirmwareResponse() { _tds__UpgradeSystemFirmwareResponse::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmwareResponse() { }
	friend _tds__UpgradeSystemFirmwareResponse *soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:474 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (251)
/* tds:SystemReboot complex type: */
class SOAP_CMAC _tds__SystemReboot
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemReboot (251)
	virtual int soap_type(void) const { return 251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
	virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW(_tds__SystemReboot); }
	         _tds__SystemReboot() { _tds__SystemReboot::soap_default(NULL); }
	virtual ~_tds__SystemReboot() { }
	friend _tds__SystemReboot *soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:477 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (252)
/* tds:SystemRebootResponse complex type: */
class SOAP_CMAC _tds__SystemRebootResponse
{
public:
	std::string Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemRebootResponse (252)
	virtual int soap_type(void) const { return 252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
	virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SystemRebootResponse); }
	         _tds__SystemRebootResponse() { _tds__SystemRebootResponse::soap_default(NULL); }
	virtual ~_tds__SystemRebootResponse() { }
	friend _tds__SystemRebootResponse *soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:480 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (253)
/* tds:RestoreSystem complex type: */
class SOAP_CMAC _tds__RestoreSystem
{
public:
	std::vector<tt__BackupFile *> BackupFiles;	/* required element of XSD type tt:BackupFile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystem (253)
	virtual int soap_type(void) const { return 253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
	virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystem); }
	         _tds__RestoreSystem() { _tds__RestoreSystem::soap_default(NULL); }
	virtual ~_tds__RestoreSystem() { }
	friend _tds__RestoreSystem *soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:483 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (254)
/* tds:RestoreSystemResponse complex type: */
class SOAP_CMAC _tds__RestoreSystemResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystemResponse (254)
	virtual int soap_type(void) const { return 254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
	virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystemResponse); }
	         _tds__RestoreSystemResponse() { _tds__RestoreSystemResponse::soap_default(NULL); }
	virtual ~_tds__RestoreSystemResponse() { }
	friend _tds__RestoreSystemResponse *soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:486 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (255)
/* tds:GetSystemBackup complex type: */
class SOAP_CMAC _tds__GetSystemBackup
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackup (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackup); }
	         _tds__GetSystemBackup() { _tds__GetSystemBackup::soap_default(NULL); }
	virtual ~_tds__GetSystemBackup() { }
	friend _tds__GetSystemBackup *soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:489 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (256)
/* tds:GetSystemBackupResponse complex type: */
class SOAP_CMAC _tds__GetSystemBackupResponse
{
public:
	std::vector<tt__BackupFile *> BackupFiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BackupFile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackupResponse (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackupResponse); }
	         _tds__GetSystemBackupResponse() { _tds__GetSystemBackupResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemBackupResponse() { }
	friend _tds__GetSystemBackupResponse *soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:492 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (257)
/* tds:GetSystemSupportInformation complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformation (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformation); }
	         _tds__GetSystemSupportInformation() { _tds__GetSystemSupportInformation::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformation() { }
	friend _tds__GetSystemSupportInformation *soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:495 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (258)
/* tds:GetSystemSupportInformationResponse complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse
{
public:
	tt__SupportInformation *SupportInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformationResponse (258)
	virtual int soap_type(void) const { return 258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformationResponse); }
	         _tds__GetSystemSupportInformationResponse() { _tds__GetSystemSupportInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformationResponse() { }
	friend _tds__GetSystemSupportInformationResponse *soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:498 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (259)
/* tds:GetSystemLog complex type: */
class SOAP_CMAC _tds__GetSystemLog
{
public:
	enum tt__SystemLogType LogType;	/* required element of XSD type tt:SystemLogType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLog (259)
	virtual int soap_type(void) const { return 259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
	virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLog); }
	         _tds__GetSystemLog() { _tds__GetSystemLog::soap_default(NULL); }
	virtual ~_tds__GetSystemLog() { }
	friend _tds__GetSystemLog *soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:501 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (260)
/* tds:GetSystemLogResponse complex type: */
class SOAP_CMAC _tds__GetSystemLogResponse
{
public:
	tt__SystemLog *SystemLog;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemLog */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLogResponse (260)
	virtual int soap_type(void) const { return 260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLogResponse); }
	         _tds__GetSystemLogResponse() { _tds__GetSystemLogResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemLogResponse() { }
	friend _tds__GetSystemLogResponse *soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:504 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (261)
/* tds:GetScopes complex type: */
class SOAP_CMAC _tds__GetScopes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopes (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
	virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopes); }
	         _tds__GetScopes() { _tds__GetScopes::soap_default(NULL); }
	virtual ~_tds__GetScopes() { }
	friend _tds__GetScopes *soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:507 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (262)
/* tds:GetScopesResponse complex type: */
class SOAP_CMAC _tds__GetScopesResponse
{
public:
	std::vector<tt__Scope *> Scopes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Scope */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopesResponse (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopesResponse); }
	         _tds__GetScopesResponse() { _tds__GetScopesResponse::soap_default(NULL); }
	virtual ~_tds__GetScopesResponse() { }
	friend _tds__GetScopesResponse *soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:510 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (263)
/* tds:SetScopes complex type: */
class SOAP_CMAC _tds__SetScopes
{
public:
	std::vector<std::string> Scopes;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopes (263)
	virtual int soap_type(void) const { return 263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
	virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopes); }
	         _tds__SetScopes() { _tds__SetScopes::soap_default(NULL); }
	virtual ~_tds__SetScopes() { }
	friend _tds__SetScopes *soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:513 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (264)
/* tds:SetScopesResponse complex type: */
class SOAP_CMAC _tds__SetScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopesResponse (264)
	virtual int soap_type(void) const { return 264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopesResponse); }
	         _tds__SetScopesResponse() { _tds__SetScopesResponse::soap_default(NULL); }
	virtual ~_tds__SetScopesResponse() { }
	friend _tds__SetScopesResponse *soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:516 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (265)
/* tds:AddScopes complex type: */
class SOAP_CMAC _tds__AddScopes
{
public:
	std::vector<std::string> ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopes (265)
	virtual int soap_type(void) const { return 265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
	virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopes); }
	         _tds__AddScopes() { _tds__AddScopes::soap_default(NULL); }
	virtual ~_tds__AddScopes() { }
	friend _tds__AddScopes *soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:519 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (266)
/* tds:AddScopesResponse complex type: */
class SOAP_CMAC _tds__AddScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopesResponse (266)
	virtual int soap_type(void) const { return 266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
	virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopesResponse); }
	         _tds__AddScopesResponse() { _tds__AddScopesResponse::soap_default(NULL); }
	virtual ~_tds__AddScopesResponse() { }
	friend _tds__AddScopesResponse *soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:522 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (267)
/* tds:RemoveScopes complex type: */
class SOAP_CMAC _tds__RemoveScopes
{
public:
	std::vector<std::string> ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopes (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
	virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopes); }
	         _tds__RemoveScopes() { _tds__RemoveScopes::soap_default(NULL); }
	virtual ~_tds__RemoveScopes() { }
	friend _tds__RemoveScopes *soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:525 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (268)
/* tds:RemoveScopesResponse complex type: */
class SOAP_CMAC _tds__RemoveScopesResponse
{
public:
	std::vector<std::string> ScopeItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopesResponse (268)
	virtual int soap_type(void) const { return 268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopesResponse); }
	         _tds__RemoveScopesResponse() { _tds__RemoveScopesResponse::soap_default(NULL); }
	virtual ~_tds__RemoveScopesResponse() { }
	friend _tds__RemoveScopesResponse *soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:528 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (269)
/* tds:GetDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryMode (269)
	virtual int soap_type(void) const { return 269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryMode); }
	         _tds__GetDiscoveryMode() { _tds__GetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryMode() { }
	friend _tds__GetDiscoveryMode *soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:531 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (270)
/* tds:GetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryModeResponse (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryModeResponse); }
	         _tds__GetDiscoveryModeResponse() { _tds__GetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryModeResponse() { }
	friend _tds__GetDiscoveryModeResponse *soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:534 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (271)
/* tds:SetDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetDiscoveryMode
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryMode (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryMode); }
	         _tds__SetDiscoveryMode() { _tds__SetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryMode() { }
	friend _tds__SetDiscoveryMode *soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:537 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (272)
/* tds:SetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryModeResponse (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryModeResponse); }
	         _tds__SetDiscoveryModeResponse() { _tds__SetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryModeResponse() { }
	friend _tds__SetDiscoveryModeResponse *soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:540 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (273)
/* tds:GetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryMode (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryMode); }
	         _tds__GetRemoteDiscoveryMode() { _tds__GetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryMode() { }
	friend _tds__GetRemoteDiscoveryMode *soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:543 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (274)
/* tds:GetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryModeResponse); }
	         _tds__GetRemoteDiscoveryModeResponse() { _tds__GetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
	friend _tds__GetRemoteDiscoveryModeResponse *soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:546 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (275)
/* tds:SetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryMode (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryMode); }
	         _tds__SetRemoteDiscoveryMode() { _tds__SetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryMode() { }
	friend _tds__SetRemoteDiscoveryMode *soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:549 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (276)
/* tds:SetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryModeResponse); }
	         _tds__SetRemoteDiscoveryModeResponse() { _tds__SetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
	friend _tds__SetRemoteDiscoveryModeResponse *soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:552 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (277)
/* tds:GetDPAddresses complex type: */
class SOAP_CMAC _tds__GetDPAddresses
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddresses (277)
	virtual int soap_type(void) const { return 277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddresses); }
	         _tds__GetDPAddresses() { _tds__GetDPAddresses::soap_default(NULL); }
	virtual ~_tds__GetDPAddresses() { }
	friend _tds__GetDPAddresses *soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:555 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (278)
/* tds:GetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__GetDPAddressesResponse
{
public:
	std::vector<tt__NetworkHost *> DPAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddressesResponse (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddressesResponse); }
	         _tds__GetDPAddressesResponse() { _tds__GetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__GetDPAddressesResponse() { }
	friend _tds__GetDPAddressesResponse *soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:558 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (279)
/* tds:SetDPAddresses complex type: */
class SOAP_CMAC _tds__SetDPAddresses
{
public:
	std::vector<tt__NetworkHost *> DPAddress;	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddresses (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddresses); }
	         _tds__SetDPAddresses() { _tds__SetDPAddresses::soap_default(NULL); }
	virtual ~_tds__SetDPAddresses() { }
	friend _tds__SetDPAddresses *soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:561 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (280)
/* tds:SetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__SetDPAddressesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddressesResponse (280)
	virtual int soap_type(void) const { return 280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddressesResponse); }
	         _tds__SetDPAddressesResponse() { _tds__SetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__SetDPAddressesResponse() { }
	friend _tds__SetDPAddressesResponse *soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:564 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (281)
/* tds:GetEndpointReference complex type: */
class SOAP_CMAC _tds__GetEndpointReference
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReference (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReference); }
	         _tds__GetEndpointReference() { _tds__GetEndpointReference::soap_default(NULL); }
	virtual ~_tds__GetEndpointReference() { }
	friend _tds__GetEndpointReference *soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:567 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (282)
/* tds:GetEndpointReferenceResponse complex type: */
class SOAP_CMAC _tds__GetEndpointReferenceResponse
{
public:
	std::string GUID;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReferenceResponse (282)
	virtual int soap_type(void) const { return 282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReferenceResponse); }
	         _tds__GetEndpointReferenceResponse() { _tds__GetEndpointReferenceResponse::soap_default(NULL); }
	virtual ~_tds__GetEndpointReferenceResponse() { }
	friend _tds__GetEndpointReferenceResponse *soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:570 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (283)
/* tds:GetRemoteUser complex type: */
class SOAP_CMAC _tds__GetRemoteUser
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUser (283)
	virtual int soap_type(void) const { return 283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUser); }
	         _tds__GetRemoteUser() { _tds__GetRemoteUser::soap_default(NULL); }
	virtual ~_tds__GetRemoteUser() { }
	friend _tds__GetRemoteUser *soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:573 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (284)
/* tds:GetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__GetRemoteUserResponse
{
public:
	tt__RemoteUser *RemoteUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUserResponse (284)
	virtual int soap_type(void) const { return 284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUserResponse); }
	         _tds__GetRemoteUserResponse() { _tds__GetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteUserResponse() { }
	friend _tds__GetRemoteUserResponse *soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:576 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (285)
/* tds:SetRemoteUser complex type: */
class SOAP_CMAC _tds__SetRemoteUser
{
public:
	tt__RemoteUser *RemoteUser;	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUser (285)
	virtual int soap_type(void) const { return 285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUser); }
	         _tds__SetRemoteUser() { _tds__SetRemoteUser::soap_default(NULL); }
	virtual ~_tds__SetRemoteUser() { }
	friend _tds__SetRemoteUser *soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:579 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (286)
/* tds:SetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__SetRemoteUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUserResponse (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUserResponse); }
	         _tds__SetRemoteUserResponse() { _tds__SetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteUserResponse() { }
	friend _tds__SetRemoteUserResponse *soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:582 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (287)
/* tds:GetUsers complex type: */
class SOAP_CMAC _tds__GetUsers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsers (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
	virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsers); }
	         _tds__GetUsers() { _tds__GetUsers::soap_default(NULL); }
	virtual ~_tds__GetUsers() { }
	friend _tds__GetUsers *soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:585 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (288)
/* tds:GetUsersResponse complex type: */
class SOAP_CMAC _tds__GetUsersResponse
{
public:
	std::vector<tt__User *> User;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsersResponse (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
	virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsersResponse); }
	         _tds__GetUsersResponse() { _tds__GetUsersResponse::soap_default(NULL); }
	virtual ~_tds__GetUsersResponse() { }
	friend _tds__GetUsersResponse *soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:588 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (289)
/* tds:CreateUsers complex type: */
class SOAP_CMAC _tds__CreateUsers
{
public:
	std::vector<tt__User *> User;	/* required element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsers (289)
	virtual int soap_type(void) const { return 289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
	virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsers); }
	         _tds__CreateUsers() { _tds__CreateUsers::soap_default(NULL); }
	virtual ~_tds__CreateUsers() { }
	friend _tds__CreateUsers *soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:591 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (290)
/* tds:CreateUsersResponse complex type: */
class SOAP_CMAC _tds__CreateUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsersResponse (290)
	virtual int soap_type(void) const { return 290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
	virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsersResponse); }
	         _tds__CreateUsersResponse() { _tds__CreateUsersResponse::soap_default(NULL); }
	virtual ~_tds__CreateUsersResponse() { }
	friend _tds__CreateUsersResponse *soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:594 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (291)
/* tds:DeleteUsers complex type: */
class SOAP_CMAC _tds__DeleteUsers
{
public:
	std::vector<std::string> Username;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsers (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
	virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsers); }
	         _tds__DeleteUsers() { _tds__DeleteUsers::soap_default(NULL); }
	virtual ~_tds__DeleteUsers() { }
	friend _tds__DeleteUsers *soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:597 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (292)
/* tds:DeleteUsersResponse complex type: */
class SOAP_CMAC _tds__DeleteUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsersResponse (292)
	virtual int soap_type(void) const { return 292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsersResponse); }
	         _tds__DeleteUsersResponse() { _tds__DeleteUsersResponse::soap_default(NULL); }
	virtual ~_tds__DeleteUsersResponse() { }
	friend _tds__DeleteUsersResponse *soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:600 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (293)
/* tds:SetUser complex type: */
class SOAP_CMAC _tds__SetUser
{
public:
	std::vector<tt__User *> User;	/* required element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUser (293)
	virtual int soap_type(void) const { return 293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
	virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetUser); }
	         _tds__SetUser() { _tds__SetUser::soap_default(NULL); }
	virtual ~_tds__SetUser() { }
	friend _tds__SetUser *soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:603 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (294)
/* tds:SetUserResponse complex type: */
class SOAP_CMAC _tds__SetUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUserResponse (294)
	virtual int soap_type(void) const { return 294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetUserResponse); }
	         _tds__SetUserResponse() { _tds__SetUserResponse::soap_default(NULL); }
	virtual ~_tds__SetUserResponse() { }
	friend _tds__SetUserResponse *soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:606 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (295)
/* tds:GetWsdlUrl complex type: */
class SOAP_CMAC _tds__GetWsdlUrl
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrl (295)
	virtual int soap_type(void) const { return 295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrl); }
	         _tds__GetWsdlUrl() { _tds__GetWsdlUrl::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrl() { }
	friend _tds__GetWsdlUrl *soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:609 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (296)
/* tds:GetWsdlUrlResponse complex type: */
class SOAP_CMAC _tds__GetWsdlUrlResponse
{
public:
	std::string WsdlUrl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrlResponse (296)
	virtual int soap_type(void) const { return 296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrlResponse); }
	         _tds__GetWsdlUrlResponse() { _tds__GetWsdlUrlResponse::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrlResponse() { }
	friend _tds__GetWsdlUrlResponse *soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:612 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (297)
/* tds:GetCapabilities complex type: */
class SOAP_CMAC _tds__GetCapabilities
{
public:
	std::vector<enum tt__CapabilityCategory> Category;	/* optional element of XSD type tt:CapabilityCategory */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilities (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilities); }
	         _tds__GetCapabilities() { _tds__GetCapabilities::soap_default(NULL); }
	virtual ~_tds__GetCapabilities() { }
	friend _tds__GetCapabilities *soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:615 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (298)
/* tds:GetCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetCapabilitiesResponse
{
public:
	tt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilitiesResponse (298)
	virtual int soap_type(void) const { return 298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilitiesResponse); }
	         _tds__GetCapabilitiesResponse() { _tds__GetCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetCapabilitiesResponse() { }
	friend _tds__GetCapabilitiesResponse *soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:618 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (299)
/* tds:GetHostname complex type: */
class SOAP_CMAC _tds__GetHostname
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostname (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
	virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostname); }
	         _tds__GetHostname() { _tds__GetHostname::soap_default(NULL); }
	virtual ~_tds__GetHostname() { }
	friend _tds__GetHostname *soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:621 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (300)
/* tds:GetHostnameResponse complex type: */
class SOAP_CMAC _tds__GetHostnameResponse
{
public:
	tt__HostnameInformation *HostnameInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:HostnameInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostnameResponse (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostnameResponse); }
	         _tds__GetHostnameResponse() { _tds__GetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__GetHostnameResponse() { }
	friend _tds__GetHostnameResponse *soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:624 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (301)
/* tds:SetHostname complex type: */
class SOAP_CMAC _tds__SetHostname
{
public:
	std::string Name;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostname (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
	virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostname); }
	         _tds__SetHostname() { _tds__SetHostname::soap_default(NULL); }
	virtual ~_tds__SetHostname() { }
	friend _tds__SetHostname *soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:627 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (302)
/* tds:SetHostnameResponse complex type: */
class SOAP_CMAC _tds__SetHostnameResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameResponse (302)
	virtual int soap_type(void) const { return 302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameResponse); }
	         _tds__SetHostnameResponse() { _tds__SetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameResponse() { }
	friend _tds__SetHostnameResponse *soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:630 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (303)
/* tds:SetHostnameFromDHCP complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCP (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCP); }
	         _tds__SetHostnameFromDHCP() { _tds__SetHostnameFromDHCP::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCP() { }
	friend _tds__SetHostnameFromDHCP *soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:633 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (304)
/* tds:SetHostnameFromDHCPResponse complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCPResponse (304)
	virtual int soap_type(void) const { return 304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCPResponse); }
	         _tds__SetHostnameFromDHCPResponse() { _tds__SetHostnameFromDHCPResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCPResponse() { }
	friend _tds__SetHostnameFromDHCPResponse *soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:636 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (305)
/* tds:GetDNS complex type: */
class SOAP_CMAC _tds__GetDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNS (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
	virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNS); }
	         _tds__GetDNS() { _tds__GetDNS::soap_default(NULL); }
	virtual ~_tds__GetDNS() { }
	friend _tds__GetDNS *soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:639 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (306)
/* tds:GetDNSResponse complex type: */
class SOAP_CMAC _tds__GetDNSResponse
{
public:
	tt__DNSInformation *DNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNSResponse (306)
	virtual int soap_type(void) const { return 306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNSResponse); }
	         _tds__GetDNSResponse() { _tds__GetDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDNSResponse() { }
	friend _tds__GetDNSResponse *soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:642 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (307)
/* tds:SetDNS complex type: */
class SOAP_CMAC _tds__SetDNS
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> SearchDomain;	/* optional element of XSD type xsd:token */
	std::vector<tt__IPAddress *> DNSManual;	/* optional element of XSD type tt:IPAddress */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNS (307)
	virtual int soap_type(void) const { return 307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
	virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNS); }
	         _tds__SetDNS() { _tds__SetDNS::soap_default(NULL); }
	virtual ~_tds__SetDNS() { }
	friend _tds__SetDNS *soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:645 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (308)
/* tds:SetDNSResponse complex type: */
class SOAP_CMAC _tds__SetDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNSResponse (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNSResponse); }
	         _tds__SetDNSResponse() { _tds__SetDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDNSResponse() { }
	friend _tds__SetDNSResponse *soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:648 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (309)
/* tds:GetNTP complex type: */
class SOAP_CMAC _tds__GetNTP
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTP (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
	virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTP); }
	         _tds__GetNTP() { _tds__GetNTP::soap_default(NULL); }
	virtual ~_tds__GetNTP() { }
	friend _tds__GetNTP *soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:651 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (310)
/* tds:GetNTPResponse complex type: */
class SOAP_CMAC _tds__GetNTPResponse
{
public:
	tt__NTPInformation *NTPInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NTPInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTPResponse (310)
	virtual int soap_type(void) const { return 310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTPResponse); }
	         _tds__GetNTPResponse() { _tds__GetNTPResponse::soap_default(NULL); }
	virtual ~_tds__GetNTPResponse() { }
	friend _tds__GetNTPResponse *soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:654 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (311)
/* tds:SetNTP complex type: */
class SOAP_CMAC _tds__SetNTP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<tt__NetworkHost *> NTPManual;	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTP (311)
	virtual int soap_type(void) const { return 311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
	virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTP); }
	         _tds__SetNTP() { _tds__SetNTP::soap_default(NULL); }
	virtual ~_tds__SetNTP() { }
	friend _tds__SetNTP *soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:657 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (312)
/* tds:SetNTPResponse complex type: */
class SOAP_CMAC _tds__SetNTPResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTPResponse (312)
	virtual int soap_type(void) const { return 312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTPResponse); }
	         _tds__SetNTPResponse() { _tds__SetNTPResponse::soap_default(NULL); }
	virtual ~_tds__SetNTPResponse() { }
	friend _tds__SetNTPResponse *soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:660 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (313)
/* tds:GetDynamicDNS complex type: */
class SOAP_CMAC _tds__GetDynamicDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNS (313)
	virtual int soap_type(void) const { return 313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNS); }
	         _tds__GetDynamicDNS() { _tds__GetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNS() { }
	friend _tds__GetDynamicDNS *soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:663 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (314)
/* tds:GetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__GetDynamicDNSResponse
{
public:
	tt__DynamicDNSInformation *DynamicDNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DynamicDNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNSResponse (314)
	virtual int soap_type(void) const { return 314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNSResponse); }
	         _tds__GetDynamicDNSResponse() { _tds__GetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNSResponse() { }
	friend _tds__GetDynamicDNSResponse *soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:666 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (315)
/* tds:SetDynamicDNS complex type: */
class SOAP_CMAC _tds__SetDynamicDNS
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	std::string *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNS (315)
	virtual int soap_type(void) const { return 315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNS); }
	         _tds__SetDynamicDNS() { _tds__SetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNS() { }
	friend _tds__SetDynamicDNS *soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:669 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (316)
/* tds:SetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__SetDynamicDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNSResponse (316)
	virtual int soap_type(void) const { return 316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNSResponse); }
	         _tds__SetDynamicDNSResponse() { _tds__SetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNSResponse() { }
	friend _tds__SetDynamicDNSResponse *soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:672 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (317)
/* tds:GetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__GetNetworkInterfaces
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfaces (317)
	virtual int soap_type(void) const { return 317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfaces); }
	         _tds__GetNetworkInterfaces() { _tds__GetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfaces() { }
	friend _tds__GetNetworkInterfaces *soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:675 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (318)
/* tds:GetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse
{
public:
	std::vector<tt__NetworkInterface *> NetworkInterfaces;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkInterface */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfacesResponse (318)
	virtual int soap_type(void) const { return 318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfacesResponse); }
	         _tds__GetNetworkInterfacesResponse() { _tds__GetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfacesResponse() { }
	friend _tds__GetNetworkInterfacesResponse *soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:678 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (319)
/* tds:SetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__SetNetworkInterfaces
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__NetworkInterfaceSetConfiguration *NetworkInterface;	/* required element of XSD type tt:NetworkInterfaceSetConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfaces (319)
	virtual int soap_type(void) const { return 319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfaces); }
	         _tds__SetNetworkInterfaces() { _tds__SetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfaces() { }
	friend _tds__SetNetworkInterfaces *soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:681 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (320)
/* tds:SetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfacesResponse (320)
	virtual int soap_type(void) const { return 320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfacesResponse); }
	         _tds__SetNetworkInterfacesResponse() { _tds__SetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfacesResponse() { }
	friend _tds__SetNetworkInterfacesResponse *soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:684 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (321)
/* tds:GetNetworkProtocols complex type: */
class SOAP_CMAC _tds__GetNetworkProtocols
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocols (321)
	virtual int soap_type(void) const { return 321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocols); }
	         _tds__GetNetworkProtocols() { _tds__GetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocols() { }
	friend _tds__GetNetworkProtocols *soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:687 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (322)
/* tds:GetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse
{
public:
	std::vector<tt__NetworkProtocol *> NetworkProtocols;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:NetworkProtocol */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocolsResponse (322)
	virtual int soap_type(void) const { return 322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocolsResponse); }
	         _tds__GetNetworkProtocolsResponse() { _tds__GetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocolsResponse() { }
	friend _tds__GetNetworkProtocolsResponse *soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:690 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (323)
/* tds:SetNetworkProtocols complex type: */
class SOAP_CMAC _tds__SetNetworkProtocols
{
public:
	std::vector<tt__NetworkProtocol *> NetworkProtocols;	/* required element of XSD type tt:NetworkProtocol */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocols (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocols); }
	         _tds__SetNetworkProtocols() { _tds__SetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocols() { }
	friend _tds__SetNetworkProtocols *soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:693 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (324)
/* tds:SetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocolsResponse (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocolsResponse); }
	         _tds__SetNetworkProtocolsResponse() { _tds__SetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocolsResponse() { }
	friend _tds__SetNetworkProtocolsResponse *soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:696 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (325)
/* tds:GetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGateway
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGateway (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGateway); }
	         _tds__GetNetworkDefaultGateway() { _tds__GetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGateway() { }
	friend _tds__GetNetworkDefaultGateway *soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:699 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (326)
/* tds:GetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse
{
public:
	tt__NetworkGateway *NetworkGateway;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkGateway */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (326)
	virtual int soap_type(void) const { return 326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGatewayResponse); }
	         _tds__GetNetworkDefaultGatewayResponse() { _tds__GetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
	friend _tds__GetNetworkDefaultGatewayResponse *soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:702 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (327)
/* tds:SetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGateway
{
public:
	std::vector<std::string> IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::vector<std::string> IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGateway (327)
	virtual int soap_type(void) const { return 327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGateway); }
	         _tds__SetNetworkDefaultGateway() { _tds__SetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGateway() { }
	friend _tds__SetNetworkDefaultGateway *soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:705 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (328)
/* tds:SetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGatewayResponse); }
	         _tds__SetNetworkDefaultGatewayResponse() { _tds__SetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
	friend _tds__SetNetworkDefaultGatewayResponse *soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:708 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (329)
/* tds:GetZeroConfiguration complex type: */
class SOAP_CMAC _tds__GetZeroConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfiguration (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfiguration); }
	         _tds__GetZeroConfiguration() { _tds__GetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__GetZeroConfiguration() { }
	friend _tds__GetZeroConfiguration *soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:711 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (330)
/* tds:GetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetZeroConfigurationResponse
{
public:
	tt__NetworkZeroConfiguration *ZeroConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkZeroConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfigurationResponse (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfigurationResponse); }
	         _tds__GetZeroConfigurationResponse() { _tds__GetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetZeroConfigurationResponse() { }
	friend _tds__GetZeroConfigurationResponse *soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:714 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (331)
/* tds:SetZeroConfiguration complex type: */
class SOAP_CMAC _tds__SetZeroConfiguration
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfiguration (331)
	virtual int soap_type(void) const { return 331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfiguration); }
	         _tds__SetZeroConfiguration() { _tds__SetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__SetZeroConfiguration() { }
	friend _tds__SetZeroConfiguration *soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:717 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (332)
/* tds:SetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetZeroConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfigurationResponse (332)
	virtual int soap_type(void) const { return 332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfigurationResponse); }
	         _tds__SetZeroConfigurationResponse() { _tds__SetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetZeroConfigurationResponse() { }
	friend _tds__SetZeroConfigurationResponse *soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:720 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (333)
/* tds:GetIPAddressFilter complex type: */
class SOAP_CMAC _tds__GetIPAddressFilter
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilter (333)
	virtual int soap_type(void) const { return 333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilter); }
	         _tds__GetIPAddressFilter() { _tds__GetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilter() { }
	friend _tds__GetIPAddressFilter *soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:723 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (334)
/* tds:GetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__GetIPAddressFilterResponse
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilterResponse (334)
	virtual int soap_type(void) const { return 334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilterResponse); }
	         _tds__GetIPAddressFilterResponse() { _tds__GetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilterResponse() { }
	friend _tds__GetIPAddressFilterResponse *soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:726 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (335)
/* tds:SetIPAddressFilter complex type: */
class SOAP_CMAC _tds__SetIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilter (335)
	virtual int soap_type(void) const { return 335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilter); }
	         _tds__SetIPAddressFilter() { _tds__SetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilter() { }
	friend _tds__SetIPAddressFilter *soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:729 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (336)
/* tds:SetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__SetIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilterResponse (336)
	virtual int soap_type(void) const { return 336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilterResponse); }
	         _tds__SetIPAddressFilterResponse() { _tds__SetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilterResponse() { }
	friend _tds__SetIPAddressFilterResponse *soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:732 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (337)
/* tds:AddIPAddressFilter complex type: */
class SOAP_CMAC _tds__AddIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilter (337)
	virtual int soap_type(void) const { return 337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilter); }
	         _tds__AddIPAddressFilter() { _tds__AddIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilter() { }
	friend _tds__AddIPAddressFilter *soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:735 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (338)
/* tds:AddIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__AddIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilterResponse (338)
	virtual int soap_type(void) const { return 338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilterResponse); }
	         _tds__AddIPAddressFilterResponse() { _tds__AddIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilterResponse() { }
	friend _tds__AddIPAddressFilterResponse *soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:738 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (339)
/* tds:RemoveIPAddressFilter complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilter (339)
	virtual int soap_type(void) const { return 339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilter); }
	         _tds__RemoveIPAddressFilter() { _tds__RemoveIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilter() { }
	friend _tds__RemoveIPAddressFilter *soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:741 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (340)
/* tds:RemoveIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilterResponse (340)
	virtual int soap_type(void) const { return 340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilterResponse); }
	         _tds__RemoveIPAddressFilterResponse() { _tds__RemoveIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilterResponse() { }
	friend _tds__RemoveIPAddressFilterResponse *soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:744 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (341)
/* tds:GetAccessPolicy complex type: */
class SOAP_CMAC _tds__GetAccessPolicy
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicy (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicy); }
	         _tds__GetAccessPolicy() { _tds__GetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicy() { }
	friend _tds__GetAccessPolicy *soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:747 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (342)
/* tds:GetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__GetAccessPolicyResponse
{
public:
	tt__BinaryData *PolicyFile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicyResponse (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicyResponse); }
	         _tds__GetAccessPolicyResponse() { _tds__GetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicyResponse() { }
	friend _tds__GetAccessPolicyResponse *soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:750 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (343)
/* tds:SetAccessPolicy complex type: */
class SOAP_CMAC _tds__SetAccessPolicy
{
public:
	tt__BinaryData *PolicyFile;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicy (343)
	virtual int soap_type(void) const { return 343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicy); }
	         _tds__SetAccessPolicy() { _tds__SetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicy() { }
	friend _tds__SetAccessPolicy *soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:753 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (344)
/* tds:SetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__SetAccessPolicyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicyResponse (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicyResponse); }
	         _tds__SetAccessPolicyResponse() { _tds__SetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicyResponse() { }
	friend _tds__SetAccessPolicyResponse *soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:756 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (345)
/* tds:CreateCertificate complex type: */
class SOAP_CMAC _tds__CreateCertificate
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	time_t *ValidNotBefore;	/* optional element of XSD type xsd:dateTime */
	time_t *ValidNotAfter;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificate (345)
	virtual int soap_type(void) const { return 345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
	virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificate); }
	         _tds__CreateCertificate() { _tds__CreateCertificate::soap_default(NULL); }
	virtual ~_tds__CreateCertificate() { }
	friend _tds__CreateCertificate *soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:759 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (346)
/* tds:CreateCertificateResponse complex type: */
class SOAP_CMAC _tds__CreateCertificateResponse
{
public:
	tt__Certificate *NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificateResponse (346)
	virtual int soap_type(void) const { return 346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
	virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificateResponse); }
	         _tds__CreateCertificateResponse() { _tds__CreateCertificateResponse::soap_default(NULL); }
	virtual ~_tds__CreateCertificateResponse() { }
	friend _tds__CreateCertificateResponse *soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:762 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (347)
/* tds:GetCertificates complex type: */
class SOAP_CMAC _tds__GetCertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificates (347)
	virtual int soap_type(void) const { return 347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
	virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificates); }
	         _tds__GetCertificates() { _tds__GetCertificates::soap_default(NULL); }
	virtual ~_tds__GetCertificates() { }
	friend _tds__GetCertificates *soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:765 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (348)
/* tds:GetCertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesResponse
{
public:
	std::vector<tt__Certificate *> NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesResponse (348)
	virtual int soap_type(void) const { return 348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesResponse); }
	         _tds__GetCertificatesResponse() { _tds__GetCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesResponse() { }
	friend _tds__GetCertificatesResponse *soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:768 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (349)
/* tds:GetCertificatesStatus complex type: */
class SOAP_CMAC _tds__GetCertificatesStatus
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatus (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatus); }
	         _tds__GetCertificatesStatus() { _tds__GetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatus() { }
	friend _tds__GetCertificatesStatus *soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:771 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (350)
/* tds:GetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesStatusResponse
{
public:
	std::vector<tt__CertificateStatus *> CertificateStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:CertificateStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatusResponse (350)
	virtual int soap_type(void) const { return 350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatusResponse); }
	         _tds__GetCertificatesStatusResponse() { _tds__GetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatusResponse() { }
	friend _tds__GetCertificatesStatusResponse *soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:774 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (351)
/* tds:SetCertificatesStatus complex type: */
class SOAP_CMAC _tds__SetCertificatesStatus
{
public:
	std::vector<tt__CertificateStatus *> CertificateStatus;	/* optional element of XSD type tt:CertificateStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatus (351)
	virtual int soap_type(void) const { return 351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatus); }
	         _tds__SetCertificatesStatus() { _tds__SetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatus() { }
	friend _tds__SetCertificatesStatus *soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:777 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (352)
/* tds:SetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__SetCertificatesStatusResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatusResponse (352)
	virtual int soap_type(void) const { return 352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatusResponse); }
	         _tds__SetCertificatesStatusResponse() { _tds__SetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatusResponse() { }
	friend _tds__SetCertificatesStatusResponse *soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:780 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (353)
/* tds:DeleteCertificates complex type: */
class SOAP_CMAC _tds__DeleteCertificates
{
public:
	std::vector<std::string> CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificates (353)
	virtual int soap_type(void) const { return 353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificates); }
	         _tds__DeleteCertificates() { _tds__DeleteCertificates::soap_default(NULL); }
	virtual ~_tds__DeleteCertificates() { }
	friend _tds__DeleteCertificates *soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:783 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (354)
/* tds:DeleteCertificatesResponse complex type: */
class SOAP_CMAC _tds__DeleteCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificatesResponse (354)
	virtual int soap_type(void) const { return 354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificatesResponse); }
	         _tds__DeleteCertificatesResponse() { _tds__DeleteCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__DeleteCertificatesResponse() { }
	friend _tds__DeleteCertificatesResponse *soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:786 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (355)
/* tds:GetPkcs10Request complex type: */
class SOAP_CMAC _tds__GetPkcs10Request
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	tt__BinaryData *Attributes;	/* optional element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10Request (355)
	virtual int soap_type(void) const { return 355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10Request); }
	         _tds__GetPkcs10Request() { _tds__GetPkcs10Request::soap_default(NULL); }
	virtual ~_tds__GetPkcs10Request() { }
	friend _tds__GetPkcs10Request *soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:789 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (356)
/* tds:GetPkcs10RequestResponse complex type: */
class SOAP_CMAC _tds__GetPkcs10RequestResponse
{
public:
	tt__BinaryData *Pkcs10Request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10RequestResponse (356)
	virtual int soap_type(void) const { return 356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10RequestResponse); }
	         _tds__GetPkcs10RequestResponse() { _tds__GetPkcs10RequestResponse::soap_default(NULL); }
	virtual ~_tds__GetPkcs10RequestResponse() { }
	friend _tds__GetPkcs10RequestResponse *soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:792 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (357)
/* tds:LoadCertificates complex type: */
class SOAP_CMAC _tds__LoadCertificates
{
public:
	std::vector<tt__Certificate *> NVTCertificate;	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificates (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificates); }
	         _tds__LoadCertificates() { _tds__LoadCertificates::soap_default(NULL); }
	virtual ~_tds__LoadCertificates() { }
	friend _tds__LoadCertificates *soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:795 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (358)
/* tds:LoadCertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificatesResponse (358)
	virtual int soap_type(void) const { return 358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificatesResponse); }
	         _tds__LoadCertificatesResponse() { _tds__LoadCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificatesResponse() { }
	friend _tds__LoadCertificatesResponse *soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:798 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (359)
/* tds:GetClientCertificateMode complex type: */
class SOAP_CMAC _tds__GetClientCertificateMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateMode (359)
	virtual int soap_type(void) const { return 359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateMode); }
	         _tds__GetClientCertificateMode() { _tds__GetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateMode() { }
	friend _tds__GetClientCertificateMode *soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:801 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (360)
/* tds:GetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__GetClientCertificateModeResponse
{
public:
	bool Enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateModeResponse (360)
	virtual int soap_type(void) const { return 360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateModeResponse); }
	         _tds__GetClientCertificateModeResponse() { _tds__GetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateModeResponse() { }
	friend _tds__GetClientCertificateModeResponse *soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:804 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (361)
/* tds:SetClientCertificateMode complex type: */
class SOAP_CMAC _tds__SetClientCertificateMode
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateMode (361)
	virtual int soap_type(void) const { return 361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateMode); }
	         _tds__SetClientCertificateMode() { _tds__SetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateMode() { }
	friend _tds__SetClientCertificateMode *soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:807 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (362)
/* tds:SetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__SetClientCertificateModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateModeResponse (362)
	virtual int soap_type(void) const { return 362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateModeResponse); }
	         _tds__SetClientCertificateModeResponse() { _tds__SetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateModeResponse() { }
	friend _tds__SetClientCertificateModeResponse *soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:810 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (363)
/* tds:GetCACertificates complex type: */
class SOAP_CMAC _tds__GetCACertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificates (363)
	virtual int soap_type(void) const { return 363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
	virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificates); }
	         _tds__GetCACertificates() { _tds__GetCACertificates::soap_default(NULL); }
	virtual ~_tds__GetCACertificates() { }
	friend _tds__GetCACertificates *soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:813 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (364)
/* tds:GetCACertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCACertificatesResponse
{
public:
	std::vector<tt__Certificate *> CACertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificatesResponse (364)
	virtual int soap_type(void) const { return 364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificatesResponse); }
	         _tds__GetCACertificatesResponse() { _tds__GetCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCACertificatesResponse() { }
	friend _tds__GetCACertificatesResponse *soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:816 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (365)
/* tds:LoadCertificateWithPrivateKey complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey
{
public:
	std::vector<tt__CertificateWithPrivateKey *> CertificateWithPrivateKey;	/* required element of XSD type tt:CertificateWithPrivateKey */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKey (365)
	virtual int soap_type(void) const { return 365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKey); }
	         _tds__LoadCertificateWithPrivateKey() { _tds__LoadCertificateWithPrivateKey::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKey() { }
	friend _tds__LoadCertificateWithPrivateKey *soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:819 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (366)
/* tds:LoadCertificateWithPrivateKeyResponse complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (366)
	virtual int soap_type(void) const { return 366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKeyResponse); }
	         _tds__LoadCertificateWithPrivateKeyResponse() { _tds__LoadCertificateWithPrivateKeyResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
	friend _tds__LoadCertificateWithPrivateKeyResponse *soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:822 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (367)
/* tds:GetCertificateInformation complex type: */
class SOAP_CMAC _tds__GetCertificateInformation
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformation (367)
	virtual int soap_type(void) const { return 367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformation); }
	         _tds__GetCertificateInformation() { _tds__GetCertificateInformation::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformation() { }
	friend _tds__GetCertificateInformation *soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:825 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (368)
/* tds:GetCertificateInformationResponse complex type: */
class SOAP_CMAC _tds__GetCertificateInformationResponse
{
public:
	tt__CertificateInformation *CertificateInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:CertificateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformationResponse (368)
	virtual int soap_type(void) const { return 368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformationResponse); }
	         _tds__GetCertificateInformationResponse() { _tds__GetCertificateInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformationResponse() { }
	friend _tds__GetCertificateInformationResponse *soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:828 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (369)
/* tds:LoadCACertificates complex type: */
class SOAP_CMAC _tds__LoadCACertificates
{
public:
	std::vector<tt__Certificate *> CACertificate;	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificates (369)
	virtual int soap_type(void) const { return 369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificates); }
	         _tds__LoadCACertificates() { _tds__LoadCACertificates::soap_default(NULL); }
	virtual ~_tds__LoadCACertificates() { }
	friend _tds__LoadCACertificates *soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:831 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (370)
/* tds:LoadCACertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCACertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificatesResponse (370)
	virtual int soap_type(void) const { return 370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificatesResponse); }
	         _tds__LoadCACertificatesResponse() { _tds__LoadCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCACertificatesResponse() { }
	friend _tds__LoadCACertificatesResponse *soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:834 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (371)
/* tds:CreateDot1XConfiguration complex type: */
class SOAP_CMAC _tds__CreateDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfiguration (371)
	virtual int soap_type(void) const { return 371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfiguration); }
	         _tds__CreateDot1XConfiguration() { _tds__CreateDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfiguration() { }
	friend _tds__CreateDot1XConfiguration *soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:837 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (372)
/* tds:CreateDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfigurationResponse (372)
	virtual int soap_type(void) const { return 372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfigurationResponse); }
	         _tds__CreateDot1XConfigurationResponse() { _tds__CreateDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfigurationResponse() { }
	friend _tds__CreateDot1XConfigurationResponse *soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:840 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (373)
/* tds:SetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__SetDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfiguration (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfiguration); }
	         _tds__SetDot1XConfiguration() { _tds__SetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfiguration() { }
	friend _tds__SetDot1XConfiguration *soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:843 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (374)
/* tds:SetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfigurationResponse (374)
	virtual int soap_type(void) const { return 374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfigurationResponse); }
	         _tds__SetDot1XConfigurationResponse() { _tds__SetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfigurationResponse() { }
	friend _tds__SetDot1XConfigurationResponse *soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:846 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (375)
/* tds:GetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__GetDot1XConfiguration
{
public:
	std::string Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfiguration (375)
	virtual int soap_type(void) const { return 375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfiguration); }
	         _tds__GetDot1XConfiguration() { _tds__GetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfiguration() { }
	friend _tds__GetDot1XConfiguration *soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:849 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (376)
/* tds:GetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationResponse (376)
	virtual int soap_type(void) const { return 376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationResponse); }
	         _tds__GetDot1XConfigurationResponse() { _tds__GetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationResponse() { }
	friend _tds__GetDot1XConfigurationResponse *soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:852 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (377)
/* tds:GetDot1XConfigurations complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurations (377)
	virtual int soap_type(void) const { return 377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurations); }
	         _tds__GetDot1XConfigurations() { _tds__GetDot1XConfigurations::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurations() { }
	friend _tds__GetDot1XConfigurations *soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:855 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (378)
/* tds:GetDot1XConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse
{
public:
	std::vector<tt__Dot1XConfiguration *> Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationsResponse (378)
	virtual int soap_type(void) const { return 378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationsResponse); }
	         _tds__GetDot1XConfigurationsResponse() { _tds__GetDot1XConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationsResponse() { }
	friend _tds__GetDot1XConfigurationsResponse *soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:858 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (379)
/* tds:DeleteDot1XConfiguration complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfiguration
{
public:
	std::vector<std::string> Dot1XConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfiguration (379)
	virtual int soap_type(void) const { return 379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfiguration); }
	         _tds__DeleteDot1XConfiguration() { _tds__DeleteDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfiguration() { }
	friend _tds__DeleteDot1XConfiguration *soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:861 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (380)
/* tds:DeleteDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfigurationResponse); }
	         _tds__DeleteDot1XConfigurationResponse() { _tds__DeleteDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfigurationResponse() { }
	friend _tds__DeleteDot1XConfigurationResponse *soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:864 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (381)
/* tds:GetRelayOutputs complex type: */
class SOAP_CMAC _tds__GetRelayOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputs (381)
	virtual int soap_type(void) const { return 381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputs); }
	         _tds__GetRelayOutputs() { _tds__GetRelayOutputs::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputs() { }
	friend _tds__GetRelayOutputs *soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:867 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (382)
/* tds:GetRelayOutputsResponse complex type: */
class SOAP_CMAC _tds__GetRelayOutputsResponse
{
public:
	std::vector<tt__RelayOutput *> RelayOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RelayOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputsResponse (382)
	virtual int soap_type(void) const { return 382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputsResponse); }
	         _tds__GetRelayOutputsResponse() { _tds__GetRelayOutputsResponse::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputsResponse() { }
	friend _tds__GetRelayOutputsResponse *soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:870 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (383)
/* tds:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettings
{
public:
	std::string RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettings (383)
	virtual int soap_type(void) const { return 383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettings); }
	         _tds__SetRelayOutputSettings() { _tds__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettings() { }
	friend _tds__SetRelayOutputSettings *soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:873 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (384)
/* tds:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettingsResponse (384)
	virtual int soap_type(void) const { return 384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettingsResponse); }
	         _tds__SetRelayOutputSettingsResponse() { _tds__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettingsResponse() { }
	friend _tds__SetRelayOutputSettingsResponse *soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:876 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (385)
/* tds:SetRelayOutputState complex type: */
class SOAP_CMAC _tds__SetRelayOutputState
{
public:
	std::string RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__RelayLogicalState LogicalState;	/* required element of XSD type tt:RelayLogicalState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputState (385)
	virtual int soap_type(void) const { return 385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputState); }
	         _tds__SetRelayOutputState() { _tds__SetRelayOutputState::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputState() { }
	friend _tds__SetRelayOutputState *soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:879 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (386)
/* tds:SetRelayOutputStateResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputStateResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputStateResponse (386)
	virtual int soap_type(void) const { return 386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputStateResponse); }
	         _tds__SetRelayOutputStateResponse() { _tds__SetRelayOutputStateResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputStateResponse() { }
	friend _tds__SetRelayOutputStateResponse *soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:882 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (387)
/* tds:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommand
{
public:
	std::string AuxiliaryCommand;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommand (387)
	virtual int soap_type(void) const { return 387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommand); }
	         _tds__SendAuxiliaryCommand() { _tds__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommand() { }
	friend _tds__SendAuxiliaryCommand *soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:885 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (388)
/* tds:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse
{
public:
	std::string *AuxiliaryCommandResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommandResponse (388)
	virtual int soap_type(void) const { return 388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommandResponse); }
	         _tds__SendAuxiliaryCommandResponse() { _tds__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommandResponse() { }
	friend _tds__SendAuxiliaryCommandResponse *soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:888 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (389)
/* tds:GetDot11Capabilities complex type: */
class SOAP_CMAC _tds__GetDot11Capabilities
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Capabilities (389)
	virtual int soap_type(void) const { return 389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
	virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Capabilities); }
	         _tds__GetDot11Capabilities() { _tds__GetDot11Capabilities::soap_default(NULL); }
	virtual ~_tds__GetDot11Capabilities() { }
	friend _tds__GetDot11Capabilities *soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:891 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (390)
/* tds:GetDot11CapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse
{
public:
	tt__Dot11Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11CapabilitiesResponse (390)
	virtual int soap_type(void) const { return 390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11CapabilitiesResponse); }
	         _tds__GetDot11CapabilitiesResponse() { _tds__GetDot11CapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11CapabilitiesResponse() { }
	friend _tds__GetDot11CapabilitiesResponse *soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:894 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (391)
/* tds:GetDot11Status complex type: */
class SOAP_CMAC _tds__GetDot11Status
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Status (391)
	virtual int soap_type(void) const { return 391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
	virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Status); }
	         _tds__GetDot11Status() { _tds__GetDot11Status::soap_default(NULL); }
	virtual ~_tds__GetDot11Status() { }
	friend _tds__GetDot11Status *soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:897 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (392)
/* tds:GetDot11StatusResponse complex type: */
class SOAP_CMAC _tds__GetDot11StatusResponse
{
public:
	tt__Dot11Status *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Status */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11StatusResponse (392)
	virtual int soap_type(void) const { return 392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11StatusResponse); }
	         _tds__GetDot11StatusResponse() { _tds__GetDot11StatusResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11StatusResponse() { }
	friend _tds__GetDot11StatusResponse *soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:900 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (393)
/* tds:ScanAvailableDot11Networks complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11Networks
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11Networks (393)
	virtual int soap_type(void) const { return 393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11Networks); }
	         _tds__ScanAvailableDot11Networks() { _tds__ScanAvailableDot11Networks::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11Networks() { }
	friend _tds__ScanAvailableDot11Networks *soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:903 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (394)
/* tds:ScanAvailableDot11NetworksResponse complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse
{
public:
	std::vector<tt__Dot11AvailableNetworks *> Networks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Dot11AvailableNetworks */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (394)
	virtual int soap_type(void) const { return 394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11NetworksResponse); }
	         _tds__ScanAvailableDot11NetworksResponse() { _tds__ScanAvailableDot11NetworksResponse::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
	friend _tds__ScanAvailableDot11NetworksResponse *soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:906 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (395)
/* tds:GetSystemUris complex type: */
class SOAP_CMAC _tds__GetSystemUris
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUris (395)
	virtual int soap_type(void) const { return 395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
	virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUris); }
	         _tds__GetSystemUris() { _tds__GetSystemUris::soap_default(NULL); }
	virtual ~_tds__GetSystemUris() { }
	friend _tds__GetSystemUris *soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:9946 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1662)
/* tds:GetSystemUrisResponse-Extension complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1662)
	virtual int soap_type(void) const { return 1662; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse_Extension); }
	         _tds__GetSystemUrisResponse_Extension() { _tds__GetSystemUrisResponse_Extension::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse_Extension() { }
	friend _tds__GetSystemUrisResponse_Extension *soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:909 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (396)
/* tds:GetSystemUrisResponse complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse
{
public:
	tt__SystemLogUriList *SystemLogUris;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:SystemLogUriList */
	std::string *SupportInfoUri;	/* optional element of XSD type xsd:anyURI */
	std::string *SystemBackupUri;	/* optional element of XSD type xsd:anyURI */
	_tds__GetSystemUrisResponse_Extension *Extension;	/* optional element of XSD type tds:GetSystemUrisResponse-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse); }
	         _tds__GetSystemUrisResponse() { _tds__GetSystemUrisResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse() { }
	friend _tds__GetSystemUrisResponse *soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:912 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (397)
/* tds:StartFirmwareUpgrade complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgrade
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgrade (397)
	virtual int soap_type(void) const { return 397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgrade); }
	         _tds__StartFirmwareUpgrade() { _tds__StartFirmwareUpgrade::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgrade() { }
	friend _tds__StartFirmwareUpgrade *soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:915 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (398)
/* tds:StartFirmwareUpgradeResponse complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse
{
public:
	std::string UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 UploadDelay;	/* external (custom serializer) */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgradeResponse (398)
	virtual int soap_type(void) const { return 398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgradeResponse); }
	         _tds__StartFirmwareUpgradeResponse() { _tds__StartFirmwareUpgradeResponse::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgradeResponse() { }
	friend _tds__StartFirmwareUpgradeResponse *soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:918 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (399)
/* tds:StartSystemRestore complex type: */
class SOAP_CMAC _tds__StartSystemRestore
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestore (399)
	virtual int soap_type(void) const { return 399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestore); }
	         _tds__StartSystemRestore() { _tds__StartSystemRestore::soap_default(NULL); }
	virtual ~_tds__StartSystemRestore() { }
	friend _tds__StartSystemRestore *soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:921 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (400)
/* tds:StartSystemRestoreResponse complex type: */
class SOAP_CMAC _tds__StartSystemRestoreResponse
{
public:
	std::string UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestoreResponse (400)
	virtual int soap_type(void) const { return 400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestoreResponse); }
	         _tds__StartSystemRestoreResponse() { _tds__StartSystemRestoreResponse::soap_default(NULL); }
	virtual ~_tds__StartSystemRestoreResponse() { }
	friend _tds__StartSystemRestoreResponse *soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:924 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (401)
/* tds:GetStorageConfigurations complex type: */
class SOAP_CMAC _tds__GetStorageConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurations (401)
	virtual int soap_type(void) const { return 401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurations); }
	         _tds__GetStorageConfigurations() { _tds__GetStorageConfigurations::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurations() { }
	friend _tds__GetStorageConfigurations *soap_instantiate__tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:927 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (402)
/* tds:GetStorageConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationsResponse
{
public:
	std::vector<tds__StorageConfiguration *> StorageConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationsResponse (402)
	virtual int soap_type(void) const { return 402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationsResponse); }
	         _tds__GetStorageConfigurationsResponse() { _tds__GetStorageConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationsResponse() { }
	friend _tds__GetStorageConfigurationsResponse *soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:930 */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (403)
/* tds:CreateStorageConfiguration complex type: */
class SOAP_CMAC _tds__CreateStorageConfiguration
{
public:
	tds__StorageConfigurationData *StorageConfiguration;	/* required element of XSD type tds:StorageConfigurationData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfiguration (403)
	virtual int soap_type(void) const { return 403; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfiguration); }
	         _tds__CreateStorageConfiguration() { _tds__CreateStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfiguration() { }
	friend _tds__CreateStorageConfiguration *soap_instantiate__tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:933 */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (404)
/* tds:CreateStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateStorageConfigurationResponse
{
public:
	std::string Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfigurationResponse (404)
	virtual int soap_type(void) const { return 404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfigurationResponse); }
	         _tds__CreateStorageConfigurationResponse() { _tds__CreateStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfigurationResponse() { }
	friend _tds__CreateStorageConfigurationResponse *soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:936 */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (405)
/* tds:GetStorageConfiguration complex type: */
class SOAP_CMAC _tds__GetStorageConfiguration
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfiguration (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfiguration); }
	         _tds__GetStorageConfiguration() { _tds__GetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__GetStorageConfiguration() { }
	friend _tds__GetStorageConfiguration *soap_instantiate__tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:939 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (406)
/* tds:GetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationResponse
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationResponse (406)
	virtual int soap_type(void) const { return 406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationResponse); }
	         _tds__GetStorageConfigurationResponse() { _tds__GetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationResponse() { }
	friend _tds__GetStorageConfigurationResponse *soap_instantiate__tds__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:942 */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (407)
/* tds:SetStorageConfiguration complex type: */
class SOAP_CMAC _tds__SetStorageConfiguration
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfiguration (407)
	virtual int soap_type(void) const { return 407; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfiguration); }
	         _tds__SetStorageConfiguration() { _tds__SetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__SetStorageConfiguration() { }
	friend _tds__SetStorageConfiguration *soap_instantiate__tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:945 */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (408)
/* tds:SetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfigurationResponse (408)
	virtual int soap_type(void) const { return 408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfigurationResponse); }
	         _tds__SetStorageConfigurationResponse() { _tds__SetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetStorageConfigurationResponse() { }
	friend _tds__SetStorageConfigurationResponse *soap_instantiate__tds__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:948 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (409)
/* tds:DeleteStorageConfiguration complex type: */
class SOAP_CMAC _tds__DeleteStorageConfiguration
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfiguration (409)
	virtual int soap_type(void) const { return 409; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfiguration); }
	         _tds__DeleteStorageConfiguration() { _tds__DeleteStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfiguration() { }
	friend _tds__DeleteStorageConfiguration *soap_instantiate__tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:951 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (410)
/* tds:DeleteStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfigurationResponse (410)
	virtual int soap_type(void) const { return 410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfigurationResponse); }
	         _tds__DeleteStorageConfigurationResponse() { _tds__DeleteStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfigurationResponse() { }
	friend _tds__DeleteStorageConfigurationResponse *soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:954 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (411)
/* Type tt__DeviceEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceEntity simple type: */
class SOAP_CMAC tt__DeviceEntity : public xsd__anyType
{
public:
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceEntity (411)
	virtual int soap_type(void) const { return 411; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
	virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW(tt__DeviceEntity); }
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
	friend tt__DeviceEntity *soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:957 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (412)
/* Type tt__IntRectangle is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRectangle simple type: */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType
{
public:
	int x;	/* required attribute of XSD type xsd:int */
	int y;	/* required attribute of XSD type xsd:int */
	int width;	/* required attribute of XSD type xsd:int */
	int height;	/* required attribute of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangle (412)
	virtual int soap_type(void) const { return 412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
	virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangle); }
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
	friend tt__IntRectangle *soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:960 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (413)
/* Type tt__IntRectangleRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRectangleRange complex type: */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType
{
public:
	tt__IntRange *XRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *YRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangleRange (413)
	virtual int soap_type(void) const { return 413; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
	virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangleRange); }
	         tt__IntRectangleRange() { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
	friend tt__IntRectangleRange *soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:963 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (414)
/* Type tt__IntRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRange complex type: */
class SOAP_CMAC tt__IntRange : public xsd__anyType
{
public:
	int Min;	/* required element of XSD type xsd:int */
	int Max;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRange (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
	virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRange); }
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
	friend tt__IntRange *soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:966 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (415)
/* Type tt__FloatRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FloatRange complex type: */
class SOAP_CMAC tt__FloatRange : public xsd__anyType
{
public:
	float Min;	/* required element of XSD type xsd:float */
	float Max;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatRange (415)
	virtual int soap_type(void) const { return 415; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
	virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW(tt__FloatRange); }
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
	friend tt__FloatRange *soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:969 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (416)
/* Type tt__DurationRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DurationRange complex type: */
class SOAP_CMAC tt__DurationRange : public xsd__anyType
{
public:
	LONG64 Min;	/* external (custom serializer) */
	LONG64 Max;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DurationRange (416)
	virtual int soap_type(void) const { return 416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
	virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW(tt__DurationRange); }
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
	friend tt__DurationRange *soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:972 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (417)
/* Type tt__IntList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntList complex type: */
class SOAP_CMAC tt__IntList : public xsd__anyType
{
public:
	std::vector<int> Items;	/* optional element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntList (417)
	virtual int soap_type(void) const { return 417; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntList, default initialized and not managed by a soap context
	virtual tt__IntList *soap_alloc(void) const { return SOAP_NEW(tt__IntList); }
	         tt__IntList() { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
	friend tt__IntList *soap_instantiate_tt__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:975 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (418)
/* Type tt__FloatList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FloatList complex type: */
class SOAP_CMAC tt__FloatList : public xsd__anyType
{
public:
	std::vector<float> Items;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatList (418)
	virtual int soap_type(void) const { return 418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatList, default initialized and not managed by a soap context
	virtual tt__FloatList *soap_alloc(void) const { return SOAP_NEW(tt__FloatList); }
	         tt__FloatList() { tt__FloatList::soap_default(NULL); }
	virtual ~tt__FloatList() { }
	friend tt__FloatList *soap_instantiate_tt__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:978 */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (419)
/* Type tt__AnyHolder is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnyHolder complex type: */
class SOAP_CMAC tt__AnyHolder : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnyHolder (419)
	virtual int soap_type(void) const { return 419; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnyHolder, default initialized and not managed by a soap context
	virtual tt__AnyHolder *soap_alloc(void) const { return SOAP_NEW(tt__AnyHolder); }
	         tt__AnyHolder() { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
	friend tt__AnyHolder *soap_instantiate_tt__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:984 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (421)
/* Type tt__VideoSourceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceExtension complex type: */
class SOAP_CMAC tt__VideoSourceExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__ImagingSettings20 *Imaging;	/* optional element of XSD type tt:ImagingSettings20 */
	tt__VideoSourceExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension (421)
	virtual int soap_type(void) const { return 421; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension); }
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
	friend tt__VideoSourceExtension *soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:987 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (422)
/* Type tt__VideoSourceExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension2 (422)
	virtual int soap_type(void) const { return 422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension2); }
	         tt__VideoSourceExtension2() { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
	friend tt__VideoSourceExtension2 *soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:993 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (424)
/* Type tt__Profile is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Profile complex type: */
class SOAP_CMAC tt__Profile : public xsd__anyType
{
public:
	std::string Name;	/* required element of XSD type tt:Name */
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of XSD type tt:VideoSourceConfiguration */
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of XSD type tt:AudioSourceConfiguration */
	tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of XSD type tt:VideoEncoderConfiguration */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZConfiguration;	/* optional element of XSD type tt:PTZConfiguration */
	tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of XSD type tt:MetadataConfiguration */
	tt__ProfileExtension *Extension;	/* optional element of XSD type tt:ProfileExtension */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Profile (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Profile, default initialized and not managed by a soap context
	virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW(tt__Profile); }
	         tt__Profile() { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
	friend tt__Profile *soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:996 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (425)
/* Type tt__ProfileExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileExtension complex type: */
class SOAP_CMAC tt__ProfileExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of XSD type tt:AudioOutputConfiguration */
	tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of XSD type tt:AudioDecoderConfiguration */
	tt__ProfileExtension2 *Extension;	/* optional element of XSD type tt:ProfileExtension2 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension (425)
	virtual int soap_type(void) const { return 425; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
	virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension); }
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
	friend tt__ProfileExtension *soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:999 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (426)
/* Type tt__ProfileExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileExtension2 complex type: */
class SOAP_CMAC tt__ProfileExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension2 (426)
	virtual int soap_type(void) const { return 426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
	virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension2); }
	         tt__ProfileExtension2() { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
	friend tt__ProfileExtension2 *soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1002 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (427)
/* Type tt__ConfigurationEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigurationEntity complex type: */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType
{
public:
	std::string Name;	/* required element of XSD type tt:Name */
	int UseCount;	/* required element of XSD type xsd:int */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigurationEntity (427)
	virtual int soap_type(void) const { return 427; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
	virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW(tt__ConfigurationEntity); }
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
	friend tt__ConfigurationEntity *soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1008 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (429)
/* Type tt__VideoSourceConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension : public xsd__anyType
{
public:
	tt__Rotate *Rotate;	/* optional element of XSD type tt:Rotate */
	tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension (429)
	virtual int soap_type(void) const { return 429; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension); }
	         tt__VideoSourceConfigurationExtension() { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
	friend tt__VideoSourceConfigurationExtension *soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1011 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (430)
/* Type tt__VideoSourceConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<tt__LensDescription *> LensDescription;	/* optional element of XSD type tt:LensDescription */
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (430)
	virtual int soap_type(void) const { return 430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension2); }
	         tt__VideoSourceConfigurationExtension2() { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
	friend tt__VideoSourceConfigurationExtension2 *soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1014 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (431)
/* Type tt__Rotate is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rotate complex type: */
class SOAP_CMAC tt__Rotate : public xsd__anyType
{
public:
	enum tt__RotateMode Mode;	/* required element of XSD type tt:RotateMode */
	int *Degree;	/* optional element of XSD type xsd:int */
	tt__RotateExtension *Extension;	/* optional element of XSD type tt:RotateExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rotate (431)
	virtual int soap_type(void) const { return 431; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
	virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW(tt__Rotate); }
	         tt__Rotate() { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
	friend tt__Rotate *soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1017 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (432)
/* Type tt__RotateExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateExtension complex type: */
class SOAP_CMAC tt__RotateExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateExtension (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
	virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateExtension); }
	         tt__RotateExtension() { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
	friend tt__RotateExtension *soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1020 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (433)
/* Type tt__LensProjection is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LensProjection complex type: */
class SOAP_CMAC tt__LensProjection : public xsd__anyType
{
public:
	float Angle;	/* required element of XSD type xsd:float */
	float Radius;	/* required element of XSD type xsd:float */
	float *Transmittance;	/* optional element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensProjection (433)
	virtual int soap_type(void) const { return 433; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
	virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW(tt__LensProjection); }
	         tt__LensProjection() { tt__LensProjection::soap_default(NULL); }
	virtual ~tt__LensProjection() { }
	friend tt__LensProjection *soap_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1023 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (434)
/* Type tt__LensOffset is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LensOffset simple type: */
class SOAP_CMAC tt__LensOffset : public xsd__anyType
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensOffset (434)
	virtual int soap_type(void) const { return 434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
	virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW(tt__LensOffset); }
	         tt__LensOffset() { tt__LensOffset::soap_default(NULL); }
	virtual ~tt__LensOffset() { }
	friend tt__LensOffset *soap_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1026 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (435)
/* Type tt__LensDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LensDescription complex type: */
class SOAP_CMAC tt__LensDescription : public xsd__anyType
{
public:
	tt__LensOffset *Offset;	/* required element of XSD type tt:LensOffset */
	std::vector<tt__LensProjection *> Projection;	/* required element of XSD type tt:LensProjection */
	float XFactor;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	float *FocalLength;	/* optional attribute of XSD type xsd:float */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensDescription (435)
	virtual int soap_type(void) const { return 435; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
	virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW(tt__LensDescription); }
	         tt__LensDescription() { tt__LensDescription::soap_default(NULL); }
	virtual ~tt__LensDescription() { }
	friend tt__LensDescription *soap_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1029 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (436)
/* Type tt__VideoSourceConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of XSD type tt:IntRectangleRange */
	std::vector<std::string> VideoSourceTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptions (436)
	virtual int soap_type(void) const { return 436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptions); }
	         tt__VideoSourceConfigurationOptions() { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
	friend tt__VideoSourceConfigurationOptions *soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1032 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (437)
/* Type tt__VideoSourceConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__RotateOptions *Rotate;	/* optional element of XSD type tt:RotateOptions */
	tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (437)
	virtual int soap_type(void) const { return 437; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension); }
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
	friend tt__VideoSourceConfigurationOptionsExtension *soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1035 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (438)
/* Type tt__VideoSourceConfigurationOptionsExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (438)
	virtual int soap_type(void) const { return 438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension2); }
	         tt__VideoSourceConfigurationOptionsExtension2() { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
	friend tt__VideoSourceConfigurationOptionsExtension2 *soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1038 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (439)
/* Type tt__RotateOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateOptions complex type: */
class SOAP_CMAC tt__RotateOptions : public xsd__anyType
{
public:
	std::vector<enum tt__RotateMode> Mode;	/* required element of XSD type tt:RotateMode */
	tt__IntList *DegreeList;	/* optional element of XSD type tt:IntList */
	tt__RotateOptionsExtension *Extension;	/* optional element of XSD type tt:RotateOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptions (439)
	virtual int soap_type(void) const { return 439; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
	virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptions); }
	         tt__RotateOptions() { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
	friend tt__RotateOptions *soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1041 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (440)
/* Type tt__RotateOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateOptionsExtension complex type: */
class SOAP_CMAC tt__RotateOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptionsExtension (440)
	virtual int soap_type(void) const { return 440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
	virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptionsExtension); }
	         tt__RotateOptionsExtension() { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
	friend tt__RotateOptionsExtension *soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1047 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (442)
/* Type tt__VideoResolution is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoResolution complex type: */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution (442)
	virtual int soap_type(void) const { return 442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
	virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution); }
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
	friend tt__VideoResolution *soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1050 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (443)
/* Type tt__VideoRateControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoRateControl complex type: */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType
{
public:
	int FrameRateLimit;	/* required element of XSD type xsd:int */
	int EncodingInterval;	/* required element of XSD type xsd:int */
	int BitrateLimit;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl (443)
	virtual int soap_type(void) const { return 443; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
	virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl); }
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
	friend tt__VideoRateControl *soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1053 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (444)
/* Type tt__Mpeg4Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Configuration complex type: */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of XSD type tt:Mpeg4Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Configuration (444)
	virtual int soap_type(void) const { return 444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
	virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Configuration); }
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
	friend tt__Mpeg4Configuration *soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1056 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (445)
/* Type tt__H264Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Configuration complex type: */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of XSD type tt:H264Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Configuration (445)
	virtual int soap_type(void) const { return 445; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
	virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW(tt__H264Configuration); }
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
	friend tt__H264Configuration *soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1059 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (446)
/* Type tt__VideoEncoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRange *QualityRange;	/* required element of XSD type tt:IntRange */
	tt__JpegOptions *JPEG;	/* optional element of XSD type tt:JpegOptions */
	tt__Mpeg4Options *MPEG4;	/* optional element of XSD type tt:Mpeg4Options */
	tt__H264Options *H264;	/* optional element of XSD type tt:H264Options */
	tt__VideoEncoderOptionsExtension *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfigurationOptions (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfigurationOptions); }
	         tt__VideoEncoderConfigurationOptions() { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
	friend tt__VideoEncoderConfigurationOptions *soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1062 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (447)
/* Type tt__VideoEncoderOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderOptionsExtension complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__JpegOptions2 *JPEG;	/* optional element of XSD type tt:JpegOptions2 */
	tt__Mpeg4Options2 *MPEG4;	/* optional element of XSD type tt:Mpeg4Options2 */
	tt__H264Options2 *H264;	/* optional element of XSD type tt:H264Options2 */
	tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension (447)
	virtual int soap_type(void) const { return 447; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension); }
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
	friend tt__VideoEncoderOptionsExtension *soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1065 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (448)
/* Type tt__VideoEncoderOptionsExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (448)
	virtual int soap_type(void) const { return 448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension2); }
	         tt__VideoEncoderOptionsExtension2() { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
	friend tt__VideoEncoderOptionsExtension2 *soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1068 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (449)
/* Type tt__JpegOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions complex type: */
class SOAP_CMAC tt__JpegOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions (449)
	virtual int soap_type(void) const { return 449; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
	virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions); }
	         tt__JpegOptions() { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
	friend tt__JpegOptions *soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1074 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (451)
/* Type tt__Mpeg4Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options complex type: */
class SOAP_CMAC tt__Mpeg4Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	std::vector<enum tt__Mpeg4Profile> Mpeg4ProfilesSupported;	/* required element of XSD type tt:Mpeg4Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options (451)
	virtual int soap_type(void) const { return 451; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options); }
	         tt__Mpeg4Options() { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
	friend tt__Mpeg4Options *soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1080 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (453)
/* Type tt__H264Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options complex type: */
class SOAP_CMAC tt__H264Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	std::vector<enum tt__H264Profile> H264ProfilesSupported;	/* required element of XSD type tt:H264Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options (453)
	virtual int soap_type(void) const { return 453; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
	virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW(tt__H264Options); }
	         tt__H264Options() { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
	friend tt__H264Options *soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1089 */
#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (456)
/* Type tt__VideoResolution2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoResolution2 complex type: */
class SOAP_CMAC tt__VideoResolution2 : public xsd__anyType
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution2 (456)
	virtual int soap_type(void) const { return 456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution2, default initialized and not managed by a soap context
	virtual tt__VideoResolution2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution2); }
	         tt__VideoResolution2() { tt__VideoResolution2::soap_default(NULL); }
	virtual ~tt__VideoResolution2() { }
	friend tt__VideoResolution2 *soap_instantiate_tt__VideoResolution2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1092 */
#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (457)
/* Type tt__VideoRateControl2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoRateControl2 complex type: */
class SOAP_CMAC tt__VideoRateControl2 : public xsd__anyType
{
public:
	float FrameRateLimit;	/* required element of XSD type xsd:float */
	int BitrateLimit;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	bool *ConstantBitRate;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl2 (457)
	virtual int soap_type(void) const { return 457; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl2, default initialized and not managed by a soap context
	virtual tt__VideoRateControl2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl2); }
	         tt__VideoRateControl2() { tt__VideoRateControl2::soap_default(NULL); }
	virtual ~tt__VideoRateControl2() { }
	friend tt__VideoRateControl2 *soap_instantiate_tt__VideoRateControl2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1095 */
#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (458)
/* Type tt__VideoEncoder2ConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoder2ConfigurationOptions : public xsd__anyType
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__IntRange *QualityRange;	/* required element of XSD type tt:IntRange */
	std::vector<tt__VideoResolution2 *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution2 */
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	std::string *GovLengthRange;	/* optional attribute of XSD type tt:IntAttrList */
	std::string *FrameRatesSupported;	/* optional attribute of XSD type tt:FloatAttrList */
	std::string *ProfilesSupported;	/* optional attribute of XSD type tt:StringAttrList */
	bool *ConstantBitRateSupported;	/* optional attribute of XSD type xsd:boolean */
	int *GuaranteedInstances;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (458)
	virtual int soap_type(void) const { return 458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2ConfigurationOptions); }
	         tt__VideoEncoder2ConfigurationOptions() { tt__VideoEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoder2ConfigurationOptions() { }
	friend tt__VideoEncoder2ConfigurationOptions *soap_instantiate_tt__VideoEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1101 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (460)
/* Type tt__AudioSourceConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioSourceConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string> InputTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	tt__AudioSourceOptionsExtension *Extension;	/* optional element of XSD type tt:AudioSourceOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfigurationOptions (460)
	virtual int soap_type(void) const { return 460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfigurationOptions); }
	         tt__AudioSourceConfigurationOptions() { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
	friend tt__AudioSourceConfigurationOptions *soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1104 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (461)
/* Type tt__AudioSourceOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceOptionsExtension complex type: */
class SOAP_CMAC tt__AudioSourceOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceOptionsExtension (461)
	virtual int soap_type(void) const { return 461; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceOptionsExtension); }
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
	friend tt__AudioSourceOptionsExtension *soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1110 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (463)
/* Type tt__AudioEncoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions : public xsd__anyType
{
public:
	std::vector<tt__AudioEncoderConfigurationOption *> Options;	/* optional element of XSD type tt:AudioEncoderConfigurationOption */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOptions (463)
	virtual int soap_type(void) const { return 463; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOptions); }
	         tt__AudioEncoderConfigurationOptions() { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
	friend tt__AudioEncoderConfigurationOptions *soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1113 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (464)
/* Type tt__AudioEncoderConfigurationOption is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfigurationOption complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOption : public xsd__anyType
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOption (464)
	virtual int soap_type(void) const { return 464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOption); }
	         tt__AudioEncoderConfigurationOption() { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
	friend tt__AudioEncoderConfigurationOption *soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1119 */
#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (466)
/* Type tt__AudioEncoder2ConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoder2ConfigurationOptions : public xsd__anyType
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (466)
	virtual int soap_type(void) const { return 466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2ConfigurationOptions); }
	         tt__AudioEncoder2ConfigurationOptions() { tt__AudioEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoder2ConfigurationOptions() { }
	friend tt__AudioEncoder2ConfigurationOptions *soap_instantiate_tt__AudioEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1128 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (469)
/* Type tt__MetadataConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationExtension (469)
	virtual int soap_type(void) const { return 469; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationExtension); }
	         tt__MetadataConfigurationExtension() { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
	friend tt__MetadataConfigurationExtension *soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1131 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (470)
/* Type tt__PTZFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZFilter complex type: */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType
{
public:
	bool Status;	/* required element of XSD type xsd:boolean */
	bool Position;	/* required element of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZFilter (470)
	virtual int soap_type(void) const { return 470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
	virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZFilter); }
	         tt__PTZFilter() { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
	friend tt__PTZFilter *soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:11825 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1719)
/* tt:EventSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1719)
	virtual int soap_type(void) const { return 1719; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy); }
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
	friend _tt__EventSubscription_SubscriptionPolicy *soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1134 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (471)
/* Type tt__EventSubscription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventSubscription complex type: */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tt:EventSubscription-SubscriptionPolicy */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventSubscription (471)
	virtual int soap_type(void) const { return 471; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
	virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW(tt__EventSubscription); }
	         tt__EventSubscription() { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
	friend tt__EventSubscription *soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1137 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (472)
/* Type tt__MetadataConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationOptions complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptions : public xsd__anyType
{
public:
	tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of XSD type tt:PTZStatusFilterOptions */
	std::vector<char *> __any;
	tt__MetadataConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptions (472)
	virtual int soap_type(void) const { return 472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptions); }
	         tt__MetadataConfigurationOptions() { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
	friend tt__MetadataConfigurationOptions *soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1140 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (473)
/* Type tt__MetadataConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<std::string> CompressionType;	/* optional element of XSD type xsd:string */
	tt__MetadataConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (473)
	virtual int soap_type(void) const { return 473; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension); }
	         tt__MetadataConfigurationOptionsExtension() { tt__MetadataConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension() { }
	friend tt__MetadataConfigurationOptionsExtension *soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1143 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (474)
/* Type tt__MetadataConfigurationOptionsExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (474)
	virtual int soap_type(void) const { return 474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension2); }
	         tt__MetadataConfigurationOptionsExtension2() { tt__MetadataConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension2() { }
	friend tt__MetadataConfigurationOptionsExtension2 *soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1146 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (475)
/* Type tt__PTZStatusFilterOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatusFilterOptions complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptions : public xsd__anyType
{
public:
	bool PanTiltStatusSupported;	/* required element of XSD type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	bool *PanTiltPositionSupported;	/* optional element of XSD type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of XSD type xsd:boolean */
	tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of XSD type tt:PTZStatusFilterOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptions (475)
	virtual int soap_type(void) const { return 475; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptions); }
	         tt__PTZStatusFilterOptions() { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
	friend tt__PTZStatusFilterOptions *soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1149 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (476)
/* Type tt__PTZStatusFilterOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatusFilterOptionsExtension complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (476)
	virtual int soap_type(void) const { return 476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptionsExtension); }
	         tt__PTZStatusFilterOptionsExtension() { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
	friend tt__PTZStatusFilterOptionsExtension *soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1155 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (478)
/* Type tt__VideoOutputExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputExtension complex type: */
class SOAP_CMAC tt__VideoOutputExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputExtension (478)
	virtual int soap_type(void) const { return 478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
	virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputExtension); }
	         tt__VideoOutputExtension() { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
	friend tt__VideoOutputExtension *soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1161 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (480)
/* Type tt__VideoOutputConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfigurationOptions (480)
	virtual int soap_type(void) const { return 480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfigurationOptions); }
	         tt__VideoOutputConfigurationOptions() { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
	friend tt__VideoOutputConfigurationOptions *soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1164 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (481)
/* Type tt__VideoDecoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions : public xsd__anyType
{
public:
	tt__JpegDecOptions *JpegDecOptions;	/* optional element of XSD type tt:JpegDecOptions */
	tt__H264DecOptions *H264DecOptions;	/* optional element of XSD type tt:H264DecOptions */
	tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of XSD type tt:Mpeg4DecOptions */
	tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptions (481)
	virtual int soap_type(void) const { return 481; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptions); }
	         tt__VideoDecoderConfigurationOptions() { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
	friend tt__VideoDecoderConfigurationOptions *soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1167 */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (482)
/* Type tt__H264DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264DecOptions complex type: */
class SOAP_CMAC tt__H264DecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	std::vector<enum tt__H264Profile> SupportedH264Profiles;	/* required element of XSD type tt:H264Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264DecOptions (482)
	virtual int soap_type(void) const { return 482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264DecOptions, default initialized and not managed by a soap context
	virtual tt__H264DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__H264DecOptions); }
	         tt__H264DecOptions() { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
	friend tt__H264DecOptions *soap_instantiate_tt__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1170 */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (483)
/* Type tt__JpegDecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegDecOptions complex type: */
class SOAP_CMAC tt__JpegDecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegDecOptions (483)
	virtual int soap_type(void) const { return 483; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegDecOptions, default initialized and not managed by a soap context
	virtual tt__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegDecOptions); }
	         tt__JpegDecOptions() { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
	friend tt__JpegDecOptions *soap_instantiate_tt__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1173 */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (484)
/* Type tt__Mpeg4DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4DecOptions complex type: */
class SOAP_CMAC tt__Mpeg4DecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	std::vector<enum tt__Mpeg4Profile> SupportedMpeg4Profiles;	/* required element of XSD type tt:Mpeg4Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4DecOptions (484)
	virtual int soap_type(void) const { return 484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4DecOptions, default initialized and not managed by a soap context
	virtual tt__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4DecOptions); }
	         tt__Mpeg4DecOptions() { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
	friend tt__Mpeg4DecOptions *soap_instantiate_tt__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1176 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (485)
/* Type tt__VideoDecoderConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (485)
	virtual int soap_type(void) const { return 485; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptionsExtension); }
	         tt__VideoDecoderConfigurationOptionsExtension() { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
	friend tt__VideoDecoderConfigurationOptionsExtension *soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1185 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (488)
/* Type tt__AudioOutputConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string> OutputTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> SendPrimacyOptions;	/* optional element of XSD type xsd:anyURI */
	tt__IntRange *OutputLevelRange;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfigurationOptions (488)
	virtual int soap_type(void) const { return 488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfigurationOptions); }
	         tt__AudioOutputConfigurationOptions() { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
	friend tt__AudioOutputConfigurationOptions *soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1191 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (490)
/* Type tt__AudioDecoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions : public xsd__anyType
{
public:
	tt__AACDecOptions *AACDecOptions;	/* optional element of XSD type tt:AACDecOptions */
	tt__G711DecOptions *G711DecOptions;	/* optional element of XSD type tt:G711DecOptions */
	tt__G726DecOptions *G726DecOptions;	/* optional element of XSD type tt:G726DecOptions */
	tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:AudioDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptions (490)
	virtual int soap_type(void) const { return 490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptions); }
	         tt__AudioDecoderConfigurationOptions() { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
	friend tt__AudioDecoderConfigurationOptions *soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1194 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (491)
/* Type tt__G711DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:G711DecOptions complex type: */
class SOAP_CMAC tt__G711DecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G711DecOptions (491)
	virtual int soap_type(void) const { return 491; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
	virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G711DecOptions); }
	         tt__G711DecOptions() { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
	friend tt__G711DecOptions *soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1197 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (492)
/* Type tt__AACDecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AACDecOptions complex type: */
class SOAP_CMAC tt__AACDecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AACDecOptions (492)
	virtual int soap_type(void) const { return 492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
	virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__AACDecOptions); }
	         tt__AACDecOptions() { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
	friend tt__AACDecOptions *soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1200 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (493)
/* Type tt__G726DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:G726DecOptions complex type: */
class SOAP_CMAC tt__G726DecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G726DecOptions (493)
	virtual int soap_type(void) const { return 493; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
	virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G726DecOptions); }
	         tt__G726DecOptions() { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
	friend tt__G726DecOptions *soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1203 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (494)
/* Type tt__AudioDecoderConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (494)
	virtual int soap_type(void) const { return 494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptionsExtension); }
	         tt__AudioDecoderConfigurationOptionsExtension() { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
	friend tt__AudioDecoderConfigurationOptionsExtension *soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1206 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (495)
/* Type tt__MulticastConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MulticastConfiguration complex type: */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType
{
public:
	tt__IPAddress *Address;	/* required element of XSD type tt:IPAddress */
	int Port;	/* required element of XSD type xsd:int */
	int TTL;	/* required element of XSD type xsd:int */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MulticastConfiguration (495)
	virtual int soap_type(void) const { return 495; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
	virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MulticastConfiguration); }
	         tt__MulticastConfiguration() { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
	friend tt__MulticastConfiguration *soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1209 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (496)
/* Type tt__StreamSetup is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StreamSetup complex type: */
class SOAP_CMAC tt__StreamSetup : public xsd__anyType
{
public:
	enum tt__StreamType Stream;	/* required element of XSD type tt:StreamType */
	tt__Transport *Transport;	/* required element of XSD type tt:Transport */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamSetup (496)
	virtual int soap_type(void) const { return 496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
	virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW(tt__StreamSetup); }
	         tt__StreamSetup() { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
	friend tt__StreamSetup *soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1212 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (497)
/* Type tt__Transport is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transport complex type: */
class SOAP_CMAC tt__Transport : public xsd__anyType
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of XSD type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of XSD type tt:Transport */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transport (497)
	virtual int soap_type(void) const { return 497; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transport, default initialized and not managed by a soap context
	virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW(tt__Transport); }
	         tt__Transport() { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
	friend tt__Transport *soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1215 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (498)
/* Type tt__MediaUri is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaUri complex type: */
class SOAP_CMAC tt__MediaUri : public xsd__anyType
{
public:
	std::string Uri;	/* required element of XSD type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of XSD type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of XSD type xsd:boolean */
	LONG64 Timeout;	/* external (custom serializer) */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaUri (498)
	virtual int soap_type(void) const { return 498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
	virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW(tt__MediaUri); }
	         tt__MediaUri() { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
	friend tt__MediaUri *soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1218 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (499)
/* Type tt__Scope is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Scope complex type: */
class SOAP_CMAC tt__Scope : public xsd__anyType
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of XSD type tt:ScopeDefinition */
	std::string ScopeItem;	/* required element of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Scope (499)
	virtual int soap_type(void) const { return 499; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Scope, default initialized and not managed by a soap context
	virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW(tt__Scope); }
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
	friend tt__Scope *soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1224 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (501)
/* Type tt__NetworkInterfaceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	std::vector<tt__Dot3Configuration *> Dot3;	/* optional element of XSD type tt:Dot3Configuration */
	std::vector<tt__Dot11Configuration *> Dot11;	/* optional element of XSD type tt:Dot11Configuration */
	tt__NetworkInterfaceExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension (501)
	virtual int soap_type(void) const { return 501; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension); }
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
	friend tt__NetworkInterfaceExtension *soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1227 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (502)
/* Type tt__Dot3Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot3Configuration complex type: */
class SOAP_CMAC tt__Dot3Configuration : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot3Configuration (502)
	virtual int soap_type(void) const { return 502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
	virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot3Configuration); }
	         tt__Dot3Configuration() { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
	friend tt__Dot3Configuration *soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1230 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (503)
/* Type tt__NetworkInterfaceExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension2 (503)
	virtual int soap_type(void) const { return 503; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension2); }
	         tt__NetworkInterfaceExtension2() { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
	friend tt__NetworkInterfaceExtension2 *soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1233 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (504)
/* Type tt__NetworkInterfaceLink is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceLink complex type: */
class SOAP_CMAC tt__NetworkInterfaceLink : public xsd__anyType
{
public:
	tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceLink (504)
	virtual int soap_type(void) const { return 504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceLink); }
	         tt__NetworkInterfaceLink() { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
	friend tt__NetworkInterfaceLink *soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1236 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (505)
/* Type tt__NetworkInterfaceConnectionSetting is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceConnectionSetting complex type: */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting : public xsd__anyType
{
public:
	bool AutoNegotiation;	/* required element of XSD type xsd:boolean */
	int Speed;	/* required element of XSD type xsd:int */
	enum tt__Duplex Duplex;	/* required element of XSD type tt:Duplex */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (505)
	virtual int soap_type(void) const { return 505; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConnectionSetting); }
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
	friend tt__NetworkInterfaceConnectionSetting *soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1239 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (506)
/* Type tt__NetworkInterfaceInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceInfo complex type: */
class SOAP_CMAC tt__NetworkInterfaceInfo : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of XSD type xsd:string */
	std::string HwAddress;	/* required element of XSD type tt:HwAddress */
	int *MTU;	/* optional element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceInfo (506)
	virtual int soap_type(void) const { return 506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceInfo); }
	         tt__NetworkInterfaceInfo() { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
	friend tt__NetworkInterfaceInfo *soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1242 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (507)
/* Type tt__IPv6NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6NetworkInterface complex type: */
class SOAP_CMAC tt__IPv6NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv6Configuration *Config;	/* optional element of XSD type tt:IPv6Configuration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterface (507)
	virtual int soap_type(void) const { return 507; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterface); }
	         tt__IPv6NetworkInterface() { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
	friend tt__IPv6NetworkInterface *soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1245 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (508)
/* Type tt__IPv4NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4NetworkInterface complex type: */
class SOAP_CMAC tt__IPv4NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv4Configuration *Config;	/* required element of XSD type tt:IPv4Configuration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterface (508)
	virtual int soap_type(void) const { return 508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterface); }
	         tt__IPv4NetworkInterface() { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
	friend tt__IPv4NetworkInterface *soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1248 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (509)
/* Type tt__IPv4Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4Configuration complex type: */
class SOAP_CMAC tt__IPv4Configuration : public xsd__anyType
{
public:
	std::vector<tt__PrefixedIPv4Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Configuration (509)
	virtual int soap_type(void) const { return 509; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
	virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Configuration); }
	         tt__IPv4Configuration() { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
	friend tt__IPv4Configuration *soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1251 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (510)
/* Type tt__IPv6Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6Configuration complex type: */
class SOAP_CMAC tt__IPv6Configuration : public xsd__anyType
{
public:
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of XSD type tt:IPv6DHCPConfiguration */
	std::vector<tt__PrefixedIPv6Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> LinkLocal;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> FromDHCP;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> FromRA;	/* optional element of XSD type tt:PrefixedIPv6Address */
	tt__IPv6ConfigurationExtension *Extension;	/* optional element of XSD type tt:IPv6ConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Configuration (510)
	virtual int soap_type(void) const { return 510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
	virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Configuration); }
	         tt__IPv6Configuration() { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
	friend tt__IPv6Configuration *soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1254 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (511)
/* Type tt__IPv6ConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6ConfigurationExtension complex type: */
class SOAP_CMAC tt__IPv6ConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6ConfigurationExtension (511)
	virtual int soap_type(void) const { return 511; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPv6ConfigurationExtension); }
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
	friend tt__IPv6ConfigurationExtension *soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1257 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (512)
/* Type tt__NetworkProtocol is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocol complex type: */
class SOAP_CMAC tt__NetworkProtocol : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of XSD type tt:NetworkProtocolType */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	std::vector<int> Port;	/* required element of XSD type xsd:int */
	tt__NetworkProtocolExtension *Extension;	/* optional element of XSD type tt:NetworkProtocolExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocol (512)
	virtual int soap_type(void) const { return 512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
	virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocol); }
	         tt__NetworkProtocol() { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
	friend tt__NetworkProtocol *soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1260 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (513)
/* Type tt__NetworkProtocolExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocolExtension complex type: */
class SOAP_CMAC tt__NetworkProtocolExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolExtension (513)
	virtual int soap_type(void) const { return 513; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolExtension); }
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
	friend tt__NetworkProtocolExtension *soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1263 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (514)
/* Type tt__NetworkHost is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHost complex type: */
class SOAP_CMAC tt__NetworkHost : public xsd__anyType
{
public:
	enum tt__NetworkHostType Type;	/* required element of XSD type tt:NetworkHostType */
	std::string *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	std::string *DNSname;	/* optional element of XSD type tt:DNSName */
	tt__NetworkHostExtension *Extension;	/* optional element of XSD type tt:NetworkHostExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHost (514)
	virtual int soap_type(void) const { return 514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
	virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHost); }
	         tt__NetworkHost() { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
	friend tt__NetworkHost *soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1266 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (515)
/* Type tt__NetworkHostExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHostExtension complex type: */
class SOAP_CMAC tt__NetworkHostExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostExtension (515)
	virtual int soap_type(void) const { return 515; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
	virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostExtension); }
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
	friend tt__NetworkHostExtension *soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1269 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (516)
/* Type tt__IPAddress is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddress complex type: */
class SOAP_CMAC tt__IPAddress : public xsd__anyType
{
public:
	enum tt__IPType Type;	/* required element of XSD type tt:IPType */
	std::string *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddress (516)
	virtual int soap_type(void) const { return 516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
	virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW(tt__IPAddress); }
	         tt__IPAddress() { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
	friend tt__IPAddress *soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1272 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (517)
/* Type tt__PrefixedIPv4Address is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PrefixedIPv4Address complex type: */
class SOAP_CMAC tt__PrefixedIPv4Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of XSD type tt:IPv4Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv4Address (517)
	virtual int soap_type(void) const { return 517; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv4Address); }
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
	friend tt__PrefixedIPv4Address *soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1275 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (518)
/* Type tt__PrefixedIPv6Address is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PrefixedIPv6Address complex type: */
class SOAP_CMAC tt__PrefixedIPv6Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of XSD type tt:IPv6Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv6Address (518)
	virtual int soap_type(void) const { return 518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv6Address); }
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
	friend tt__PrefixedIPv6Address *soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1278 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (519)
/* Type tt__HostnameInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HostnameInformation complex type: */
class SOAP_CMAC tt__HostnameInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::string *Name;	/* optional element of XSD type xsd:token */
	tt__HostnameInformationExtension *Extension;	/* optional element of XSD type tt:HostnameInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformation (519)
	virtual int soap_type(void) const { return 519; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
	virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformation); }
	         tt__HostnameInformation() { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
	friend tt__HostnameInformation *soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1281 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (520)
/* Type tt__HostnameInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HostnameInformationExtension complex type: */
class SOAP_CMAC tt__HostnameInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformationExtension (520)
	virtual int soap_type(void) const { return 520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
	virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformationExtension); }
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
	friend tt__HostnameInformationExtension *soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1284 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (521)
/* Type tt__DNSInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSInformation complex type: */
class SOAP_CMAC tt__DNSInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> SearchDomain;	/* optional element of XSD type xsd:token */
	std::vector<tt__IPAddress *> DNSFromDHCP;	/* optional element of XSD type tt:IPAddress */
	std::vector<tt__IPAddress *> DNSManual;	/* optional element of XSD type tt:IPAddress */
	tt__DNSInformationExtension *Extension;	/* optional element of XSD type tt:DNSInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformation (521)
	virtual int soap_type(void) const { return 521; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
	virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformation); }
	         tt__DNSInformation() { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
	friend tt__DNSInformation *soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1287 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (522)
/* Type tt__DNSInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSInformationExtension complex type: */
class SOAP_CMAC tt__DNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformationExtension (522)
	virtual int soap_type(void) const { return 522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformationExtension); }
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
	friend tt__DNSInformationExtension *soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1290 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (523)
/* Type tt__NTPInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NTPInformation complex type: */
class SOAP_CMAC tt__NTPInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<tt__NetworkHost *> NTPFromDHCP;	/* optional element of XSD type tt:NetworkHost */
	std::vector<tt__NetworkHost *> NTPManual;	/* optional element of XSD type tt:NetworkHost */
	tt__NTPInformationExtension *Extension;	/* optional element of XSD type tt:NTPInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformation (523)
	virtual int soap_type(void) const { return 523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
	virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformation); }
	         tt__NTPInformation() { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
	friend tt__NTPInformation *soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1293 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (524)
/* Type tt__NTPInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NTPInformationExtension complex type: */
class SOAP_CMAC tt__NTPInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformationExtension (524)
	virtual int soap_type(void) const { return 524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
	virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformationExtension); }
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
	friend tt__NTPInformationExtension *soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1296 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (525)
/* Type tt__DynamicDNSInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSInformation complex type: */
class SOAP_CMAC tt__DynamicDNSInformation : public xsd__anyType
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	std::string *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	tt__DynamicDNSInformationExtension *Extension;	/* optional element of XSD type tt:DynamicDNSInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformation (525)
	virtual int soap_type(void) const { return 525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformation); }
	         tt__DynamicDNSInformation() { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
	friend tt__DynamicDNSInformation *soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1299 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (526)
/* Type tt__DynamicDNSInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSInformationExtension complex type: */
class SOAP_CMAC tt__DynamicDNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformationExtension (526)
	virtual int soap_type(void) const { return 526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformationExtension); }
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
	friend tt__DynamicDNSInformationExtension *soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1302 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (527)
/* Type tt__NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of XSD type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of XSD type xsd:int */
	tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterfaceSetConfiguration */
	tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterfaceSetConfiguration */
	tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfiguration); }
	         tt__NetworkInterfaceSetConfiguration() { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
	friend tt__NetworkInterfaceSetConfiguration *soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1305 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (528)
/* Type tt__NetworkInterfaceSetConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	std::vector<tt__Dot3Configuration *> Dot3;	/* optional element of XSD type tt:Dot3Configuration */
	std::vector<tt__Dot11Configuration *> Dot11;	/* optional element of XSD type tt:Dot11Configuration */
	tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (528)
	virtual int soap_type(void) const { return 528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension); }
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
	friend tt__NetworkInterfaceSetConfigurationExtension *soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1308 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (529)
/* Type tt__IPv6NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__PrefixedIPv6Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv6Address */
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of XSD type tt:IPv6DHCPConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (529)
	virtual int soap_type(void) const { return 529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration); }
	         tt__IPv6NetworkInterfaceSetConfiguration() { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
	friend tt__IPv6NetworkInterfaceSetConfiguration *soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1311 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (530)
/* Type tt__IPv4NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__PrefixedIPv4Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (530)
	virtual int soap_type(void) const { return 530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration); }
	         tt__IPv4NetworkInterfaceSetConfiguration() { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
	friend tt__IPv4NetworkInterfaceSetConfiguration *soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1314 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (531)
/* Type tt__NetworkGateway is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkGateway complex type: */
class SOAP_CMAC tt__NetworkGateway : public xsd__anyType
{
public:
	std::vector<std::string> IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::vector<std::string> IPv6Address;	/* optional element of XSD type tt:IPv6Address */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkGateway (531)
	virtual int soap_type(void) const { return 531; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
	virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW(tt__NetworkGateway); }
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
	friend tt__NetworkGateway *soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1317 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (532)
/* Type tt__NetworkZeroConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfiguration complex type: */
class SOAP_CMAC tt__NetworkZeroConfiguration : public xsd__anyType
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> Addresses;	/* optional element of XSD type tt:IPv4Address */
	tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfiguration (532)
	virtual int soap_type(void) const { return 532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfiguration); }
	         tt__NetworkZeroConfiguration() { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
	friend tt__NetworkZeroConfiguration *soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1320 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (533)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	std::vector<tt__NetworkZeroConfiguration *> Additional;	/* optional element of XSD type tt:NetworkZeroConfiguration */
	tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension (533)
	virtual int soap_type(void) const { return 533; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension); }
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
	friend tt__NetworkZeroConfigurationExtension *soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1323 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (534)
/* Type tt__NetworkZeroConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension2); }
	         tt__NetworkZeroConfigurationExtension2() { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
	friend tt__NetworkZeroConfigurationExtension2 *soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1326 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (535)
/* Type tt__IPAddressFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilter complex type: */
class SOAP_CMAC tt__IPAddressFilter : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of XSD type tt:IPAddressFilterType */
	std::vector<tt__PrefixedIPv4Address *> IPv4Address;	/* optional element of XSD type tt:PrefixedIPv4Address */
	std::vector<tt__PrefixedIPv6Address *> IPv6Address;	/* optional element of XSD type tt:PrefixedIPv6Address */
	tt__IPAddressFilterExtension *Extension;	/* optional element of XSD type tt:IPAddressFilterExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilter (535)
	virtual int soap_type(void) const { return 535; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
	virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilter); }
	         tt__IPAddressFilter() { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
	friend tt__IPAddressFilter *soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1329 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (536)
/* Type tt__IPAddressFilterExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilterExtension complex type: */
class SOAP_CMAC tt__IPAddressFilterExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterExtension (536)
	virtual int soap_type(void) const { return 536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterExtension); }
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
	friend tt__IPAddressFilterExtension *soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1332 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (537)
/* Type tt__Dot11Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Configuration complex type: */
class SOAP_CMAC tt__Dot11Configuration : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of XSD type tt:Dot11StationMode */
	std::string Alias;	/* required element of XSD type tt:Name */
	std::string Priority;	/* required element of XSD type tt:NetworkInterfaceConfigPriority */
	tt__Dot11SecurityConfiguration *Security;	/* required element of XSD type tt:Dot11SecurityConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Configuration (537)
	virtual int soap_type(void) const { return 537; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
	virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Configuration); }
	         tt__Dot11Configuration() { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
	friend tt__Dot11Configuration *soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1335 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (538)
/* Type tt__Dot11SecurityConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityConfiguration complex type: */
class SOAP_CMAC tt__Dot11SecurityConfiguration : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of XSD type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of XSD type tt:Dot11Cipher */
	tt__Dot11PSKSet *PSK;	/* optional element of XSD type tt:Dot11PSKSet */
	std::string *Dot1X;	/* optional element of XSD type tt:ReferenceToken */
	tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot11SecurityConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfiguration (538)
	virtual int soap_type(void) const { return 538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfiguration); }
	         tt__Dot11SecurityConfiguration() { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
	friend tt__Dot11SecurityConfiguration *soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1338 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (539)
/* Type tt__Dot11SecurityConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (539)
	virtual int soap_type(void) const { return 539; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfigurationExtension); }
	         tt__Dot11SecurityConfigurationExtension() { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
	friend tt__Dot11SecurityConfigurationExtension *soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1341 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (540)
/* Type tt__Dot11PSKSet is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKSet complex type: */
class SOAP_CMAC tt__Dot11PSKSet : public xsd__anyType
{
public:
	xsd__hexBinary *Key;	/* optional element of XSD type tt:Dot11PSK */
	std::string *Passphrase;	/* optional element of XSD type tt:Dot11PSKPassphrase */
	tt__Dot11PSKSetExtension *Extension;	/* optional element of XSD type tt:Dot11PSKSetExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSet (540)
	virtual int soap_type(void) const { return 540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSet); }
	         tt__Dot11PSKSet() { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
	friend tt__Dot11PSKSet *soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1344 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (541)
/* Type tt__Dot11PSKSetExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKSetExtension complex type: */
class SOAP_CMAC tt__Dot11PSKSetExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSetExtension (541)
	virtual int soap_type(void) const { return 541; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSetExtension); }
	         tt__Dot11PSKSetExtension() { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
	friend tt__Dot11PSKSetExtension *soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1347 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (542)
/* Type tt__NetworkInterfaceSetConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (542)
	virtual int soap_type(void) const { return 542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension2); }
	         tt__NetworkInterfaceSetConfigurationExtension2() { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
	friend tt__NetworkInterfaceSetConfigurationExtension2 *soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1350 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (543)
/* Type tt__Dot11Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Capabilities complex type: */
class SOAP_CMAC tt__Dot11Capabilities : public xsd__anyType
{
public:
	bool TKIP;	/* required element of XSD type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of XSD type xsd:boolean */
	bool MultipleConfiguration;	/* required element of XSD type xsd:boolean */
	bool AdHocStationMode;	/* required element of XSD type xsd:boolean */
	bool WEP;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Capabilities (543)
	virtual int soap_type(void) const { return 543; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
	virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Capabilities); }
	         tt__Dot11Capabilities() { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
	friend tt__Dot11Capabilities *soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1353 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (544)
/* Type tt__Dot11Status is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Status complex type: */
class SOAP_CMAC tt__Dot11Status : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of XSD type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	std::string ActiveConfigAlias;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Status (544)
	virtual int soap_type(void) const { return 544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
	virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Status); }
	         tt__Dot11Status() { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
	friend tt__Dot11Status *soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1356 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (545)
/* Type tt__Dot11AvailableNetworks is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AvailableNetworks complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworks : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of XSD type xsd:string */
	std::vector<enum tt__Dot11AuthAndMangementSuite> AuthAndMangementSuite;	/* optional element of XSD type tt:Dot11AuthAndMangementSuite */
	std::vector<enum tt__Dot11Cipher> PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	std::vector<enum tt__Dot11Cipher> GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of XSD type tt:Dot11AvailableNetworksExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworks (545)
	virtual int soap_type(void) const { return 545; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworks); }
	         tt__Dot11AvailableNetworks() { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
	friend tt__Dot11AvailableNetworks *soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1359 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (546)
/* Type tt__Dot11AvailableNetworksExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AvailableNetworksExtension complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworksExtension (546)
	virtual int soap_type(void) const { return 546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworksExtension); }
	         tt__Dot11AvailableNetworksExtension() { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
	friend tt__Dot11AvailableNetworksExtension *soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1362 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (547)
/* Type tt__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Capabilities complex type: */
class SOAP_CMAC tt__Capabilities : public xsd__anyType
{
public:
	tt__AnalyticsCapabilities *Analytics;	/* optional element of XSD type tt:AnalyticsCapabilities */
	tt__DeviceCapabilities *Device;	/* optional element of XSD type tt:DeviceCapabilities */
	tt__EventCapabilities *Events;	/* optional element of XSD type tt:EventCapabilities */
	tt__ImagingCapabilities *Imaging;	/* optional element of XSD type tt:ImagingCapabilities */
	tt__MediaCapabilities *Media;	/* optional element of XSD type tt:MediaCapabilities */
	tt__PTZCapabilities *PTZ;	/* optional element of XSD type tt:PTZCapabilities */
	tt__CapabilitiesExtension *Extension;	/* optional element of XSD type tt:CapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Capabilities (547)
	virtual int soap_type(void) const { return 547; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
	virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Capabilities); }
	         tt__Capabilities() { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
	friend tt__Capabilities *soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1365 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (548)
/* Type tt__CapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilitiesExtension complex type: */
class SOAP_CMAC tt__CapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__DeviceIOCapabilities *DeviceIO;	/* optional element of XSD type tt:DeviceIOCapabilities */
	tt__DisplayCapabilities *Display;	/* optional element of XSD type tt:DisplayCapabilities */
	tt__RecordingCapabilities *Recording;	/* optional element of XSD type tt:RecordingCapabilities */
	tt__SearchCapabilities *Search;	/* optional element of XSD type tt:SearchCapabilities */
	tt__ReplayCapabilities *Replay;	/* optional element of XSD type tt:ReplayCapabilities */
	tt__ReceiverCapabilities *Receiver;	/* optional element of XSD type tt:ReceiverCapabilities */
	tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of XSD type tt:AnalyticsDeviceCapabilities */
	tt__CapabilitiesExtension2 *Extensions;	/* optional element of XSD type tt:CapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension (548)
	virtual int soap_type(void) const { return 548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension); }
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
	friend tt__CapabilitiesExtension *soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1368 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (549)
/* Type tt__CapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__CapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension2 (549)
	virtual int soap_type(void) const { return 549; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension2); }
	         tt__CapabilitiesExtension2() { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
	friend tt__CapabilitiesExtension2 *soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1371 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (550)
/* Type tt__AnalyticsCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool RuleSupport;	/* required element of XSD type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsCapabilities (550)
	virtual int soap_type(void) const { return 550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsCapabilities); }
	         tt__AnalyticsCapabilities() { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
	friend tt__AnalyticsCapabilities *soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1374 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (551)
/* Type tt__DeviceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceCapabilities complex type: */
class SOAP_CMAC tt__DeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	tt__NetworkCapabilities *Network;	/* optional element of XSD type tt:NetworkCapabilities */
	tt__SystemCapabilities *System;	/* optional element of XSD type tt:SystemCapabilities */
	tt__IOCapabilities *IO;	/* optional element of XSD type tt:IOCapabilities */
	tt__SecurityCapabilities *Security;	/* optional element of XSD type tt:SecurityCapabilities */
	tt__DeviceCapabilitiesExtension *Extension;	/* optional element of XSD type tt:DeviceCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilities (551)
	virtual int soap_type(void) const { return 551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilities); }
	         tt__DeviceCapabilities() { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
	friend tt__DeviceCapabilities *soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1377 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (552)
/* Type tt__DeviceCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceCapabilitiesExtension complex type: */
class SOAP_CMAC tt__DeviceCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilitiesExtension (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilitiesExtension); }
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
	friend tt__DeviceCapabilitiesExtension *soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1380 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (553)
/* Type tt__EventCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventCapabilities complex type: */
class SOAP_CMAC tt__EventCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of XSD type xsd:boolean */
	bool WSPullPointSupport;	/* required element of XSD type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventCapabilities (553)
	virtual int soap_type(void) const { return 553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
	virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__EventCapabilities); }
	         tt__EventCapabilities() { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
	friend tt__EventCapabilities *soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1383 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (554)
/* Type tt__IOCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilities complex type: */
class SOAP_CMAC tt__IOCapabilities : public xsd__anyType
{
public:
	int *InputConnectors;	/* optional element of XSD type xsd:int */
	int *RelayOutputs;	/* optional element of XSD type xsd:int */
	tt__IOCapabilitiesExtension *Extension;	/* optional element of XSD type tt:IOCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilities (554)
	virtual int soap_type(void) const { return 554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
	virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilities); }
	         tt__IOCapabilities() { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
	friend tt__IOCapabilities *soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1386 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (555)
/* Type tt__IOCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilitiesExtension complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *Auxiliary;	/* optional element of XSD type xsd:boolean */
	std::vector<std::string> AuxiliaryCommands;	/* optional element of XSD type tt:AuxiliaryData */
	tt__IOCapabilitiesExtension2 *Extension;	/* required element of XSD type tt:IOCapabilitiesExtension2 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension (555)
	virtual int soap_type(void) const { return 555; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension); }
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
	friend tt__IOCapabilitiesExtension *soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1389 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (556)
/* Type tt__IOCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension2 (556)
	virtual int soap_type(void) const { return 556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension2); }
	         tt__IOCapabilitiesExtension2() { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
	friend tt__IOCapabilitiesExtension2 *soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1392 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (557)
/* Type tt__MediaCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaCapabilities complex type: */
class SOAP_CMAC tt__MediaCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of XSD type tt:RealTimeStreamingCapabilities */
	std::vector<char *> __any;
	tt__MediaCapabilitiesExtension *Extension;	/* optional element of XSD type tt:MediaCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilities (557)
	virtual int soap_type(void) const { return 557; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
	virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilities); }
	         tt__MediaCapabilities() { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
	friend tt__MediaCapabilities *soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1395 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (558)
/* Type tt__MediaCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaCapabilitiesExtension complex type: */
class SOAP_CMAC tt__MediaCapabilitiesExtension : public xsd__anyType
{
public:
	tt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type tt:ProfileCapabilities */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilitiesExtension (558)
	virtual int soap_type(void) const { return 558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilitiesExtension); }
	         tt__MediaCapabilitiesExtension() { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
	friend tt__MediaCapabilitiesExtension *soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1398 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (559)
/* Type tt__RealTimeStreamingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RealTimeStreamingCapabilities complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilities : public xsd__anyType
{
public:
	bool *RTPMulticast;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of XSD type tt:RealTimeStreamingCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilities (559)
	virtual int soap_type(void) const { return 559; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilities); }
	         tt__RealTimeStreamingCapabilities() { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
	friend tt__RealTimeStreamingCapabilities *soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1401 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (560)
/* Type tt__RealTimeStreamingCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RealTimeStreamingCapabilitiesExtension complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (560)
	virtual int soap_type(void) const { return 560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension); }
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
	friend tt__RealTimeStreamingCapabilitiesExtension *soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1404 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (561)
/* Type tt__ProfileCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileCapabilities complex type: */
class SOAP_CMAC tt__ProfileCapabilities : public xsd__anyType
{
public:
	int MaximumNumberOfProfiles;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileCapabilities (561)
	virtual int soap_type(void) const { return 561; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ProfileCapabilities); }
	         tt__ProfileCapabilities() { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
	friend tt__ProfileCapabilities *soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1407 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (562)
/* Type tt__NetworkCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilities complex type: */
class SOAP_CMAC tt__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional element of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional element of XSD type xsd:boolean */
	bool *DynDNS;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilities (562)
	virtual int soap_type(void) const { return 562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilities); }
	         tt__NetworkCapabilities() { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
	friend tt__NetworkCapabilities *soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1410 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (563)
/* Type tt__NetworkCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilitiesExtension complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *Dot11Configuration;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension (563)
	virtual int soap_type(void) const { return 563; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension); }
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
	friend tt__NetworkCapabilitiesExtension *soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1413 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (564)
/* Type tt__NetworkCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (564)
	virtual int soap_type(void) const { return 564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension2); }
	         tt__NetworkCapabilitiesExtension2() { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
	friend tt__NetworkCapabilitiesExtension2 *soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1416 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (565)
/* Type tt__SecurityCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilities complex type: */
class SOAP_CMAC tt__SecurityCapabilities : public xsd__anyType
{
public:
	bool TLS1_x002e1;	/* required element of XSD type xsd:boolean */
	bool TLS1_x002e2;	/* required element of XSD type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of XSD type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of XSD type xsd:boolean */
	bool X_x002e509Token;	/* required element of XSD type xsd:boolean */
	bool SAMLToken;	/* required element of XSD type xsd:boolean */
	bool KerberosToken;	/* required element of XSD type xsd:boolean */
	bool RELToken;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	tt__SecurityCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilities (565)
	virtual int soap_type(void) const { return 565; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilities); }
	         tt__SecurityCapabilities() { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
	friend tt__SecurityCapabilities *soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1419 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (566)
/* Type tt__SecurityCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension : public xsd__anyType
{
public:
	bool TLS1_x002e0;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension (566)
	virtual int soap_type(void) const { return 566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension); }
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
	friend tt__SecurityCapabilitiesExtension *soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1422 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (567)
/* Type tt__SecurityCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2 : public xsd__anyType
{
public:
	bool Dot1X;	/* required element of XSD type xsd:boolean */
	std::vector<int> SupportedEAPMethod;	/* optional element of XSD type xsd:int */
	bool RemoteUserHandling;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (567)
	virtual int soap_type(void) const { return 567; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension2); }
	         tt__SecurityCapabilitiesExtension2() { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
	friend tt__SecurityCapabilitiesExtension2 *soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1425 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (568)
/* Type tt__SystemCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilities complex type: */
class SOAP_CMAC tt__SystemCapabilities : public xsd__anyType
{
public:
	bool DiscoveryResolve;	/* required element of XSD type xsd:boolean */
	bool DiscoveryBye;	/* required element of XSD type xsd:boolean */
	bool RemoteDiscovery;	/* required element of XSD type xsd:boolean */
	bool SystemBackup;	/* required element of XSD type xsd:boolean */
	bool SystemLogging;	/* required element of XSD type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of XSD type xsd:boolean */
	std::vector<tt__OnvifVersion *> SupportedVersions;	/* required element of XSD type tt:OnvifVersion */
	tt__SystemCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilities (568)
	virtual int soap_type(void) const { return 568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
	virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilities); }
	         tt__SystemCapabilities() { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
	friend tt__SystemCapabilities *soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1428 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (569)
/* Type tt__SystemCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *HttpFirmwareUpgrade;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of XSD type xsd:boolean */
	tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension (569)
	virtual int soap_type(void) const { return 569; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension); }
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
	friend tt__SystemCapabilitiesExtension *soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1431 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (570)
/* Type tt__SystemCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension2 (570)
	virtual int soap_type(void) const { return 570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension2); }
	         tt__SystemCapabilitiesExtension2() { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
	friend tt__SystemCapabilitiesExtension2 *soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1434 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (571)
/* Type tt__OnvifVersion is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OnvifVersion complex type: */
class SOAP_CMAC tt__OnvifVersion : public xsd__anyType
{
public:
	int Major;	/* required element of XSD type xsd:int */
	int Minor;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OnvifVersion (571)
	virtual int soap_type(void) const { return 571; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
	virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW(tt__OnvifVersion); }
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
	friend tt__OnvifVersion *soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1437 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (572)
/* Type tt__ImagingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingCapabilities complex type: */
class SOAP_CMAC tt__ImagingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingCapabilities (572)
	virtual int soap_type(void) const { return 572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
	virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ImagingCapabilities); }
	         tt__ImagingCapabilities() { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
	friend tt__ImagingCapabilities *soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1440 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (573)
/* Type tt__PTZCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZCapabilities complex type: */
class SOAP_CMAC tt__PTZCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZCapabilities (573)
	virtual int soap_type(void) const { return 573; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
	virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__PTZCapabilities); }
	         tt__PTZCapabilities() { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
	friend tt__PTZCapabilities *soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1443 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (574)
/* Type tt__DeviceIOCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceIOCapabilities complex type: */
class SOAP_CMAC tt__DeviceIOCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	int VideoSources;	/* required element of XSD type xsd:int */
	int VideoOutputs;	/* required element of XSD type xsd:int */
	int AudioSources;	/* required element of XSD type xsd:int */
	int AudioOutputs;	/* required element of XSD type xsd:int */
	int RelayOutputs;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceIOCapabilities (574)
	virtual int soap_type(void) const { return 574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceIOCapabilities); }
	         tt__DeviceIOCapabilities() { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
	friend tt__DeviceIOCapabilities *soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1446 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (575)
/* Type tt__DisplayCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DisplayCapabilities complex type: */
class SOAP_CMAC tt__DisplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool FixedLayout;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DisplayCapabilities (575)
	virtual int soap_type(void) const { return 575; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
	virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DisplayCapabilities); }
	         tt__DisplayCapabilities() { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
	friend tt__DisplayCapabilities *soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1449 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (576)
/* Type tt__RecordingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingCapabilities complex type: */
class SOAP_CMAC tt__RecordingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool ReceiverSource;	/* required element of XSD type xsd:boolean */
	bool MediaProfileSource;	/* required element of XSD type xsd:boolean */
	bool DynamicRecordings;	/* required element of XSD type xsd:boolean */
	bool DynamicTracks;	/* required element of XSD type xsd:boolean */
	int MaxStringLength;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingCapabilities (576)
	virtual int soap_type(void) const { return 576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
	virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RecordingCapabilities); }
	         tt__RecordingCapabilities() { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
	friend tt__RecordingCapabilities *soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1452 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (577)
/* Type tt__SearchCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchCapabilities complex type: */
class SOAP_CMAC tt__SearchCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool MetadataSearch;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchCapabilities (577)
	virtual int soap_type(void) const { return 577; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
	virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SearchCapabilities); }
	         tt__SearchCapabilities() { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
	friend tt__SearchCapabilities *soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1455 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (578)
/* Type tt__ReplayCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReplayCapabilities complex type: */
class SOAP_CMAC tt__ReplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayCapabilities (578)
	virtual int soap_type(void) const { return 578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
	virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReplayCapabilities); }
	         tt__ReplayCapabilities() { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
	friend tt__ReplayCapabilities *soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1458 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (579)
/* Type tt__ReceiverCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverCapabilities complex type: */
class SOAP_CMAC tt__ReceiverCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of XSD type xsd:boolean */
	int SupportedReceivers;	/* required element of XSD type xsd:int */
	int MaximumRTSPURILength;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverCapabilities (579)
	virtual int soap_type(void) const { return 579; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
	virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverCapabilities); }
	         tt__ReceiverCapabilities() { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
	friend tt__ReceiverCapabilities *soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1461 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (580)
/* Type tt__AnalyticsDeviceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool *RuleSupport;	/* optional element of XSD type xsd:boolean */
	tt__AnalyticsDeviceExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceCapabilities (580)
	virtual int soap_type(void) const { return 580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceCapabilities); }
	         tt__AnalyticsDeviceCapabilities() { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
	friend tt__AnalyticsDeviceCapabilities *soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1464 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (581)
/* Type tt__AnalyticsDeviceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceExtension (581)
	virtual int soap_type(void) const { return 581; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceExtension); }
	         tt__AnalyticsDeviceExtension() { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
	friend tt__AnalyticsDeviceExtension *soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1467 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (582)
/* Type tt__SystemLog is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLog complex type: */
class SOAP_CMAC tt__SystemLog : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	std::string *String;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLog (582)
	virtual int soap_type(void) const { return 582; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
	virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW(tt__SystemLog); }
	         tt__SystemLog() { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
	friend tt__SystemLog *soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1470 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (583)
/* Type tt__SupportInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportInformation complex type: */
class SOAP_CMAC tt__SupportInformation : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	std::string *String;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportInformation (583)
	virtual int soap_type(void) const { return 583; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
	virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW(tt__SupportInformation); }
	         tt__SupportInformation() { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
	friend tt__SupportInformation *soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1473 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (584)
/* Type tt__BinaryData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BinaryData complex type: */
class SOAP_CMAC tt__BinaryData : public xsd__anyType
{
public:
	xsd__base64Binary Data;	/* required element of XSD type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BinaryData (584)
	virtual int soap_type(void) const { return 584; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
	virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW(tt__BinaryData); }
	         tt__BinaryData() { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
	friend tt__BinaryData *soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1476 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (585)
/* Type tt__AttachmentData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AttachmentData complex type: */
class SOAP_CMAC tt__AttachmentData : public xsd__anyType
{
public:
	struct _xop__Include xop__Include;	/* required element of XSD type xop:Include */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AttachmentData (585)
	virtual int soap_type(void) const { return 585; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
	virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW(tt__AttachmentData); }
	         tt__AttachmentData() { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
	friend tt__AttachmentData *soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1479 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (586)
/* Type tt__BackupFile is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BackupFile complex type: */
class SOAP_CMAC tt__BackupFile : public xsd__anyType
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	tt__AttachmentData *Data;	/* required element of XSD type tt:AttachmentData */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BackupFile (586)
	virtual int soap_type(void) const { return 586; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
	virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW(tt__BackupFile); }
	         tt__BackupFile() { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
	friend tt__BackupFile *soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1482 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (587)
/* Type tt__SystemLogUriList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogUriList complex type: */
class SOAP_CMAC tt__SystemLogUriList : public xsd__anyType
{
public:
	std::vector<tt__SystemLogUri *> SystemLog;	/* optional element of XSD type tt:SystemLogUri */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUriList (587)
	virtual int soap_type(void) const { return 587; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
	virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUriList); }
	         tt__SystemLogUriList() { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
	friend tt__SystemLogUriList *soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1485 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (588)
/* Type tt__SystemLogUri is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogUri complex type: */
class SOAP_CMAC tt__SystemLogUri : public xsd__anyType
{
public:
	enum tt__SystemLogType Type;	/* required element of XSD type tt:SystemLogType */
	std::string Uri;	/* required element of XSD type xsd:anyURI */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUri (588)
	virtual int soap_type(void) const { return 588; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
	virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUri); }
	         tt__SystemLogUri() { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
	friend tt__SystemLogUri *soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1488 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (589)
/* Type tt__SystemDateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemDateTime complex type: */
class SOAP_CMAC tt__SystemDateTime : public xsd__anyType
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of XSD type tt:DateTime */
	tt__SystemDateTimeExtension *Extension;	/* optional element of XSD type tt:SystemDateTimeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTime (589)
	virtual int soap_type(void) const { return 589; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
	virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTime); }
	         tt__SystemDateTime() { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
	friend tt__SystemDateTime *soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1491 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (590)
/* Type tt__SystemDateTimeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemDateTimeExtension complex type: */
class SOAP_CMAC tt__SystemDateTimeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTimeExtension (590)
	virtual int soap_type(void) const { return 590; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
	virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTimeExtension); }
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
	friend tt__SystemDateTimeExtension *soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1494 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (591)
/* Type tt__DateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DateTime complex type: */
class SOAP_CMAC tt__DateTime : public xsd__anyType
{
public:
	tt__Time *Time;	/* required element of XSD type tt:Time */
	tt__Date *Date;	/* required element of XSD type tt:Date */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTime (591)
	virtual int soap_type(void) const { return 591; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
	virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW(tt__DateTime); }
	         tt__DateTime() { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
	friend tt__DateTime *soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1497 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (592)
/* Type tt__Date is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Date complex type: */
class SOAP_CMAC tt__Date : public xsd__anyType
{
public:
	int Year;	/* required element of XSD type xsd:int */
	int Month;	/* required element of XSD type xsd:int */
	int Day;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Date (592)
	virtual int soap_type(void) const { return 592; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Date, default initialized and not managed by a soap context
	virtual tt__Date *soap_alloc(void) const { return SOAP_NEW(tt__Date); }
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
	friend tt__Date *soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1500 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (593)
/* Type tt__Time is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Time complex type: */
class SOAP_CMAC tt__Time : public xsd__anyType
{
public:
	int Hour;	/* required element of XSD type xsd:int */
	int Minute;	/* required element of XSD type xsd:int */
	int Second;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Time (593)
	virtual int soap_type(void) const { return 593; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Time, default initialized and not managed by a soap context
	virtual tt__Time *soap_alloc(void) const { return SOAP_NEW(tt__Time); }
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
	friend tt__Time *soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1503 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (594)
/* Type tt__TimeZone is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TimeZone complex type: */
class SOAP_CMAC tt__TimeZone : public xsd__anyType
{
public:
	std::string TZ;	/* required element of XSD type xsd:token */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TimeZone (594)
	virtual int soap_type(void) const { return 594; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
	virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW(tt__TimeZone); }
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
	friend tt__TimeZone *soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1506 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (595)
/* Type tt__RemoteUser is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RemoteUser complex type: */
class SOAP_CMAC tt__RemoteUser : public xsd__anyType
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	bool UseDerivedPassword;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RemoteUser (595)
	virtual int soap_type(void) const { return 595; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
	virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW(tt__RemoteUser); }
	         tt__RemoteUser() { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
	friend tt__RemoteUser *soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1509 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (596)
/* Type tt__User is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:User complex type: */
class SOAP_CMAC tt__User : public xsd__anyType
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of XSD type tt:UserLevel */
	tt__UserExtension *Extension;	/* optional element of XSD type tt:UserExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__User (596)
	virtual int soap_type(void) const { return 596; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__User, default initialized and not managed by a soap context
	virtual tt__User *soap_alloc(void) const { return SOAP_NEW(tt__User); }
	         tt__User() { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
	friend tt__User *soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1512 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (597)
/* Type tt__UserExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:UserExtension complex type: */
class SOAP_CMAC tt__UserExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserExtension (597)
	virtual int soap_type(void) const { return 597; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
	virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW(tt__UserExtension); }
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
	friend tt__UserExtension *soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1515 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (598)
/* Type tt__CertificateGenerationParameters is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateGenerationParameters complex type: */
class SOAP_CMAC tt__CertificateGenerationParameters : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	std::string *ValidNotBefore;	/* optional element of XSD type xsd:token */
	std::string *ValidNotAfter;	/* optional element of XSD type xsd:token */
	tt__CertificateGenerationParametersExtension *Extension;	/* optional element of XSD type tt:CertificateGenerationParametersExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParameters (598)
	virtual int soap_type(void) const { return 598; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParameters, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParameters); }
	         tt__CertificateGenerationParameters() { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
	friend tt__CertificateGenerationParameters *soap_instantiate_tt__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1518 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (599)
/* Type tt__CertificateGenerationParametersExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateGenerationParametersExtension complex type: */
class SOAP_CMAC tt__CertificateGenerationParametersExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParametersExtension (599)
	virtual int soap_type(void) const { return 599; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParametersExtension); }
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
	friend tt__CertificateGenerationParametersExtension *soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1521 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (600)
/* Type tt__Certificate is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Certificate complex type: */
class SOAP_CMAC tt__Certificate : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Certificate (600)
	virtual int soap_type(void) const { return 600; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
	virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW(tt__Certificate); }
	         tt__Certificate() { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
	friend tt__Certificate *soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1524 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (601)
/* Type tt__CertificateStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateStatus complex type: */
class SOAP_CMAC tt__CertificateStatus : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	bool Status;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateStatus (601)
	virtual int soap_type(void) const { return 601; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
	virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW(tt__CertificateStatus); }
	         tt__CertificateStatus() { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
	friend tt__CertificateStatus *soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1527 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (602)
/* Type tt__CertificateWithPrivateKey is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateWithPrivateKey complex type: */
class SOAP_CMAC tt__CertificateWithPrivateKey : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of XSD type tt:BinaryData */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateWithPrivateKey (602)
	virtual int soap_type(void) const { return 602; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(tt__CertificateWithPrivateKey); }
	         tt__CertificateWithPrivateKey() { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
	friend tt__CertificateWithPrivateKey *soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1530 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (603)
/* Type tt__CertificateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateInformation complex type: */
class SOAP_CMAC tt__CertificateInformation : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	std::string *IssuerDN;	/* optional element of XSD type xsd:string */
	std::string *SubjectDN;	/* optional element of XSD type xsd:string */
	tt__CertificateUsage *KeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	int *KeyLength;	/* optional element of XSD type xsd:int */
	std::string *Version;	/* optional element of XSD type xsd:string */
	std::string *SerialNum;	/* optional element of XSD type xsd:string */
	std::string *SignatureAlgorithm;	/* optional element of XSD type xsd:string */
	tt__DateTimeRange *Validity;	/* optional element of XSD type tt:DateTimeRange */
	tt__CertificateInformationExtension *Extension;	/* optional element of XSD type tt:CertificateInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformation (603)
	virtual int soap_type(void) const { return 603; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
	virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformation); }
	         tt__CertificateInformation() { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
	friend tt__CertificateInformation *soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1536 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (605)
/* Type tt__CertificateInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateInformationExtension complex type: */
class SOAP_CMAC tt__CertificateInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformationExtension (605)
	virtual int soap_type(void) const { return 605; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
	virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformationExtension); }
	         tt__CertificateInformationExtension() { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
	friend tt__CertificateInformationExtension *soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1539 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (606)
/* Type tt__Dot1XConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot1XConfiguration complex type: */
class SOAP_CMAC tt__Dot1XConfiguration : public xsd__anyType
{
public:
	std::string Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	std::string Identity;	/* required element of XSD type xsd:string */
	std::string *AnonymousID;	/* optional element of XSD type xsd:string */
	int EAPMethod;	/* required element of XSD type xsd:int */
	std::vector<std::string> CACertificateID;	/* optional element of XSD type xsd:token */
	tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of XSD type tt:EAPMethodConfiguration */
	tt__Dot1XConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot1XConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfiguration (606)
	virtual int soap_type(void) const { return 606; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfiguration); }
	         tt__Dot1XConfiguration() { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
	friend tt__Dot1XConfiguration *soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1542 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (607)
/* Type tt__Dot1XConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot1XConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot1XConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfigurationExtension (607)
	virtual int soap_type(void) const { return 607; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfigurationExtension); }
	         tt__Dot1XConfigurationExtension() { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
	friend tt__Dot1XConfigurationExtension *soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1545 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (608)
/* Type tt__EAPMethodConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EAPMethodConfiguration complex type: */
class SOAP_CMAC tt__EAPMethodConfiguration : public xsd__anyType
{
public:
	tt__TLSConfiguration *TLSConfiguration;	/* optional element of XSD type tt:TLSConfiguration */
	std::string *Password;	/* optional element of XSD type xsd:string */
	tt__EapMethodExtension *Extension;	/* optional element of XSD type tt:EapMethodExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EAPMethodConfiguration (608)
	virtual int soap_type(void) const { return 608; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
	virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EAPMethodConfiguration); }
	         tt__EAPMethodConfiguration() { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
	friend tt__EAPMethodConfiguration *soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1548 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (609)
/* Type tt__EapMethodExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EapMethodExtension complex type: */
class SOAP_CMAC tt__EapMethodExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EapMethodExtension (609)
	virtual int soap_type(void) const { return 609; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
	virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW(tt__EapMethodExtension); }
	         tt__EapMethodExtension() { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
	friend tt__EapMethodExtension *soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1551 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (610)
/* Type tt__TLSConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TLSConfiguration complex type: */
class SOAP_CMAC tt__TLSConfiguration : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TLSConfiguration (610)
	virtual int soap_type(void) const { return 610; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
	virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TLSConfiguration); }
	         tt__TLSConfiguration() { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
	friend tt__TLSConfiguration *soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1554 */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (611)
/* Type tt__GenericEapPwdConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GenericEapPwdConfigurationExtension complex type: */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (611)
	virtual int soap_type(void) const { return 611; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__GenericEapPwdConfigurationExtension); }
	         tt__GenericEapPwdConfigurationExtension() { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
	friend tt__GenericEapPwdConfigurationExtension *soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1557 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (612)
/* Type tt__RelayOutputSettings is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutputSettings complex type: */
class SOAP_CMAC tt__RelayOutputSettings : public xsd__anyType
{
public:
	enum tt__RelayMode Mode;	/* required element of XSD type tt:RelayMode */
	LONG64 DelayTime;	/* external (custom serializer) */
	enum tt__RelayIdleState IdleState;	/* required element of XSD type tt:RelayIdleState */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutputSettings (612)
	virtual int soap_type(void) const { return 612; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
	virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutputSettings); }
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
	friend tt__RelayOutputSettings *soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1569 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (616)
/* Type tt__PTZNodeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNodeExtension complex type: */
class SOAP_CMAC tt__PTZNodeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__PTZPresetTourSupported *SupportedPresetTour;	/* optional element of XSD type tt:PTZPresetTourSupported */
	tt__PTZNodeExtension2 *Extension;	/* optional element of XSD type tt:PTZNodeExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension (616)
	virtual int soap_type(void) const { return 616; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension); }
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
	friend tt__PTZNodeExtension *soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1572 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (617)
/* Type tt__PTZNodeExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNodeExtension2 complex type: */
class SOAP_CMAC tt__PTZNodeExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension2 (617)
	virtual int soap_type(void) const { return 617; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension2); }
	         tt__PTZNodeExtension2() { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
	friend tt__PTZNodeExtension2 *soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1575 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (618)
/* Type tt__PTZPresetTourSupported is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSupported complex type: */
class SOAP_CMAC tt__PTZPresetTourSupported : public xsd__anyType
{
public:
	int MaximumNumberOfPresetTours;	/* required element of XSD type xsd:int */
	std::vector<enum tt__PTZPresetTourOperation> PTZPresetTourOperation;	/* optional element of XSD type tt:PTZPresetTourOperation */
	tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSupportedExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupported (618)
	virtual int soap_type(void) const { return 618; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupported); }
	         tt__PTZPresetTourSupported() { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
	friend tt__PTZPresetTourSupported *soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1578 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (619)
/* Type tt__PTZPresetTourSupportedExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSupportedExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupportedExtension (619)
	virtual int soap_type(void) const { return 619; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupportedExtension); }
	         tt__PTZPresetTourSupportedExtension() { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
	friend tt__PTZPresetTourSupportedExtension *soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1584 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (621)
/* Type tt__PTZConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationExtension complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__PTControlDirection *PTControlDirection;	/* optional element of XSD type tt:PTControlDirection */
	tt__PTZConfigurationExtension2 *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension (621)
	virtual int soap_type(void) const { return 621; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension); }
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
	friend tt__PTZConfigurationExtension *soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1587 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (622)
/* Type tt__PTZConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationExtension2 complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension2 (622)
	virtual int soap_type(void) const { return 622; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension2); }
	         tt__PTZConfigurationExtension2() { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
	friend tt__PTZConfigurationExtension2 *soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1590 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (623)
/* Type tt__PTControlDirection is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirection complex type: */
class SOAP_CMAC tt__PTControlDirection : public xsd__anyType
{
public:
	tt__EFlip *EFlip;	/* optional element of XSD type tt:EFlip */
	tt__Reverse *Reverse;	/* optional element of XSD type tt:Reverse */
	tt__PTControlDirectionExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirection (623)
	virtual int soap_type(void) const { return 623; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
	virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirection); }
	         tt__PTControlDirection() { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
	friend tt__PTControlDirection *soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1593 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (624)
/* Type tt__PTControlDirectionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionExtension (624)
	virtual int soap_type(void) const { return 624; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionExtension); }
	         tt__PTControlDirectionExtension() { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
	friend tt__PTControlDirectionExtension *soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1596 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (625)
/* Type tt__EFlip is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlip complex type: */
class SOAP_CMAC tt__EFlip : public xsd__anyType
{
public:
	enum tt__EFlipMode Mode;	/* required element of XSD type tt:EFlipMode */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlip (625)
	virtual int soap_type(void) const { return 625; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
	virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW(tt__EFlip); }
	         tt__EFlip() { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
	friend tt__EFlip *soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1599 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (626)
/* Type tt__Reverse is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Reverse complex type: */
class SOAP_CMAC tt__Reverse : public xsd__anyType
{
public:
	enum tt__ReverseMode Mode;	/* required element of XSD type tt:ReverseMode */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Reverse (626)
	virtual int soap_type(void) const { return 626; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
	virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW(tt__Reverse); }
	         tt__Reverse() { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
	friend tt__Reverse *soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1602 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (627)
/* Type tt__PTZConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationOptions complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions : public xsd__anyType
{
public:
	tt__PTZSpaces *Spaces;	/* required element of XSD type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of XSD type tt:DurationRange */
	std::vector<char *> __any;
	tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of XSD type tt:PTControlDirectionOptions */
	tt__PTZConfigurationOptions2 *Extension;	/* optional element of XSD type tt:PTZConfigurationOptions2 */
	std::string *PTZRamps;	/* optional attribute of XSD type tt:IntAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions (627)
	virtual int soap_type(void) const { return 627; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions); }
	         tt__PTZConfigurationOptions() { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
	friend tt__PTZConfigurationOptions *soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1605 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (628)
/* Type tt__PTZConfigurationOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationOptions2 complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions2 (628)
	virtual int soap_type(void) const { return 628; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions2); }
	         tt__PTZConfigurationOptions2() { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
	friend tt__PTZConfigurationOptions2 *soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1608 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (629)
/* Type tt__PTControlDirectionOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionOptions complex type: */
class SOAP_CMAC tt__PTControlDirectionOptions : public xsd__anyType
{
public:
	tt__EFlipOptions *EFlip;	/* optional element of XSD type tt:EFlipOptions */
	tt__ReverseOptions *Reverse;	/* optional element of XSD type tt:ReverseOptions */
	tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptions (629)
	virtual int soap_type(void) const { return 629; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptions); }
	         tt__PTControlDirectionOptions() { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
	friend tt__PTControlDirectionOptions *soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1611 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (630)
/* Type tt__PTControlDirectionOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionOptionsExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptionsExtension (630)
	virtual int soap_type(void) const { return 630; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptionsExtension); }
	         tt__PTControlDirectionOptionsExtension() { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
	friend tt__PTControlDirectionOptionsExtension *soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1614 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (631)
/* Type tt__EFlipOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipOptions complex type: */
class SOAP_CMAC tt__EFlipOptions : public xsd__anyType
{
public:
	std::vector<enum tt__EFlipMode> Mode;	/* optional element of XSD type tt:EFlipMode */
	tt__EFlipOptionsExtension *Extension;	/* optional element of XSD type tt:EFlipOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptions (631)
	virtual int soap_type(void) const { return 631; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
	virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptions); }
	         tt__EFlipOptions() { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
	friend tt__EFlipOptions *soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1617 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (632)
/* Type tt__EFlipOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipOptionsExtension complex type: */
class SOAP_CMAC tt__EFlipOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptionsExtension (632)
	virtual int soap_type(void) const { return 632; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
	virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptionsExtension); }
	         tt__EFlipOptionsExtension() { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
	friend tt__EFlipOptionsExtension *soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1620 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (633)
/* Type tt__ReverseOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseOptions complex type: */
class SOAP_CMAC tt__ReverseOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ReverseMode> Mode;	/* optional element of XSD type tt:ReverseMode */
	tt__ReverseOptionsExtension *Extension;	/* optional element of XSD type tt:ReverseOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptions (633)
	virtual int soap_type(void) const { return 633; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
	virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptions); }
	         tt__ReverseOptions() { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
	friend tt__ReverseOptions *soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1623 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (634)
/* Type tt__ReverseOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseOptionsExtension complex type: */
class SOAP_CMAC tt__ReverseOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptionsExtension (634)
	virtual int soap_type(void) const { return 634; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptionsExtension); }
	         tt__ReverseOptionsExtension() { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
	friend tt__ReverseOptionsExtension *soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1626 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (635)
/* Type tt__PanTiltLimits is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PanTiltLimits complex type: */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType
{
public:
	tt__Space2DDescription *Range;	/* required element of XSD type tt:Space2DDescription */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PanTiltLimits (635)
	virtual int soap_type(void) const { return 635; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
	virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW(tt__PanTiltLimits); }
	         tt__PanTiltLimits() { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
	friend tt__PanTiltLimits *soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1629 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (636)
/* Type tt__ZoomLimits is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ZoomLimits complex type: */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType
{
public:
	tt__Space1DDescription *Range;	/* required element of XSD type tt:Space1DDescription */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ZoomLimits (636)
	virtual int soap_type(void) const { return 636; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
	virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW(tt__ZoomLimits); }
	         tt__ZoomLimits() { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
	friend tt__ZoomLimits *soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1632 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (637)
/* Type tt__PTZSpaces is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpaces complex type: */
class SOAP_CMAC tt__PTZSpaces : public xsd__anyType
{
public:
	std::vector<tt__Space2DDescription *> AbsolutePanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> AbsoluteZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space2DDescription *> RelativePanTiltTranslationSpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> RelativeZoomTranslationSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space2DDescription *> ContinuousPanTiltVelocitySpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> ContinuousZoomVelocitySpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space1DDescription *> PanTiltSpeedSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space1DDescription *> ZoomSpeedSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZSpacesExtension *Extension;	/* optional element of XSD type tt:PTZSpacesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpaces (637)
	virtual int soap_type(void) const { return 637; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
	virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpaces); }
	         tt__PTZSpaces() { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
	friend tt__PTZSpaces *soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1635 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (638)
/* Type tt__PTZSpacesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpacesExtension complex type: */
class SOAP_CMAC tt__PTZSpacesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpacesExtension (638)
	virtual int soap_type(void) const { return 638; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
	virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpacesExtension); }
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
	friend tt__PTZSpacesExtension *soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1638 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (639)
/* Type tt__Space2DDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Space2DDescription complex type: */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space2DDescription (639)
	virtual int soap_type(void) const { return 639; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
	virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space2DDescription); }
	         tt__Space2DDescription() { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
	friend tt__Space2DDescription *soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1641 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (640)
/* Type tt__Space1DDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Space1DDescription complex type: */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space1DDescription (640)
	virtual int soap_type(void) const { return 640; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
	virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space1DDescription); }
	         tt__Space1DDescription() { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
	friend tt__Space1DDescription *soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1644 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (641)
/* Type tt__Vector2D is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector2D simple type: */
class SOAP_CMAC tt__Vector2D : public xsd__anyType
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	float y;	/* required attribute of XSD type xsd:float */
	std::string *space;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector2D (641)
	virtual int soap_type(void) const { return 641; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
	virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW(tt__Vector2D); }
	         tt__Vector2D() { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
	friend tt__Vector2D *soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1647 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (642)
/* Type tt__Vector1D is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector1D simple type: */
class SOAP_CMAC tt__Vector1D : public xsd__anyType
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	std::string *space;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector1D (642)
	virtual int soap_type(void) const { return 642; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
	virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW(tt__Vector1D); }
	         tt__Vector1D() { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
	friend tt__Vector1D *soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1650 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (643)
/* Type tt__PTZVector is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZVector complex type: */
class SOAP_CMAC tt__PTZVector : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZVector (643)
	virtual int soap_type(void) const { return 643; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
	virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW(tt__PTZVector); }
	         tt__PTZVector() { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
	friend tt__PTZVector *soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1653 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (644)
/* Type tt__PTZSpeed is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpeed complex type: */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpeed (644)
	virtual int soap_type(void) const { return 644; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
	virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpeed); }
	         tt__PTZSpeed() { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
	friend tt__PTZSpeed *soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1656 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (645)
/* Type tt__PTZStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatus complex type: */
class SOAP_CMAC tt__PTZStatus : public xsd__anyType
{
public:
	tt__PTZVector *Position;	/* optional element of XSD type tt:PTZVector */
	tt__PTZMoveStatus *MoveStatus;	/* optional element of XSD type tt:PTZMoveStatus */
	std::string *Error;	/* optional element of XSD type xsd:string */
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatus (645)
	virtual int soap_type(void) const { return 645; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
	virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatus); }
	         tt__PTZStatus() { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
	friend tt__PTZStatus *soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1659 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (646)
/* Type tt__PTZPreset is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPreset complex type: */
class SOAP_CMAC tt__PTZPreset : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of XSD type tt:PTZVector */
	std::string *token;	/* optional attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPreset (646)
	virtual int soap_type(void) const { return 646; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
	virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW(tt__PTZPreset); }
	         tt__PTZPreset() { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
	friend tt__PTZPreset *soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1662 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (647)
/* Type tt__PTZMoveStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZMoveStatus complex type: */
class SOAP_CMAC tt__PTZMoveStatus : public xsd__anyType
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of XSD type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of XSD type tt:MoveStatus */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZMoveStatus (647)
	virtual int soap_type(void) const { return 647; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
	virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZMoveStatus); }
	         tt__PTZMoveStatus() { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
	friend tt__PTZMoveStatus *soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1665 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (648)
/* Type tt__PresetTour is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PresetTour complex type: */
class SOAP_CMAC tt__PresetTour : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZPresetTourStatus *Status;	/* required element of XSD type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingCondition */
	std::vector<tt__PTZPresetTourSpot *> TourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourExtension */
	std::string *token;	/* optional attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PresetTour (648)
	virtual int soap_type(void) const { return 648; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
	virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW(tt__PresetTour); }
	         tt__PresetTour() { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
	friend tt__PresetTour *soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1668 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (649)
/* Type tt__PTZPresetTourExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourExtension (649)
	virtual int soap_type(void) const { return 649; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourExtension); }
	         tt__PTZPresetTourExtension() { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
	friend tt__PTZPresetTourExtension *soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1671 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (650)
/* Type tt__PTZPresetTourSpot is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpot complex type: */
class SOAP_CMAC tt__PTZPresetTourSpot : public xsd__anyType
{
public:
	tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *StayTime;	/* optional element of XSD type xsd:duration */
	tt__PTZPresetTourSpotExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSpotExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpot (650)
	virtual int soap_type(void) const { return 650; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpot); }
	         tt__PTZPresetTourSpot() { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
	friend tt__PTZPresetTourSpot *soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1674 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (651)
/* Type tt__PTZPresetTourSpotExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpotExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotExtension (651)
	virtual int soap_type(void) const { return 651; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotExtension); }
	         tt__PTZPresetTourSpotExtension() { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
	friend tt__PTZPresetTourSpotExtension *soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:17397 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1866)
/* xsd:choice complex type: */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	std::string *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvif.h:1677 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (652)
/* Type tt__PTZPresetTourPresetDetail is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetail complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetail : public xsd__anyType
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetail (652)
	virtual int soap_type(void) const { return 652; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetail); }
	         tt__PTZPresetTourPresetDetail() { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
	friend tt__PTZPresetTourPresetDetail *soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1680 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (653)
/* Type tt__PTZPresetTourTypeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourTypeExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourTypeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourTypeExtension (653)
	virtual int soap_type(void) const { return 653; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourTypeExtension); }
	         tt__PTZPresetTourTypeExtension() { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
	friend tt__PTZPresetTourTypeExtension *soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1683 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (654)
/* Type tt__PTZPresetTourStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStatus complex type: */
class SOAP_CMAC tt__PTZPresetTourStatus : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState State;	/* required element of XSD type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourStatusExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStatusExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatus (654)
	virtual int soap_type(void) const { return 654; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatus); }
	         tt__PTZPresetTourStatus() { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
	friend tt__PTZPresetTourStatus *soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1686 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (655)
/* Type tt__PTZPresetTourStatusExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStatusExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStatusExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatusExtension (655)
	virtual int soap_type(void) const { return 655; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatusExtension); }
	         tt__PTZPresetTourStatusExtension() { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
	friend tt__PTZPresetTourStatusExtension *soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1689 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (656)
/* Type tt__PTZPresetTourStartingCondition is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingCondition complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingCondition : public xsd__anyType
{
public:
	int *RecurringTime;	/* optional element of XSD type xsd:int */
	LONG64 *RecurringDuration;	/* optional element of XSD type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionExtension */
	bool *RandomPresetOrder;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingCondition (656)
	virtual int soap_type(void) const { return 656; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingCondition); }
	         tt__PTZPresetTourStartingCondition() { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
	friend tt__PTZPresetTourStartingCondition *soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1692 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (657)
/* Type tt__PTZPresetTourStartingConditionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (657)
	virtual int soap_type(void) const { return 657; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionExtension); }
	         tt__PTZPresetTourStartingConditionExtension() { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
	friend tt__PTZPresetTourStartingConditionExtension *soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1695 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (658)
/* Type tt__PTZPresetTourOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourOptions : public xsd__anyType
{
public:
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingConditionOptions */
	tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of XSD type tt:PTZPresetTourSpotOptions */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOptions (658)
	virtual int soap_type(void) const { return 658; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOptions); }
	         tt__PTZPresetTourOptions() { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
	friend tt__PTZPresetTourOptions *soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1698 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (659)
/* Type tt__PTZPresetTourSpotOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpotOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotOptions : public xsd__anyType
{
public:
	tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of XSD type tt:DurationRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotOptions (659)
	virtual int soap_type(void) const { return 659; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotOptions); }
	         tt__PTZPresetTourSpotOptions() { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
	friend tt__PTZPresetTourSpotOptions *soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1701 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (660)
/* Type tt__PTZPresetTourPresetDetailOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetailOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions : public xsd__anyType
{
public:
	std::vector<std::string> PresetToken;	/* optional element of XSD type tt:ReferenceToken */
	bool *Home;	/* optional element of XSD type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourPresetDetailOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (660)
	virtual int soap_type(void) const { return 660; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptions); }
	         tt__PTZPresetTourPresetDetailOptions() { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
	friend tt__PTZPresetTourPresetDetailOptions *soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1704 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (661)
/* Type tt__PTZPresetTourPresetDetailOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetailOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (661)
	virtual int soap_type(void) const { return 661; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptionsExtension); }
	         tt__PTZPresetTourPresetDetailOptionsExtension() { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
	friend tt__PTZPresetTourPresetDetailOptionsExtension *soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1707 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (662)
/* Type tt__PTZPresetTourStartingConditionOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions : public xsd__anyType
{
public:
	tt__IntRange *RecurringTime;	/* optional element of XSD type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of XSD type tt:DurationRange */
	std::vector<enum tt__PTZPresetTourDirection> Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (662)
	virtual int soap_type(void) const { return 662; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptions); }
	         tt__PTZPresetTourStartingConditionOptions() { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
	friend tt__PTZPresetTourStartingConditionOptions *soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1710 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (663)
/* Type tt__PTZPresetTourStartingConditionOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (663)
	virtual int soap_type(void) const { return 663; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptionsExtension); }
	         tt__PTZPresetTourStartingConditionOptionsExtension() { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
	friend tt__PTZPresetTourStartingConditionOptionsExtension *soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1713 */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (664)
/* Type tt__ImagingStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus complex type: */
class SOAP_CMAC tt__ImagingStatus : public xsd__anyType
{
public:
	tt__FocusStatus *FocusStatus;	/* required element of XSD type tt:FocusStatus */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus (664)
	virtual int soap_type(void) const { return 664; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus, default initialized and not managed by a soap context
	virtual tt__ImagingStatus *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus); }
	         tt__ImagingStatus() { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
	friend tt__ImagingStatus *soap_instantiate_tt__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1716 */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (665)
/* Type tt__FocusStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus complex type: */
class SOAP_CMAC tt__FocusStatus : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	std::string Error;	/* required element of XSD type xsd:string */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus (665)
	virtual int soap_type(void) const { return 665; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus, default initialized and not managed by a soap context
	virtual tt__FocusStatus *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus); }
	         tt__FocusStatus() { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
	friend tt__FocusStatus *soap_instantiate_tt__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1719 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (666)
/* Type tt__FocusConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration complex type: */
class SOAP_CMAC tt__FocusConfiguration : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of XSD type xsd:float */
	float NearLimit;	/* required element of XSD type xsd:float */
	float FarLimit;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration (666)
	virtual int soap_type(void) const { return 666; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration); }
	         tt__FocusConfiguration() { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
	friend tt__FocusConfiguration *soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1722 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (667)
/* Type tt__ImagingSettings is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettings complex type: */
class SOAP_CMAC tt__ImagingSettings : public xsd__anyType
{
public:
	tt__BacklightCompensation *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure *Exposure;	/* optional element of XSD type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of XSD type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange */
	tt__WhiteBalance *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance */
	tt__ImagingSettingsExtension *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings (667)
	virtual int soap_type(void) const { return 667; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
	virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings); }
	         tt__ImagingSettings() { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
	friend tt__ImagingSettings *soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1725 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (668)
/* Type tt__ImagingSettingsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension (668)
	virtual int soap_type(void) const { return 668; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension); }
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
	friend tt__ImagingSettingsExtension *soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1728 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (669)
/* Type tt__Exposure is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Exposure complex type: */
class SOAP_CMAC tt__Exposure : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* required element of XSD type tt:Rectangle */
	float MinExposureTime;	/* required element of XSD type xsd:float */
	float MaxExposureTime;	/* required element of XSD type xsd:float */
	float MinGain;	/* required element of XSD type xsd:float */
	float MaxGain;	/* required element of XSD type xsd:float */
	float MinIris;	/* required element of XSD type xsd:float */
	float MaxIris;	/* required element of XSD type xsd:float */
	float ExposureTime;	/* required element of XSD type xsd:float */
	float Gain;	/* required element of XSD type xsd:float */
	float Iris;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure (669)
	virtual int soap_type(void) const { return 669; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
	virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW(tt__Exposure); }
	         tt__Exposure() { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
	friend tt__Exposure *soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1731 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (670)
/* Type tt__WideDynamicRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRange complex type: */
class SOAP_CMAC tt__WideDynamicRange : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float Level;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange (670)
	virtual int soap_type(void) const { return 670; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange); }
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
	friend tt__WideDynamicRange *soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1734 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (671)
/* Type tt__BacklightCompensation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensation complex type: */
class SOAP_CMAC tt__BacklightCompensation : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float Level;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation (671)
	virtual int soap_type(void) const { return 671; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation); }
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
	friend tt__BacklightCompensation *soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1737 */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (672)
/* Type tt__ImagingOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions complex type: */
class SOAP_CMAC tt__ImagingOptions : public xsd__anyType
{
public:
	tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of XSD type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of XSD type tt:FloatRange */
	tt__ExposureOptions *Exposure;	/* required element of XSD type tt:ExposureOptions */
	tt__FocusOptions *Focus;	/* required element of XSD type tt:FocusOptions */
	std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;	/* required element of XSD type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* required element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of XSD type tt:WideDynamicRangeOptions */
	tt__WhiteBalanceOptions *WhiteBalance;	/* required element of XSD type tt:WhiteBalanceOptions */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions (672)
	virtual int soap_type(void) const { return 672; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions, default initialized and not managed by a soap context
	virtual tt__ImagingOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions); }
	         tt__ImagingOptions() { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
	friend tt__ImagingOptions *soap_instantiate_tt__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1740 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (673)
/* Type tt__WideDynamicRangeOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRangeOptions complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions (673)
	virtual int soap_type(void) const { return 673; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions); }
	         tt__WideDynamicRangeOptions() { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
	friend tt__WideDynamicRangeOptions *soap_instantiate_tt__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1743 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (674)
/* Type tt__BacklightCompensationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationOptions complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions (674)
	virtual int soap_type(void) const { return 674; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions); }
	         tt__BacklightCompensationOptions() { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
	friend tt__BacklightCompensationOptions *soap_instantiate_tt__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1746 */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (675)
/* Type tt__FocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions complex type: */
class SOAP_CMAC tt__FocusOptions : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode> AutoFocusModes;	/* optional element of XSD type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions (675)
	virtual int soap_type(void) const { return 675; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions, default initialized and not managed by a soap context
	virtual tt__FocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions); }
	         tt__FocusOptions() { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
	friend tt__FocusOptions *soap_instantiate_tt__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1749 */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (676)
/* Type tt__ExposureOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureOptions complex type: */
class SOAP_CMAC tt__ExposureOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode> Mode;	/* required element of XSD type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority> Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions (676)
	virtual int soap_type(void) const { return 676; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions, default initialized and not managed by a soap context
	virtual tt__ExposureOptions *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions); }
	         tt__ExposureOptions() { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
	friend tt__ExposureOptions *soap_instantiate_tt__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1752 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (677)
/* Type tt__WhiteBalanceOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode> Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions (677)
	virtual int soap_type(void) const { return 677; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions); }
	         tt__WhiteBalanceOptions() { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
	friend tt__WhiteBalanceOptions *soap_instantiate_tt__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1755 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (678)
/* Type tt__FocusMove is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusMove complex type: */
class SOAP_CMAC tt__FocusMove : public xsd__anyType
{
public:
	tt__AbsoluteFocus *Absolute;	/* optional element of XSD type tt:AbsoluteFocus */
	tt__RelativeFocus *Relative;	/* optional element of XSD type tt:RelativeFocus */
	tt__ContinuousFocus *Continuous;	/* optional element of XSD type tt:ContinuousFocus */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusMove (678)
	virtual int soap_type(void) const { return 678; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
	virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW(tt__FocusMove); }
	         tt__FocusMove() { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
	friend tt__FocusMove *soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1758 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (679)
/* Type tt__AbsoluteFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AbsoluteFocus complex type: */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocus (679)
	virtual int soap_type(void) const { return 679; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocus); }
	         tt__AbsoluteFocus() { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
	friend tt__AbsoluteFocus *soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1761 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (680)
/* Type tt__RelativeFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocus complex type: */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType
{
public:
	float Distance;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocus (680)
	virtual int soap_type(void) const { return 680; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
	virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocus); }
	         tt__RelativeFocus() { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
	friend tt__RelativeFocus *soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1764 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (681)
/* Type tt__ContinuousFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ContinuousFocus complex type: */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType
{
public:
	float Speed;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocus (681)
	virtual int soap_type(void) const { return 681; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
	virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocus); }
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
	friend tt__ContinuousFocus *soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1767 */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (682)
/* Type tt__MoveOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveOptions complex type: */
class SOAP_CMAC tt__MoveOptions : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions *Relative;	/* optional element of XSD type tt:RelativeFocusOptions */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions (682)
	virtual int soap_type(void) const { return 682; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions, default initialized and not managed by a soap context
	virtual tt__MoveOptions *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions); }
	         tt__MoveOptions() { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
	friend tt__MoveOptions *soap_instantiate_tt__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1770 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (683)
/* Type tt__AbsoluteFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AbsoluteFocusOptions complex type: */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Position;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocusOptions (683)
	virtual int soap_type(void) const { return 683; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocusOptions); }
	         tt__AbsoluteFocusOptions() { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
	friend tt__AbsoluteFocusOptions *soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1773 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (684)
/* Type tt__RelativeFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocusOptions complex type: */
class SOAP_CMAC tt__RelativeFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions (684)
	virtual int soap_type(void) const { return 684; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions); }
	         tt__RelativeFocusOptions() { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
	friend tt__RelativeFocusOptions *soap_instantiate_tt__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1776 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (685)
/* Type tt__ContinuousFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ContinuousFocusOptions complex type: */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocusOptions (685)
	virtual int soap_type(void) const { return 685; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
	virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocusOptions); }
	         tt__ContinuousFocusOptions() { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
	friend tt__ContinuousFocusOptions *soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1779 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (686)
/* Type tt__WhiteBalance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance complex type: */
class SOAP_CMAC tt__WhiteBalance : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float CrGain;	/* required element of XSD type xsd:float */
	float CbGain;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance (686)
	virtual int soap_type(void) const { return 686; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
	virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance); }
	         tt__WhiteBalance() { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
	friend tt__WhiteBalance *soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1782 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (687)
/* Type tt__ImagingStatus20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus20 complex type: */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType
{
public:
	tt__FocusStatus20 *FocusStatus20;	/* optional element of XSD type tt:FocusStatus20 */
	tt__ImagingStatus20Extension *Extension;	/* optional element of XSD type tt:ImagingStatus20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20 (687)
	virtual int soap_type(void) const { return 687; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20); }
	         tt__ImagingStatus20() { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
	friend tt__ImagingStatus20 *soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1785 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (688)
/* Type tt__ImagingStatus20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus20Extension complex type: */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20Extension (688)
	virtual int soap_type(void) const { return 688; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20Extension); }
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
	friend tt__ImagingStatus20Extension *soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1788 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (689)
/* Type tt__FocusStatus20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus20 complex type: */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	std::string *Error;	/* optional element of XSD type xsd:string */
	tt__FocusStatus20Extension *Extension;	/* optional element of XSD type tt:FocusStatus20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20 (689)
	virtual int soap_type(void) const { return 689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
	virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20); }
	         tt__FocusStatus20() { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
	friend tt__FocusStatus20 *soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1791 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (690)
/* Type tt__FocusStatus20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus20Extension complex type: */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20Extension (690)
	virtual int soap_type(void) const { return 690; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
	virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20Extension); }
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
	friend tt__FocusStatus20Extension *soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1794 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (691)
/* Type tt__ImagingSettings20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettings20 complex type: */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType
{
public:
	tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure20 *Exposure;	/* optional element of XSD type tt:Exposure20 */
	tt__FocusConfiguration20 *Focus;	/* optional element of XSD type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange20 */
	tt__WhiteBalance20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance20 */
	tt__ImagingSettingsExtension20 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension20 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings20 (691)
	virtual int soap_type(void) const { return 691; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
	virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings20); }
	         tt__ImagingSettings20() { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
	friend tt__ImagingSettings20 *soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1797 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (692)
/* Type tt__ImagingSettingsExtension20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension20 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__ImageStabilization *ImageStabilization;	/* optional element of XSD type tt:ImageStabilization */
	tt__ImagingSettingsExtension202 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension202 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension20 (692)
	virtual int soap_type(void) const { return 692; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension20); }
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
	friend tt__ImagingSettingsExtension20 *soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1800 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (693)
/* Type tt__ImagingSettingsExtension202 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension202 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension202 : public xsd__anyType
{
public:
	std::vector<tt__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;	/* optional element of XSD type tt:IrCutFilterAutoAdjustment */
	tt__ImagingSettingsExtension203 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension203 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension202 (693)
	virtual int soap_type(void) const { return 693; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension202); }
	         tt__ImagingSettingsExtension202() { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
	friend tt__ImagingSettingsExtension202 *soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1803 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (694)
/* Type tt__ImagingSettingsExtension203 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension203 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension203 : public xsd__anyType
{
public:
	tt__ToneCompensation *ToneCompensation;	/* optional element of XSD type tt:ToneCompensation */
	tt__Defogging *Defogging;	/* optional element of XSD type tt:Defogging */
	tt__NoiseReduction *NoiseReduction;	/* optional element of XSD type tt:NoiseReduction */
	tt__ImagingSettingsExtension204 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension204 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension203 (694)
	virtual int soap_type(void) const { return 694; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension203); }
	         tt__ImagingSettingsExtension203() { tt__ImagingSettingsExtension203::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension203() { }
	friend tt__ImagingSettingsExtension203 *soap_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1806 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (695)
/* Type tt__ImagingSettingsExtension204 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension204 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension204 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension204 (695)
	virtual int soap_type(void) const { return 695; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension204); }
	         tt__ImagingSettingsExtension204() { tt__ImagingSettingsExtension204::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension204() { }
	friend tt__ImagingSettingsExtension204 *soap_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1809 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (696)
/* Type tt__ImageStabilization is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilization complex type: */
class SOAP_CMAC tt__ImageStabilization : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ImageStabilizationExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilization (696)
	virtual int soap_type(void) const { return 696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
	virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilization); }
	         tt__ImageStabilization() { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
	friend tt__ImageStabilization *soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1812 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (697)
/* Type tt__ImageStabilizationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationExtension (697)
	virtual int soap_type(void) const { return 697; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationExtension); }
	         tt__ImageStabilizationExtension() { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
	friend tt__ImageStabilizationExtension *soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1815 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (698)
/* Type tt__IrCutFilterAutoAdjustment is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterAutoAdjustment complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment : public xsd__anyType
{
public:
	std::string BoundaryType;	/* required element of XSD type xsd:string */
	float *BoundaryOffset;	/* optional element of XSD type xsd:float */
	LONG64 *ResponseTime;	/* optional element of XSD type xsd:duration */
	tt__IrCutFilterAutoAdjustmentExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustment (698)
	virtual int soap_type(void) const { return 698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustment); }
	         tt__IrCutFilterAutoAdjustment() { tt__IrCutFilterAutoAdjustment::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustment() { }
	friend tt__IrCutFilterAutoAdjustment *soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1818 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (699)
/* Type tt__IrCutFilterAutoAdjustmentExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterAutoAdjustmentExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (699)
	virtual int soap_type(void) const { return 699; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentExtension); }
	         tt__IrCutFilterAutoAdjustmentExtension() { tt__IrCutFilterAutoAdjustmentExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
	friend tt__IrCutFilterAutoAdjustmentExtension *soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1821 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (700)
/* Type tt__WideDynamicRange20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRange20 complex type: */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float *Level;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange20 (700)
	virtual int soap_type(void) const { return 700; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange20); }
	         tt__WideDynamicRange20() { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
	friend tt__WideDynamicRange20 *soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1824 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (701)
/* Type tt__BacklightCompensation20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensation20 complex type: */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float *Level;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation20 (701)
	virtual int soap_type(void) const { return 701; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation20); }
	         tt__BacklightCompensation20() { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
	friend tt__BacklightCompensation20 *soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1827 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (702)
/* Type tt__Exposure20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Exposure20 complex type: */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of XSD type tt:Rectangle */
	float *MinExposureTime;	/* optional element of XSD type xsd:float */
	float *MaxExposureTime;	/* optional element of XSD type xsd:float */
	float *MinGain;	/* optional element of XSD type xsd:float */
	float *MaxGain;	/* optional element of XSD type xsd:float */
	float *MinIris;	/* optional element of XSD type xsd:float */
	float *MaxIris;	/* optional element of XSD type xsd:float */
	float *ExposureTime;	/* optional element of XSD type xsd:float */
	float *Gain;	/* optional element of XSD type xsd:float */
	float *Iris;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure20 (702)
	virtual int soap_type(void) const { return 702; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
	virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW(tt__Exposure20); }
	         tt__Exposure20() { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
	friend tt__Exposure20 *soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1830 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (703)
/* Type tt__ToneCompensation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ToneCompensation complex type: */
class SOAP_CMAC tt__ToneCompensation : public xsd__anyType
{
public:
	std::string Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ToneCompensationExtension *Extension;	/* optional element of XSD type tt:ToneCompensationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensation (703)
	virtual int soap_type(void) const { return 703; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
	virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensation); }
	         tt__ToneCompensation() { tt__ToneCompensation::soap_default(NULL); }
	virtual ~tt__ToneCompensation() { }
	friend tt__ToneCompensation *soap_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1833 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (704)
/* Type tt__ToneCompensationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ToneCompensationExtension complex type: */
class SOAP_CMAC tt__ToneCompensationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationExtension (704)
	virtual int soap_type(void) const { return 704; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
	virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationExtension); }
	         tt__ToneCompensationExtension() { tt__ToneCompensationExtension::soap_default(NULL); }
	virtual ~tt__ToneCompensationExtension() { }
	friend tt__ToneCompensationExtension *soap_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1836 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (705)
/* Type tt__Defogging is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Defogging complex type: */
class SOAP_CMAC tt__Defogging : public xsd__anyType
{
public:
	std::string Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__DefoggingExtension *Extension;	/* optional element of XSD type tt:DefoggingExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Defogging (705)
	virtual int soap_type(void) const { return 705; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
	virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW(tt__Defogging); }
	         tt__Defogging() { tt__Defogging::soap_default(NULL); }
	virtual ~tt__Defogging() { }
	friend tt__Defogging *soap_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1839 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (706)
/* Type tt__DefoggingExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DefoggingExtension complex type: */
class SOAP_CMAC tt__DefoggingExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingExtension (706)
	virtual int soap_type(void) const { return 706; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
	virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingExtension); }
	         tt__DefoggingExtension() { tt__DefoggingExtension::soap_default(NULL); }
	virtual ~tt__DefoggingExtension() { }
	friend tt__DefoggingExtension *soap_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1842 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (707)
/* Type tt__NoiseReduction is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NoiseReduction complex type: */
class SOAP_CMAC tt__NoiseReduction : public xsd__anyType
{
public:
	float Level;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReduction (707)
	virtual int soap_type(void) const { return 707; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
	virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReduction); }
	         tt__NoiseReduction() { tt__NoiseReduction::soap_default(NULL); }
	virtual ~tt__NoiseReduction() { }
	friend tt__NoiseReduction *soap_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1845 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (708)
/* Type tt__ImagingOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20 complex type: */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType
{
public:
	tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of XSD type tt:FloatRange */
	tt__ExposureOptions20 *Exposure;	/* optional element of XSD type tt:ExposureOptions20 */
	tt__FocusOptions20 *Focus;	/* optional element of XSD type tt:FocusOptions20 */
	std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;	/* optional element of XSD type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* optional element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRangeOptions20 */
	tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalanceOptions20 */
	tt__ImagingOptions20Extension *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20 (708)
	virtual int soap_type(void) const { return 708; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20); }
	         tt__ImagingOptions20() { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
	friend tt__ImagingOptions20 *soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1848 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (709)
/* Type tt__ImagingOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of XSD type tt:ImageStabilizationOptions */
	tt__ImagingOptions20Extension2 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension (709)
	virtual int soap_type(void) const { return 709; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension); }
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
	friend tt__ImagingOptions20Extension *soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1851 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (710)
/* Type tt__ImagingOptions20Extension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension2 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension2 : public xsd__anyType
{
public:
	tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptions */
	tt__ImagingOptions20Extension3 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension3 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension2 (710)
	virtual int soap_type(void) const { return 710; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension2); }
	         tt__ImagingOptions20Extension2() { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
	friend tt__ImagingOptions20Extension2 *soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1854 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (711)
/* Type tt__ImagingOptions20Extension3 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension3 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension3 : public xsd__anyType
{
public:
	tt__ToneCompensationOptions *ToneCompensationOptions;	/* optional element of XSD type tt:ToneCompensationOptions */
	tt__DefoggingOptions *DefoggingOptions;	/* optional element of XSD type tt:DefoggingOptions */
	tt__NoiseReductionOptions *NoiseReductionOptions;	/* optional element of XSD type tt:NoiseReductionOptions */
	tt__ImagingOptions20Extension4 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension4 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension3 (711)
	virtual int soap_type(void) const { return 711; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension3); }
	         tt__ImagingOptions20Extension3() { tt__ImagingOptions20Extension3::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension3() { }
	friend tt__ImagingOptions20Extension3 *soap_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1857 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (712)
/* Type tt__ImagingOptions20Extension4 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension4 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension4 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension4 (712)
	virtual int soap_type(void) const { return 712; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension4); }
	         tt__ImagingOptions20Extension4() { tt__ImagingOptions20Extension4::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension4() { }
	friend tt__ImagingOptions20Extension4 *soap_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1860 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (713)
/* Type tt__ImageStabilizationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationOptions complex type: */
class SOAP_CMAC tt__ImageStabilizationOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ImageStabilizationMode> Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptions (713)
	virtual int soap_type(void) const { return 713; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptions); }
	         tt__ImageStabilizationOptions() { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
	friend tt__ImageStabilizationOptions *soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1863 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (714)
/* Type tt__ImageStabilizationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationOptionsExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptionsExtension (714)
	virtual int soap_type(void) const { return 714; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptionsExtension); }
	         tt__ImageStabilizationOptionsExtension() { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
	friend tt__ImageStabilizationOptionsExtension *soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1866 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (715)
/* Type tt__IrCutFilterAutoAdjustmentOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterAutoAdjustmentOptions complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions : public xsd__anyType
{
public:
	std::vector<std::string> BoundaryType;	/* required element of XSD type xsd:string */
	bool *BoundaryOffset;	/* optional element of XSD type xsd:boolean */
	tt__DurationRange *ResponseTimeRange;	/* optional element of XSD type tt:DurationRange */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (715)
	virtual int soap_type(void) const { return 715; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptions); }
	         tt__IrCutFilterAutoAdjustmentOptions() { tt__IrCutFilterAutoAdjustmentOptions::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
	friend tt__IrCutFilterAutoAdjustmentOptions *soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1869 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (716)
/* Type tt__IrCutFilterAutoAdjustmentOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterAutoAdjustmentOptionsExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (716)
	virtual int soap_type(void) const { return 716; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
	         tt__IrCutFilterAutoAdjustmentOptionsExtension() { tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
	friend tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1872 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (717)
/* Type tt__WideDynamicRangeOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRangeOptions20 complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions20 (717)
	virtual int soap_type(void) const { return 717; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions20); }
	         tt__WideDynamicRangeOptions20() { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
	friend tt__WideDynamicRangeOptions20 *soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1875 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (718)
/* Type tt__BacklightCompensationOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationOptions20 complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__BacklightCompensationMode> Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions20 (718)
	virtual int soap_type(void) const { return 718; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions20); }
	         tt__BacklightCompensationOptions20() { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
	friend tt__BacklightCompensationOptions20 *soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1878 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (719)
/* Type tt__ExposureOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureOptions20 complex type: */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode> Mode;	/* required element of XSD type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority> Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions20 (719)
	virtual int soap_type(void) const { return 719; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
	virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions20); }
	         tt__ExposureOptions20() { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
	friend tt__ExposureOptions20 *soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1881 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (720)
/* Type tt__MoveOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveOptions20 complex type: */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions20 *Relative;	/* optional element of XSD type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions20 (720)
	virtual int soap_type(void) const { return 720; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
	virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions20); }
	         tt__MoveOptions20() { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
	friend tt__MoveOptions20 *soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1884 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (721)
/* Type tt__RelativeFocusOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocusOptions20 complex type: */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions20 (721)
	virtual int soap_type(void) const { return 721; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions20); }
	         tt__RelativeFocusOptions20() { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
	friend tt__RelativeFocusOptions20 *soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1887 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (722)
/* Type tt__WhiteBalance20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance20 complex type: */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of XSD type xsd:float */
	float *CbGain;	/* optional element of XSD type xsd:float */
	tt__WhiteBalance20Extension *Extension;	/* optional element of XSD type tt:WhiteBalance20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20 (722)
	virtual int soap_type(void) const { return 722; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20); }
	         tt__WhiteBalance20() { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
	friend tt__WhiteBalance20 *soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1890 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (723)
/* Type tt__WhiteBalance20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance20Extension complex type: */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20Extension (723)
	virtual int soap_type(void) const { return 723; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20Extension); }
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
	friend tt__WhiteBalance20Extension *soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1893 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (724)
/* Type tt__FocusConfiguration20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration20 complex type: */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of XSD type xsd:float */
	float *NearLimit;	/* optional element of XSD type xsd:float */
	float *FarLimit;	/* optional element of XSD type xsd:float */
	tt__FocusConfiguration20Extension *Extension;	/* optional element of XSD type tt:FocusConfiguration20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20 (724)
	virtual int soap_type(void) const { return 724; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20); }
	         tt__FocusConfiguration20() { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
	friend tt__FocusConfiguration20 *soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1896 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (725)
/* Type tt__FocusConfiguration20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration20Extension complex type: */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20Extension (725)
	virtual int soap_type(void) const { return 725; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20Extension); }
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
	friend tt__FocusConfiguration20Extension *soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1899 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (726)
/* Type tt__WhiteBalanceOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions20 complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode> Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of XSD type tt:FloatRange */
	tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of XSD type tt:WhiteBalanceOptions20Extension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20 (726)
	virtual int soap_type(void) const { return 726; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20); }
	         tt__WhiteBalanceOptions20() { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
	friend tt__WhiteBalanceOptions20 *soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1902 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (727)
/* Type tt__WhiteBalanceOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions20Extension complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20Extension (727)
	virtual int soap_type(void) const { return 727; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20Extension); }
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
	friend tt__WhiteBalanceOptions20Extension *soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1905 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (728)
/* Type tt__FocusOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions20 complex type: */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode> AutoFocusModes;	/* optional element of XSD type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FocusOptions20Extension *Extension;	/* optional element of XSD type tt:FocusOptions20Extension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20 (728)
	virtual int soap_type(void) const { return 728; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
	virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20); }
	         tt__FocusOptions20() { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
	friend tt__FocusOptions20 *soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1908 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (729)
/* Type tt__FocusOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions20Extension complex type: */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20Extension (729)
	virtual int soap_type(void) const { return 729; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
	virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20Extension); }
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
	friend tt__FocusOptions20Extension *soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1911 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (730)
/* Type tt__ToneCompensationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ToneCompensationOptions complex type: */
class SOAP_CMAC tt__ToneCompensationOptions : public xsd__anyType
{
public:
	std::vector<std::string> Mode;	/* required element of XSD type xsd:string */
	bool Level;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationOptions (730)
	virtual int soap_type(void) const { return 730; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
	virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationOptions); }
	         tt__ToneCompensationOptions() { tt__ToneCompensationOptions::soap_default(NULL); }
	virtual ~tt__ToneCompensationOptions() { }
	friend tt__ToneCompensationOptions *soap_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1914 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (731)
/* Type tt__DefoggingOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DefoggingOptions complex type: */
class SOAP_CMAC tt__DefoggingOptions : public xsd__anyType
{
public:
	std::vector<std::string> Mode;	/* required element of XSD type xsd:string */
	bool Level;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingOptions (731)
	virtual int soap_type(void) const { return 731; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
	virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingOptions); }
	         tt__DefoggingOptions() { tt__DefoggingOptions::soap_default(NULL); }
	virtual ~tt__DefoggingOptions() { }
	friend tt__DefoggingOptions *soap_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1917 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (732)
/* Type tt__NoiseReductionOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NoiseReductionOptions complex type: */
class SOAP_CMAC tt__NoiseReductionOptions : public xsd__anyType
{
public:
	bool Level;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReductionOptions (732)
	virtual int soap_type(void) const { return 732; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
	virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReductionOptions); }
	         tt__NoiseReductionOptions() { tt__NoiseReductionOptions::soap_default(NULL); }
	virtual ~tt__NoiseReductionOptions() { }
	friend tt__NoiseReductionOptions *soap_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1920 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (733)
/* Type tt__MessageExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageExtension complex type: */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageExtension (733)
	virtual int soap_type(void) const { return 733; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
	virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageExtension); }
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
	friend tt__MessageExtension *soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20143 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1948)
/* tt:ItemList-SimpleItem complex type: */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Value;	/* required attribute of XSD type xsd:anySimpleType */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_SimpleItem (1948)
	virtual int soap_type(void) const { return 1948; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_SimpleItem); }
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
	friend _tt__ItemList_SimpleItem *soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20171 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1951)
/* tt:ItemList-ElementItem complex type: */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	char *__any;
	std::string Name;	/* required attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_ElementItem (1951)
	virtual int soap_type(void) const { return 1951; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_ElementItem); }
	         _tt__ItemList_ElementItem() { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
	friend _tt__ItemList_ElementItem *soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1923 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (734)
/* Type tt__ItemList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemList complex type: */
class SOAP_CMAC tt__ItemList : public xsd__anyType
{
public:
	std::vector<_tt__ItemList_SimpleItem> *SimpleItem;	/* optional element of XSD type tt:ItemList-SimpleItem */
	std::vector<_tt__ItemList_ElementItem> *ElementItem;	/* optional element of XSD type tt:ItemList-ElementItem */
	tt__ItemListExtension *Extension;	/* optional element of XSD type tt:ItemListExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemList (734)
	virtual int soap_type(void) const { return 734; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
	virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW(tt__ItemList); }
	         tt__ItemList() { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
	friend tt__ItemList *soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1926 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (735)
/* Type tt__ItemListExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListExtension complex type: */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListExtension (735)
	virtual int soap_type(void) const { return 735; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
	virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListExtension); }
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
	friend tt__ItemListExtension *soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1929 */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (736)
/* Type tt__MessageDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageDescription complex type: */
class SOAP_CMAC tt__MessageDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescription (736)
	virtual int soap_type(void) const { return 736; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescription, default initialized and not managed by a soap context
	virtual tt__MessageDescription *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescription); }
	         tt__MessageDescription() { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
	friend tt__MessageDescription *soap_instantiate_tt__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1932 */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (737)
/* Type tt__MessageDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageDescriptionExtension complex type: */
class SOAP_CMAC tt__MessageDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescriptionExtension (737)
	virtual int soap_type(void) const { return 737; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescriptionExtension); }
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
	friend tt__MessageDescriptionExtension *soap_instantiate_tt__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20322 */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1957)
/* tt:ItemListDescription-SimpleItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1957)
	virtual int soap_type(void) const { return 1957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription); }
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
	friend _tt__ItemListDescription_SimpleItemDescription *soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20347 */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1960)
/* tt:ItemListDescription-ElementItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1960)
	virtual int soap_type(void) const { return 1960; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_ElementItemDescription); }
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
	friend _tt__ItemListDescription_ElementItemDescription *soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1935 */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (738)
/* Type tt__ItemListDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListDescription complex type: */
class SOAP_CMAC tt__ItemListDescription : public xsd__anyType
{
public:
	std::vector<_tt__ItemListDescription_SimpleItemDescription> *SimpleItemDescription;	/* optional element of XSD type tt:ItemListDescription-SimpleItemDescription */
	std::vector<_tt__ItemListDescription_ElementItemDescription> *ElementItemDescription;	/* optional element of XSD type tt:ItemListDescription-ElementItemDescription */
	tt__ItemListDescriptionExtension *Extension;	/* optional element of XSD type tt:ItemListDescriptionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescription (738)
	virtual int soap_type(void) const { return 738; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescription, default initialized and not managed by a soap context
	virtual tt__ItemListDescription *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescription); }
	         tt__ItemListDescription() { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
	friend tt__ItemListDescription *soap_instantiate_tt__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1938 */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (739)
/* Type tt__ItemListDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListDescriptionExtension complex type: */
class SOAP_CMAC tt__ItemListDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescriptionExtension (739)
	virtual int soap_type(void) const { return 739; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescriptionExtension); }
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
	friend tt__ItemListDescriptionExtension *soap_instantiate_tt__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1941 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (740)
/* Type tt__Vector is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector simple type: */
class SOAP_CMAC tt__Vector : public xsd__anyType
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector (740)
	virtual int soap_type(void) const { return 740; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector, default initialized and not managed by a soap context
	virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW(tt__Vector); }
	         tt__Vector() { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
	friend tt__Vector *soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1944 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (741)
/* Type tt__Rectangle is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rectangle simple type: */
class SOAP_CMAC tt__Rectangle : public xsd__anyType
{
public:
	float *bottom;	/* optional attribute of XSD type xsd:float */
	float *top;	/* optional attribute of XSD type xsd:float */
	float *right;	/* optional attribute of XSD type xsd:float */
	float *left;	/* optional attribute of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rectangle (741)
	virtual int soap_type(void) const { return 741; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
	virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW(tt__Rectangle); }
	         tt__Rectangle() { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
	friend tt__Rectangle *soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1947 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (742)
/* Type tt__Polygon is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Polygon complex type: */
class SOAP_CMAC tt__Polygon : public xsd__anyType
{
public:
	std::vector<tt__Vector *> Point;	/* required element of XSD type tt:Vector */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polygon (742)
	virtual int soap_type(void) const { return 742; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
	virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW(tt__Polygon); }
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
	friend tt__Polygon *soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1950 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (743)
/* Type tt__Polyline is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Polyline complex type: */
class SOAP_CMAC tt__Polyline : public xsd__anyType
{
public:
	std::vector<tt__Vector *> Point;	/* required element of XSD type tt:Vector */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polyline (743)
	virtual int soap_type(void) const { return 743; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
	virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW(tt__Polyline); }
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
	friend tt__Polyline *soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1953 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (744)
/* Type tt__Color is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Color simple type: */
class SOAP_CMAC tt__Color : public xsd__anyType
{
public:
	float X;	/* required attribute of XSD type xsd:float */
	float Y;	/* required attribute of XSD type xsd:float */
	float Z;	/* required attribute of XSD type xsd:float */
	std::string *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Color (744)
	virtual int soap_type(void) const { return 744; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Color, default initialized and not managed by a soap context
	virtual tt__Color *soap_alloc(void) const { return SOAP_NEW(tt__Color); }
	         tt__Color() { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
	friend tt__Color *soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1956 */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (745)
/* Type tt__ColorCovariance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorCovariance simple type: */
class SOAP_CMAC tt__ColorCovariance : public xsd__anyType
{
public:
	float XX;	/* required attribute of XSD type xsd:float */
	float YY;	/* required attribute of XSD type xsd:float */
	float ZZ;	/* required attribute of XSD type xsd:float */
	float *XY;	/* optional attribute of XSD type xsd:float */
	float *XZ;	/* optional attribute of XSD type xsd:float */
	float *YZ;	/* optional attribute of XSD type xsd:float */
	std::string *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorCovariance (745)
	virtual int soap_type(void) const { return 745; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorCovariance, default initialized and not managed by a soap context
	virtual tt__ColorCovariance *soap_alloc(void) const { return SOAP_NEW(tt__ColorCovariance); }
	         tt__ColorCovariance() { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
	friend tt__ColorCovariance *soap_instantiate_tt__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1959 */
#ifndef SOAP_TYPE_tt__Appearance
#define SOAP_TYPE_tt__Appearance (746)
/* Type tt__Appearance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Appearance complex type: */
class SOAP_CMAC tt__Appearance : public xsd__anyType
{
public:
	tt__Transformation *Transformation;	/* optional element of XSD type tt:Transformation */
	tt__ShapeDescriptor *Shape;	/* optional element of XSD type tt:ShapeDescriptor */
	tt__ColorDescriptor *Color;	/* optional element of XSD type tt:ColorDescriptor */
	tt__ClassDescriptor *Class;	/* optional element of XSD type tt:ClassDescriptor */
	tt__AppearanceExtension *Extension;	/* optional element of XSD type tt:AppearanceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Appearance (746)
	virtual int soap_type(void) const { return 746; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Appearance, default initialized and not managed by a soap context
	virtual tt__Appearance *soap_alloc(void) const { return SOAP_NEW(tt__Appearance); }
	         tt__Appearance() { tt__Appearance::soap_default(NULL); }
	virtual ~tt__Appearance() { }
	friend tt__Appearance *soap_instantiate_tt__Appearance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1962 */
#ifndef SOAP_TYPE_tt__AppearanceExtension
#define SOAP_TYPE_tt__AppearanceExtension (747)
/* Type tt__AppearanceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AppearanceExtension complex type: */
class SOAP_CMAC tt__AppearanceExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AppearanceExtension (747)
	virtual int soap_type(void) const { return 747; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AppearanceExtension, default initialized and not managed by a soap context
	virtual tt__AppearanceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AppearanceExtension); }
	         tt__AppearanceExtension() { tt__AppearanceExtension::soap_default(NULL); }
	virtual ~tt__AppearanceExtension() { }
	friend tt__AppearanceExtension *soap_instantiate_tt__AppearanceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1965 */
#ifndef SOAP_TYPE_tt__ShapeDescriptor
#define SOAP_TYPE_tt__ShapeDescriptor (748)
/* Type tt__ShapeDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ShapeDescriptor complex type: */
class SOAP_CMAC tt__ShapeDescriptor : public xsd__anyType
{
public:
	tt__Rectangle *BoundingBox;	/* required element of XSD type tt:Rectangle */
	tt__Vector *CenterOfGravity;	/* required element of XSD type tt:Vector */
	std::vector<tt__Polygon *> Polygon;	/* optional element of XSD type tt:Polygon */
	tt__ShapeDescriptorExtension *Extension;	/* optional element of XSD type tt:ShapeDescriptorExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ShapeDescriptor (748)
	virtual int soap_type(void) const { return 748; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ShapeDescriptor, default initialized and not managed by a soap context
	virtual tt__ShapeDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ShapeDescriptor); }
	         tt__ShapeDescriptor() { tt__ShapeDescriptor::soap_default(NULL); }
	virtual ~tt__ShapeDescriptor() { }
	friend tt__ShapeDescriptor *soap_instantiate_tt__ShapeDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1968 */
#ifndef SOAP_TYPE_tt__ShapeDescriptorExtension
#define SOAP_TYPE_tt__ShapeDescriptorExtension (749)
/* Type tt__ShapeDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ShapeDescriptorExtension complex type: */
class SOAP_CMAC tt__ShapeDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ShapeDescriptorExtension (749)
	virtual int soap_type(void) const { return 749; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ShapeDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ShapeDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ShapeDescriptorExtension); }
	         tt__ShapeDescriptorExtension() { tt__ShapeDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ShapeDescriptorExtension() { }
	friend tt__ShapeDescriptorExtension *soap_instantiate_tt__ShapeDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20661 */
#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1974)
/* tt:ColorDescriptor-ColorCluster complex type: */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster
{
public:
	tt__Color *Color;	/* required element of XSD type tt:Color */
	float *Weight;	/* optional element of XSD type xsd:float */
	tt__ColorCovariance *Covariance;	/* optional element of XSD type tt:ColorCovariance */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1974)
	virtual int soap_type(void) const { return 1974; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ColorDescriptor_ColorCluster, default initialized and not managed by a soap context
	virtual _tt__ColorDescriptor_ColorCluster *soap_alloc(void) const { return SOAP_NEW(_tt__ColorDescriptor_ColorCluster); }
	         _tt__ColorDescriptor_ColorCluster() { _tt__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_tt__ColorDescriptor_ColorCluster() { }
	friend _tt__ColorDescriptor_ColorCluster *soap_instantiate__tt__ColorDescriptor_ColorCluster(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1971 */
#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (750)
/* Type tt__ColorDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorDescriptor complex type: */
class SOAP_CMAC tt__ColorDescriptor : public xsd__anyType
{
public:
	std::vector<_tt__ColorDescriptor_ColorCluster> *ColorCluster;	/* optional element of XSD type tt:ColorDescriptor-ColorCluster */
	tt__ColorDescriptorExtension *Extension;	/* optional element of XSD type tt:ColorDescriptorExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorDescriptor (750)
	virtual int soap_type(void) const { return 750; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorDescriptor, default initialized and not managed by a soap context
	virtual tt__ColorDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ColorDescriptor); }
	         tt__ColorDescriptor() { tt__ColorDescriptor::soap_default(NULL); }
	virtual ~tt__ColorDescriptor() { }
	friend tt__ColorDescriptor *soap_instantiate_tt__ColorDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1974 */
#ifndef SOAP_TYPE_tt__ColorDescriptorExtension
#define SOAP_TYPE_tt__ColorDescriptorExtension (751)
/* Type tt__ColorDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorDescriptorExtension complex type: */
class SOAP_CMAC tt__ColorDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorDescriptorExtension (751)
	virtual int soap_type(void) const { return 751; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ColorDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ColorDescriptorExtension); }
	         tt__ColorDescriptorExtension() { tt__ColorDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ColorDescriptorExtension() { }
	friend tt__ColorDescriptorExtension *soap_instantiate_tt__ColorDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20729 */
#ifndef SOAP_TYPE__tt__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (1980)
/* tt:ClassDescriptor-ClassCandidate complex type: */
class SOAP_CMAC _tt__ClassDescriptor_ClassCandidate
{
public:
	enum tt__ClassType Type;	/* required element of XSD type tt:ClassType */
	float Likelihood;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (1980)
	virtual int soap_type(void) const { return 1980; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ClassDescriptor_ClassCandidate, default initialized and not managed by a soap context
	virtual _tt__ClassDescriptor_ClassCandidate *soap_alloc(void) const { return SOAP_NEW(_tt__ClassDescriptor_ClassCandidate); }
	         _tt__ClassDescriptor_ClassCandidate() { _tt__ClassDescriptor_ClassCandidate::soap_default(NULL); }
	virtual ~_tt__ClassDescriptor_ClassCandidate() { }
	friend _tt__ClassDescriptor_ClassCandidate *soap_instantiate__tt__ClassDescriptor_ClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1977 */
#ifndef SOAP_TYPE_tt__ClassDescriptor
#define SOAP_TYPE_tt__ClassDescriptor (752)
/* Type tt__ClassDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptor complex type: */
class SOAP_CMAC tt__ClassDescriptor : public xsd__anyType
{
public:
	std::vector<_tt__ClassDescriptor_ClassCandidate> *ClassCandidate;	/* optional element of XSD type tt:ClassDescriptor-ClassCandidate */
	tt__ClassDescriptorExtension *Extension;	/* optional element of XSD type tt:ClassDescriptorExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptor (752)
	virtual int soap_type(void) const { return 752; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptor, default initialized and not managed by a soap context
	virtual tt__ClassDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptor); }
	         tt__ClassDescriptor() { tt__ClassDescriptor::soap_default(NULL); }
	virtual ~tt__ClassDescriptor() { }
	friend tt__ClassDescriptor *soap_instantiate_tt__ClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1980 */
#ifndef SOAP_TYPE_tt__ClassDescriptorExtension
#define SOAP_TYPE_tt__ClassDescriptorExtension (753)
/* Type tt__ClassDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptorExtension complex type: */
class SOAP_CMAC tt__ClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	std::vector<tt__OtherType *> OtherTypes;	/* required element of XSD type tt:OtherType */
	tt__ClassDescriptorExtension2 *Extension;	/* optional element of XSD type tt:ClassDescriptorExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptorExtension (753)
	virtual int soap_type(void) const { return 753; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptorExtension); }
	         tt__ClassDescriptorExtension() { tt__ClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension() { }
	friend tt__ClassDescriptorExtension *soap_instantiate_tt__ClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1983 */
#ifndef SOAP_TYPE_tt__ClassDescriptorExtension2
#define SOAP_TYPE_tt__ClassDescriptorExtension2 (754)
/* Type tt__ClassDescriptorExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptorExtension2 complex type: */
class SOAP_CMAC tt__ClassDescriptorExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptorExtension2 (754)
	virtual int soap_type(void) const { return 754; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptorExtension2, default initialized and not managed by a soap context
	virtual tt__ClassDescriptorExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptorExtension2); }
	         tt__ClassDescriptorExtension2() { tt__ClassDescriptorExtension2::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension2() { }
	friend tt__ClassDescriptorExtension2 *soap_instantiate_tt__ClassDescriptorExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1986 */
#ifndef SOAP_TYPE_tt__OtherType
#define SOAP_TYPE_tt__OtherType (755)
/* Type tt__OtherType is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OtherType complex type: */
class SOAP_CMAC tt__OtherType : public xsd__anyType
{
public:
	std::string Type;	/* required element of XSD type xsd:string */
	float Likelihood;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OtherType (755)
	virtual int soap_type(void) const { return 755; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OtherType, default initialized and not managed by a soap context
	virtual tt__OtherType *soap_alloc(void) const { return SOAP_NEW(tt__OtherType); }
	         tt__OtherType() { tt__OtherType::soap_default(NULL); }
	virtual ~tt__OtherType() { }
	friend tt__OtherType *soap_instantiate_tt__OtherType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1992 */
#ifndef SOAP_TYPE_tt__ObjectExtension
#define SOAP_TYPE_tt__ObjectExtension (757)
/* Type tt__ObjectExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectExtension complex type: */
class SOAP_CMAC tt__ObjectExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectExtension (757)
	virtual int soap_type(void) const { return 757; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectExtension, default initialized and not managed by a soap context
	virtual tt__ObjectExtension *soap_alloc(void) const { return SOAP_NEW(tt__ObjectExtension); }
	         tt__ObjectExtension() { tt__ObjectExtension::soap_default(NULL); }
	virtual ~tt__ObjectExtension() { }
	friend tt__ObjectExtension *soap_instantiate_tt__ObjectExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1995 */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (758)
/* Type tt__Transformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transformation complex type: */
class SOAP_CMAC tt__Transformation : public xsd__anyType
{
public:
	tt__Vector *Translate;	/* optional element of XSD type tt:Vector */
	tt__Vector *Scale;	/* optional element of XSD type tt:Vector */
	tt__TransformationExtension *Extension;	/* optional element of XSD type tt:TransformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transformation (758)
	virtual int soap_type(void) const { return 758; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transformation, default initialized and not managed by a soap context
	virtual tt__Transformation *soap_alloc(void) const { return SOAP_NEW(tt__Transformation); }
	         tt__Transformation() { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
	friend tt__Transformation *soap_instantiate_tt__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1998 */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (759)
/* Type tt__TransformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TransformationExtension complex type: */
class SOAP_CMAC tt__TransformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransformationExtension (759)
	virtual int soap_type(void) const { return 759; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransformationExtension, default initialized and not managed by a soap context
	virtual tt__TransformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__TransformationExtension); }
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
	friend tt__TransformationExtension *soap_instantiate_tt__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2001 */
#ifndef SOAP_TYPE_tt__Frame
#define SOAP_TYPE_tt__Frame (760)
/* Type tt__Frame is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Frame complex type: */
class SOAP_CMAC tt__Frame : public xsd__anyType
{
public:
	tt__PTZStatus *PTZStatus;	/* optional element of XSD type tt:PTZStatus */
	tt__Transformation *Transformation;	/* optional element of XSD type tt:Transformation */
	std::vector<tt__Object *> Object;	/* optional element of XSD type tt:Object */
	tt__ObjectTree *ObjectTree;	/* optional element of XSD type tt:ObjectTree */
	tt__FrameExtension *Extension;	/* optional element of XSD type tt:FrameExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Frame (760)
	virtual int soap_type(void) const { return 760; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Frame, default initialized and not managed by a soap context
	virtual tt__Frame *soap_alloc(void) const { return SOAP_NEW(tt__Frame); }
	         tt__Frame() { tt__Frame::soap_default(NULL); }
	virtual ~tt__Frame() { }
	friend tt__Frame *soap_instantiate_tt__Frame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2004 */
#ifndef SOAP_TYPE_tt__FrameExtension
#define SOAP_TYPE_tt__FrameExtension (761)
/* Type tt__FrameExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FrameExtension complex type: */
class SOAP_CMAC tt__FrameExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__MotionInCells *MotionInCells;	/* optional element of XSD type tt:MotionInCells */
	tt__FrameExtension2 *Extension;	/* optional element of XSD type tt:FrameExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FrameExtension (761)
	virtual int soap_type(void) const { return 761; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FrameExtension, default initialized and not managed by a soap context
	virtual tt__FrameExtension *soap_alloc(void) const { return SOAP_NEW(tt__FrameExtension); }
	         tt__FrameExtension() { tt__FrameExtension::soap_default(NULL); }
	virtual ~tt__FrameExtension() { }
	friend tt__FrameExtension *soap_instantiate_tt__FrameExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2007 */
#ifndef SOAP_TYPE_tt__FrameExtension2
#define SOAP_TYPE_tt__FrameExtension2 (762)
/* Type tt__FrameExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FrameExtension2 complex type: */
class SOAP_CMAC tt__FrameExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FrameExtension2 (762)
	virtual int soap_type(void) const { return 762; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FrameExtension2, default initialized and not managed by a soap context
	virtual tt__FrameExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__FrameExtension2); }
	         tt__FrameExtension2() { tt__FrameExtension2::soap_default(NULL); }
	virtual ~tt__FrameExtension2() { }
	friend tt__FrameExtension2 *soap_instantiate_tt__FrameExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2010 */
#ifndef SOAP_TYPE_tt__Merge
#define SOAP_TYPE_tt__Merge (763)
/* Type tt__Merge is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Merge complex type: */
class SOAP_CMAC tt__Merge : public xsd__anyType
{
public:
	std::vector<tt__ObjectId *> from;	/* required element of XSD type tt:ObjectId */
	tt__ObjectId *to;	/* required element of XSD type tt:ObjectId */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Merge (763)
	virtual int soap_type(void) const { return 763; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Merge, default initialized and not managed by a soap context
	virtual tt__Merge *soap_alloc(void) const { return SOAP_NEW(tt__Merge); }
	         tt__Merge() { tt__Merge::soap_default(NULL); }
	virtual ~tt__Merge() { }
	friend tt__Merge *soap_instantiate_tt__Merge(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2013 */
#ifndef SOAP_TYPE_tt__Split
#define SOAP_TYPE_tt__Split (764)
/* Type tt__Split is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Split complex type: */
class SOAP_CMAC tt__Split : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of XSD type tt:ObjectId */
	std::vector<tt__ObjectId *> to;	/* required element of XSD type tt:ObjectId */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Split (764)
	virtual int soap_type(void) const { return 764; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Split, default initialized and not managed by a soap context
	virtual tt__Split *soap_alloc(void) const { return SOAP_NEW(tt__Split); }
	         tt__Split() { tt__Split::soap_default(NULL); }
	virtual ~tt__Split() { }
	friend tt__Split *soap_instantiate_tt__Split(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2016 */
#ifndef SOAP_TYPE_tt__Rename
#define SOAP_TYPE_tt__Rename (765)
/* Type tt__Rename is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rename complex type: */
class SOAP_CMAC tt__Rename : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of XSD type tt:ObjectId */
	tt__ObjectId *to;	/* required element of XSD type tt:ObjectId */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rename (765)
	virtual int soap_type(void) const { return 765; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rename, default initialized and not managed by a soap context
	virtual tt__Rename *soap_alloc(void) const { return SOAP_NEW(tt__Rename); }
	         tt__Rename() { tt__Rename::soap_default(NULL); }
	virtual ~tt__Rename() { }
	friend tt__Rename *soap_instantiate_tt__Rename(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2019 */
#ifndef SOAP_TYPE_tt__ObjectId
#define SOAP_TYPE_tt__ObjectId (766)
/* Type tt__ObjectId is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectId simple type: */
class SOAP_CMAC tt__ObjectId : public xsd__anyType
{
public:
	std::string *ObjectId;	/* optional attribute of XSD type xsd:integer */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectId (766)
	virtual int soap_type(void) const { return 766; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectId, default initialized and not managed by a soap context
	virtual tt__ObjectId *soap_alloc(void) const { return SOAP_NEW(tt__ObjectId); }
	         tt__ObjectId() { tt__ObjectId::soap_default(NULL); }
	virtual ~tt__ObjectId() { }
	friend tt__ObjectId *soap_instantiate_tt__ObjectId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:21095 */
#ifndef SOAP_TYPE__tt__Behaviour_Removed
#define SOAP_TYPE__tt__Behaviour_Removed (1998)
/* tt:Behaviour-Removed complex type: */
class SOAP_CMAC _tt__Behaviour_Removed
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Behaviour_Removed (1998)
	virtual int soap_type(void) const { return 1998; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Behaviour_Removed, default initialized and not managed by a soap context
	virtual _tt__Behaviour_Removed *soap_alloc(void) const { return SOAP_NEW(_tt__Behaviour_Removed); }
	         _tt__Behaviour_Removed() { _tt__Behaviour_Removed::soap_default(NULL); }
	virtual ~_tt__Behaviour_Removed() { }
	friend _tt__Behaviour_Removed *soap_instantiate__tt__Behaviour_Removed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:21115 */
#ifndef SOAP_TYPE__tt__Behaviour_Idle
#define SOAP_TYPE__tt__Behaviour_Idle (2000)
/* tt:Behaviour-Idle complex type: */
class SOAP_CMAC _tt__Behaviour_Idle
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Behaviour_Idle (2000)
	virtual int soap_type(void) const { return 2000; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Behaviour_Idle, default initialized and not managed by a soap context
	virtual _tt__Behaviour_Idle *soap_alloc(void) const { return SOAP_NEW(_tt__Behaviour_Idle); }
	         _tt__Behaviour_Idle() { _tt__Behaviour_Idle::soap_default(NULL); }
	virtual ~_tt__Behaviour_Idle() { }
	friend _tt__Behaviour_Idle *soap_instantiate__tt__Behaviour_Idle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2022 */
#ifndef SOAP_TYPE_tt__Behaviour
#define SOAP_TYPE_tt__Behaviour (767)
/* Type tt__Behaviour is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Behaviour complex type: */
class SOAP_CMAC tt__Behaviour : public xsd__anyType
{
public:
	_tt__Behaviour_Removed *Removed;	/* optional element of XSD type tt:Behaviour-Removed */
	_tt__Behaviour_Idle *Idle;	/* optional element of XSD type tt:Behaviour-Idle */
	tt__BehaviourExtension *Extension;	/* optional element of XSD type tt:BehaviourExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Behaviour (767)
	virtual int soap_type(void) const { return 767; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Behaviour, default initialized and not managed by a soap context
	virtual tt__Behaviour *soap_alloc(void) const { return SOAP_NEW(tt__Behaviour); }
	         tt__Behaviour() { tt__Behaviour::soap_default(NULL); }
	virtual ~tt__Behaviour() { }
	friend tt__Behaviour *soap_instantiate_tt__Behaviour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2025 */
#ifndef SOAP_TYPE_tt__BehaviourExtension
#define SOAP_TYPE_tt__BehaviourExtension (768)
/* Type tt__BehaviourExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BehaviourExtension complex type: */
class SOAP_CMAC tt__BehaviourExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BehaviourExtension (768)
	virtual int soap_type(void) const { return 768; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BehaviourExtension, default initialized and not managed by a soap context
	virtual tt__BehaviourExtension *soap_alloc(void) const { return SOAP_NEW(tt__BehaviourExtension); }
	         tt__BehaviourExtension() { tt__BehaviourExtension::soap_default(NULL); }
	virtual ~tt__BehaviourExtension() { }
	friend tt__BehaviourExtension *soap_instantiate_tt__BehaviourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2028 */
#ifndef SOAP_TYPE_tt__ObjectTree
#define SOAP_TYPE_tt__ObjectTree (769)
/* Type tt__ObjectTree is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectTree complex type: */
class SOAP_CMAC tt__ObjectTree : public xsd__anyType
{
public:
	std::vector<tt__Rename *> Rename;	/* optional element of XSD type tt:Rename */
	std::vector<tt__Split *> Split;	/* optional element of XSD type tt:Split */
	std::vector<tt__Merge *> Merge;	/* optional element of XSD type tt:Merge */
	std::vector<tt__ObjectId *> Delete;	/* optional element of XSD type tt:ObjectId */
	tt__ObjectTreeExtension *Extension;	/* optional element of XSD type tt:ObjectTreeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectTree (769)
	virtual int soap_type(void) const { return 769; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectTree, default initialized and not managed by a soap context
	virtual tt__ObjectTree *soap_alloc(void) const { return SOAP_NEW(tt__ObjectTree); }
	         tt__ObjectTree() { tt__ObjectTree::soap_default(NULL); }
	virtual ~tt__ObjectTree() { }
	friend tt__ObjectTree *soap_instantiate_tt__ObjectTree(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2031 */
#ifndef SOAP_TYPE_tt__ObjectTreeExtension
#define SOAP_TYPE_tt__ObjectTreeExtension (770)
/* Type tt__ObjectTreeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectTreeExtension complex type: */
class SOAP_CMAC tt__ObjectTreeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectTreeExtension (770)
	virtual int soap_type(void) const { return 770; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectTreeExtension, default initialized and not managed by a soap context
	virtual tt__ObjectTreeExtension *soap_alloc(void) const { return SOAP_NEW(tt__ObjectTreeExtension); }
	         tt__ObjectTreeExtension() { tt__ObjectTreeExtension::soap_default(NULL); }
	virtual ~tt__ObjectTreeExtension() { }
	friend tt__ObjectTreeExtension *soap_instantiate_tt__ObjectTreeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2034 */
#ifndef SOAP_TYPE_tt__MotionInCells
#define SOAP_TYPE_tt__MotionInCells (771)
/* Type tt__MotionInCells is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionInCells complex type: */
class SOAP_CMAC tt__MotionInCells : public xsd__anyType
{
public:
	std::vector<char *> __any;
	std::string Columns;	/* required attribute of XSD type xsd:integer */
	std::string Rows;	/* required attribute of XSD type xsd:integer */
	xsd__base64Binary Cells;	/* required attribute of XSD type xsd:base64Binary */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionInCells (771)
	virtual int soap_type(void) const { return 771; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionInCells, default initialized and not managed by a soap context
	virtual tt__MotionInCells *soap_alloc(void) const { return SOAP_NEW(tt__MotionInCells); }
	         tt__MotionInCells() { tt__MotionInCells::soap_default(NULL); }
	virtual ~tt__MotionInCells() { }
	friend tt__MotionInCells *soap_instantiate_tt__MotionInCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2037 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (772)
/* Type tt__AnalyticsEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__Config *> AnalyticsModule;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfiguration (772)
	virtual int soap_type(void) const { return 772; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfiguration); }
	         tt__AnalyticsEngineConfiguration() { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
	friend tt__AnalyticsEngineConfiguration *soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2040 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (773)
/* Type tt__AnalyticsEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (773)
	virtual int soap_type(void) const { return 773; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfigurationExtension); }
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
	friend tt__AnalyticsEngineConfigurationExtension *soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2043 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (774)
/* Type tt__RuleEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RuleEngineConfiguration complex type: */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__Config *> Rule;	/* optional element of XSD type tt:Config */
	tt__RuleEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:RuleEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfiguration (774)
	virtual int soap_type(void) const { return 774; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfiguration); }
	         tt__RuleEngineConfiguration() { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
	friend tt__RuleEngineConfiguration *soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2046 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (775)
/* Type tt__RuleEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RuleEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfigurationExtension (775)
	virtual int soap_type(void) const { return 775; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfigurationExtension); }
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
	friend tt__RuleEngineConfigurationExtension *soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2049 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (776)
/* Type tt__Config is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Config complex type: */
class SOAP_CMAC tt__Config : public xsd__anyType
{
public:
	tt__ItemList *Parameters;	/* required element of XSD type tt:ItemList */
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Config (776)
	virtual int soap_type(void) const { return 776; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Config, default initialized and not managed by a soap context
	virtual tt__Config *soap_alloc(void) const { return SOAP_NEW(tt__Config); }
	         tt__Config() { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
	friend tt__Config *soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:21425 */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (2015)
/* tt:ConfigDescription-Messages complex type: */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	std::string ParentTopic;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ConfigDescription_Messages (2015)
	virtual int soap_type(void) const { return 2015; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ConfigDescription_Messages, default initialized and not managed by a soap context
	virtual _tt__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW(_tt__ConfigDescription_Messages); }
	         _tt__ConfigDescription_Messages() { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
	friend _tt__ConfigDescription_Messages *soap_instantiate__tt__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2052 */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (777)
/* Type tt__ConfigDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigDescription complex type: */
class SOAP_CMAC tt__ConfigDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Parameters;	/* required element of XSD type tt:ItemListDescription */
	std::vector<_tt__ConfigDescription_Messages> *Messages;	/* optional element of XSD type tt:ConfigDescription-Messages */
	tt__ConfigDescriptionExtension *Extension;	/* optional element of XSD type tt:ConfigDescriptionExtension */
	std::string Name;	/* required attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescription (777)
	virtual int soap_type(void) const { return 777; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescription, default initialized and not managed by a soap context
	virtual tt__ConfigDescription *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescription); }
	         tt__ConfigDescription() { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
	friend tt__ConfigDescription *soap_instantiate_tt__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2055 */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (778)
/* Type tt__ConfigDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigDescriptionExtension complex type: */
class SOAP_CMAC tt__ConfigDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescriptionExtension (778)
	virtual int soap_type(void) const { return 778; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescriptionExtension); }
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
	friend tt__ConfigDescriptionExtension *soap_instantiate_tt__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2058 */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (779)
/* Type tt__SupportedRules is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedRules complex type: */
class SOAP_CMAC tt__SupportedRules : public xsd__anyType
{
public:
	std::vector<std::string> RuleContentSchemaLocation;	/* optional element of XSD type xsd:anyURI */
	std::vector<tt__ConfigDescription *> RuleDescription;	/* optional element of XSD type tt:ConfigDescription */
	tt__SupportedRulesExtension *Extension;	/* optional element of XSD type tt:SupportedRulesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRules (779)
	virtual int soap_type(void) const { return 779; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRules, default initialized and not managed by a soap context
	virtual tt__SupportedRules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRules); }
	         tt__SupportedRules() { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
	friend tt__SupportedRules *soap_instantiate_tt__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2061 */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (780)
/* Type tt__SupportedRulesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedRulesExtension complex type: */
class SOAP_CMAC tt__SupportedRulesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRulesExtension (780)
	virtual int soap_type(void) const { return 780; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRulesExtension); }
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
	friend tt__SupportedRulesExtension *soap_instantiate_tt__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2064 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (781)
/* Type tt__SupportedAnalyticsModules is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedAnalyticsModules complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModules : public xsd__anyType
{
public:
	std::vector<std::string> AnalyticsModuleContentSchemaLocation;	/* optional element of XSD type xsd:anyURI */
	std::vector<tt__ConfigDescription *> AnalyticsModuleDescription;	/* optional element of XSD type tt:ConfigDescription */
	tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of XSD type tt:SupportedAnalyticsModulesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModules (781)
	virtual int soap_type(void) const { return 781; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModules, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModules); }
	         tt__SupportedAnalyticsModules() { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
	friend tt__SupportedAnalyticsModules *soap_instantiate_tt__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2067 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (782)
/* Type tt__SupportedAnalyticsModulesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedAnalyticsModulesExtension complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (782)
	virtual int soap_type(void) const { return 782; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModulesExtension); }
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
	friend tt__SupportedAnalyticsModulesExtension *soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2070 */
#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (783)
/* Type tt__PolygonConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolygonConfiguration complex type: */
class SOAP_CMAC tt__PolygonConfiguration : public xsd__anyType
{
public:
	tt__Polygon *Polygon;	/* required element of XSD type tt:Polygon */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolygonConfiguration (783)
	virtual int soap_type(void) const { return 783; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolygonConfiguration, default initialized and not managed by a soap context
	virtual tt__PolygonConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolygonConfiguration); }
	         tt__PolygonConfiguration() { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
	friend tt__PolygonConfiguration *soap_instantiate_tt__PolygonConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2073 */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (784)
/* Type tt__PolylineArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArray complex type: */
class SOAP_CMAC tt__PolylineArray : public xsd__anyType
{
public:
	std::vector<tt__Polyline *> Segment;	/* required element of XSD type tt:Polyline */
	tt__PolylineArrayExtension *Extension;	/* optional element of XSD type tt:PolylineArrayExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArray (784)
	virtual int soap_type(void) const { return 784; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArray, default initialized and not managed by a soap context
	virtual tt__PolylineArray *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArray); }
	         tt__PolylineArray() { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
	friend tt__PolylineArray *soap_instantiate_tt__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2076 */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (785)
/* Type tt__PolylineArrayExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArrayExtension complex type: */
class SOAP_CMAC tt__PolylineArrayExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayExtension (785)
	virtual int soap_type(void) const { return 785; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayExtension, default initialized and not managed by a soap context
	virtual tt__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayExtension); }
	         tt__PolylineArrayExtension() { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
	friend tt__PolylineArrayExtension *soap_instantiate_tt__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2079 */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (786)
/* Type tt__PolylineArrayConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArrayConfiguration complex type: */
class SOAP_CMAC tt__PolylineArrayConfiguration : public xsd__anyType
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of XSD type tt:PolylineArray */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayConfiguration (786)
	virtual int soap_type(void) const { return 786; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayConfiguration, default initialized and not managed by a soap context
	virtual tt__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayConfiguration); }
	         tt__PolylineArrayConfiguration() { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
	friend tt__PolylineArrayConfiguration *soap_instantiate_tt__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2082 */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (787)
/* Type tt__MotionExpression is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionExpression complex type: */
class SOAP_CMAC tt__MotionExpression : public xsd__anyType
{
public:
	std::string Expression;	/* required element of XSD type xsd:string */
	std::vector<char *> __any;
	std::string *Type;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpression (787)
	virtual int soap_type(void) const { return 787; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpression, default initialized and not managed by a soap context
	virtual tt__MotionExpression *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpression); }
	         tt__MotionExpression() { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
	friend tt__MotionExpression *soap_instantiate_tt__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2085 */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (788)
/* Type tt__MotionExpressionConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionExpressionConfiguration complex type: */
class SOAP_CMAC tt__MotionExpressionConfiguration : public xsd__anyType
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of XSD type tt:MotionExpression */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpressionConfiguration (788)
	virtual int soap_type(void) const { return 788; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpressionConfiguration, default initialized and not managed by a soap context
	virtual tt__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpressionConfiguration); }
	         tt__MotionExpressionConfiguration() { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
	friend tt__MotionExpressionConfiguration *soap_instantiate_tt__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2088 */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (789)
/* Type tt__CellLayout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CellLayout complex type: */
class SOAP_CMAC tt__CellLayout : public xsd__anyType
{
public:
	tt__Transformation *Transformation;	/* required element of XSD type tt:Transformation */
	std::vector<char *> __any;
	std::string Columns;	/* required attribute of XSD type xsd:integer */
	std::string Rows;	/* required attribute of XSD type xsd:integer */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CellLayout (789)
	virtual int soap_type(void) const { return 789; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CellLayout, default initialized and not managed by a soap context
	virtual tt__CellLayout *soap_alloc(void) const { return SOAP_NEW(tt__CellLayout); }
	         tt__CellLayout() { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
	friend tt__CellLayout *soap_instantiate_tt__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:21885 */
#ifndef SOAP_TYPE__tt__union_MetadataStream
#define SOAP_TYPE__tt__union_MetadataStream (2033)
/* xsd:choice complex type: */
union _tt__union_MetadataStream
{
#define SOAP_UNION__tt__union_MetadataStream_VideoAnalytics	(1)
	tt__VideoAnalyticsStream *VideoAnalytics;
#define SOAP_UNION__tt__union_MetadataStream_PTZ	(2)
	tt__PTZStream *PTZ;
#define SOAP_UNION__tt__union_MetadataStream_Event	(3)
	tt__EventStream *Event;
#define SOAP_UNION__tt__union_MetadataStream_Extension	(4)
	tt__MetadataStreamExtension *Extension;
};
#endif

/* onvif.h:21872 */
#ifndef SOAP_TYPE___tt__union_MetadataStream
#define SOAP_TYPE___tt__union_MetadataStream (2028)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_MetadataStream
{
public:
	int __union_MetadataStream;	/* union discriminant (of union defined below) */
	union _tt__union_MetadataStream union_MetadataStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_MetadataStream (2028)
	virtual int soap_type(void) const { return 2028; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_MetadataStream, default initialized and not managed by a soap context
	virtual __tt__union_MetadataStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_MetadataStream); }
	         __tt__union_MetadataStream() { __tt__union_MetadataStream::soap_default(NULL); }
	virtual ~__tt__union_MetadataStream() { }
	friend __tt__union_MetadataStream *soap_instantiate___tt__union_MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2091 */
#ifndef SOAP_TYPE_tt__MetadataStream
#define SOAP_TYPE_tt__MetadataStream (790)
/* Type tt__MetadataStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataStream complex type: */
class SOAP_CMAC tt__MetadataStream : public xsd__anyType
{
public:
	int __size_MetadataStream;	/* sequence of elements <-union-MetadataStream> of XSD type -tt:union-MetadataStream */
	__tt__union_MetadataStream *__union_MetadataStream;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataStream (790)
	virtual int soap_type(void) const { return 790; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataStream, default initialized and not managed by a soap context
	virtual tt__MetadataStream *soap_alloc(void) const { return SOAP_NEW(tt__MetadataStream); }
	         tt__MetadataStream() { tt__MetadataStream::soap_default(NULL); }
	virtual ~tt__MetadataStream() { }
	friend tt__MetadataStream *soap_instantiate_tt__MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2094 */
#ifndef SOAP_TYPE_tt__MetadataStreamExtension
#define SOAP_TYPE_tt__MetadataStreamExtension (791)
/* Type tt__MetadataStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataStreamExtension complex type: */
class SOAP_CMAC tt__MetadataStreamExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	tt__AudioAnalyticsStream *AudioAnalyticsStream;	/* optional element of XSD type tt:AudioAnalyticsStream */
	tt__MetadataStreamExtension2 *Extension;	/* optional element of XSD type tt:MetadataStreamExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataStreamExtension (791)
	virtual int soap_type(void) const { return 791; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataStreamExtension, default initialized and not managed by a soap context
	virtual tt__MetadataStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataStreamExtension); }
	         tt__MetadataStreamExtension() { tt__MetadataStreamExtension::soap_default(NULL); }
	virtual ~tt__MetadataStreamExtension() { }
	friend tt__MetadataStreamExtension *soap_instantiate_tt__MetadataStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2097 */
#ifndef SOAP_TYPE_tt__MetadataStreamExtension2
#define SOAP_TYPE_tt__MetadataStreamExtension2 (792)
/* Type tt__MetadataStreamExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataStreamExtension2 complex type: */
class SOAP_CMAC tt__MetadataStreamExtension2 : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataStreamExtension2 (792)
	virtual int soap_type(void) const { return 792; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataStreamExtension2, default initialized and not managed by a soap context
	virtual tt__MetadataStreamExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__MetadataStreamExtension2); }
	         tt__MetadataStreamExtension2() { tt__MetadataStreamExtension2::soap_default(NULL); }
	virtual ~tt__MetadataStreamExtension2() { }
	friend tt__MetadataStreamExtension2 *soap_instantiate_tt__MetadataStreamExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2100 */
#ifndef SOAP_TYPE_tt__AudioAnalyticsStream
#define SOAP_TYPE_tt__AudioAnalyticsStream (793)
/* Type tt__AudioAnalyticsStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioAnalyticsStream complex type: */
class SOAP_CMAC tt__AudioAnalyticsStream : public xsd__anyType
{
public:
	std::vector<tt__AudioDescriptor *> AudioDescriptor;	/* optional element of XSD type tt:AudioDescriptor */
	tt__AudioAnalyticsStreamExtension *Extension;	/* optional element of XSD type tt:AudioAnalyticsStreamExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAnalyticsStream (793)
	virtual int soap_type(void) const { return 793; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAnalyticsStream, default initialized and not managed by a soap context
	virtual tt__AudioAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(tt__AudioAnalyticsStream); }
	         tt__AudioAnalyticsStream() { tt__AudioAnalyticsStream::soap_default(NULL); }
	virtual ~tt__AudioAnalyticsStream() { }
	friend tt__AudioAnalyticsStream *soap_instantiate_tt__AudioAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2103 */
#ifndef SOAP_TYPE_tt__AudioDescriptor
#define SOAP_TYPE_tt__AudioDescriptor (794)
/* Type tt__AudioDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDescriptor complex type: */
class SOAP_CMAC tt__AudioDescriptor : public xsd__anyType
{
public:
	std::vector<char *> __any;
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDescriptor (794)
	virtual int soap_type(void) const { return 794; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDescriptor, default initialized and not managed by a soap context
	virtual tt__AudioDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__AudioDescriptor); }
	         tt__AudioDescriptor() { tt__AudioDescriptor::soap_default(NULL); }
	virtual ~tt__AudioDescriptor() { }
	friend tt__AudioDescriptor *soap_instantiate_tt__AudioDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2106 */
#ifndef SOAP_TYPE_tt__AudioAnalyticsStreamExtension
#define SOAP_TYPE_tt__AudioAnalyticsStreamExtension (795)
/* Type tt__AudioAnalyticsStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioAnalyticsStreamExtension complex type: */
class SOAP_CMAC tt__AudioAnalyticsStreamExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAnalyticsStreamExtension (795)
	virtual int soap_type(void) const { return 795; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAnalyticsStreamExtension, default initialized and not managed by a soap context
	virtual tt__AudioAnalyticsStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioAnalyticsStreamExtension); }
	         tt__AudioAnalyticsStreamExtension() { tt__AudioAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~tt__AudioAnalyticsStreamExtension() { }
	friend tt__AudioAnalyticsStreamExtension *soap_instantiate_tt__AudioAnalyticsStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:22064 */
#ifndef SOAP_TYPE__tt__union_VideoAnalyticsStream
#define SOAP_TYPE__tt__union_VideoAnalyticsStream (2043)
/* xsd:choice complex type: */
union _tt__union_VideoAnalyticsStream
{
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Frame	(1)
	tt__Frame *Frame;
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Extension	(2)
	tt__VideoAnalyticsStreamExtension *Extension;
};
#endif

/* onvif.h:22054 */
#ifndef SOAP_TYPE___tt__union_VideoAnalyticsStream
#define SOAP_TYPE___tt__union_VideoAnalyticsStream (2040)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_VideoAnalyticsStream
{
public:
	int __union_VideoAnalyticsStream;	/* union discriminant (of union defined below) */
	union _tt__union_VideoAnalyticsStream union_VideoAnalyticsStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_VideoAnalyticsStream (2040)
	virtual int soap_type(void) const { return 2040; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_VideoAnalyticsStream, default initialized and not managed by a soap context
	virtual __tt__union_VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_VideoAnalyticsStream); }
	         __tt__union_VideoAnalyticsStream() { __tt__union_VideoAnalyticsStream::soap_default(NULL); }
	virtual ~__tt__union_VideoAnalyticsStream() { }
	friend __tt__union_VideoAnalyticsStream *soap_instantiate___tt__union_VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2109 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsStream
#define SOAP_TYPE_tt__VideoAnalyticsStream (796)
/* Type tt__VideoAnalyticsStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsStream complex type: */
class SOAP_CMAC tt__VideoAnalyticsStream : public xsd__anyType
{
public:
	int __size_VideoAnalyticsStream;	/* sequence of elements <-union-VideoAnalyticsStream> of XSD type -tt:union-VideoAnalyticsStream */
	__tt__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsStream (796)
	virtual int soap_type(void) const { return 796; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsStream, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsStream); }
	         tt__VideoAnalyticsStream() { tt__VideoAnalyticsStream::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStream() { }
	friend tt__VideoAnalyticsStream *soap_instantiate_tt__VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2112 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsStreamExtension
#define SOAP_TYPE_tt__VideoAnalyticsStreamExtension (797)
/* Type tt__VideoAnalyticsStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsStreamExtension complex type: */
class SOAP_CMAC tt__VideoAnalyticsStreamExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsStreamExtension (797)
	virtual int soap_type(void) const { return 797; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsStreamExtension, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsStreamExtension); }
	         tt__VideoAnalyticsStreamExtension() { tt__VideoAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStreamExtension() { }
	friend tt__VideoAnalyticsStreamExtension *soap_instantiate_tt__VideoAnalyticsStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:22118 */
#ifndef SOAP_TYPE__tt__union_PTZStream
#define SOAP_TYPE__tt__union_PTZStream (2047)
/* xsd:choice complex type: */
union _tt__union_PTZStream
{
#define SOAP_UNION__tt__union_PTZStream_PTZStatus	(1)
	tt__PTZStatus *PTZStatus;
#define SOAP_UNION__tt__union_PTZStream_Extension	(2)
	tt__PTZStreamExtension *Extension;
};
#endif

/* onvif.h:22108 */
#ifndef SOAP_TYPE___tt__union_PTZStream
#define SOAP_TYPE___tt__union_PTZStream (2045)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_PTZStream
{
public:
	int __union_PTZStream;	/* union discriminant (of union defined below) */
	union _tt__union_PTZStream union_PTZStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_PTZStream (2045)
	virtual int soap_type(void) const { return 2045; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_PTZStream, default initialized and not managed by a soap context
	virtual __tt__union_PTZStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_PTZStream); }
	         __tt__union_PTZStream() { __tt__union_PTZStream::soap_default(NULL); }
	virtual ~__tt__union_PTZStream() { }
	friend __tt__union_PTZStream *soap_instantiate___tt__union_PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2115 */
#ifndef SOAP_TYPE_tt__PTZStream
#define SOAP_TYPE_tt__PTZStream (798)
/* Type tt__PTZStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStream complex type: */
class SOAP_CMAC tt__PTZStream : public xsd__anyType
{
public:
	int __size_PTZStream;	/* sequence of elements <-union-PTZStream> of XSD type -tt:union-PTZStream */
	__tt__union_PTZStream *__union_PTZStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStream (798)
	virtual int soap_type(void) const { return 798; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStream, default initialized and not managed by a soap context
	virtual tt__PTZStream *soap_alloc(void) const { return SOAP_NEW(tt__PTZStream); }
	         tt__PTZStream() { tt__PTZStream::soap_default(NULL); }
	virtual ~tt__PTZStream() { }
	friend tt__PTZStream *soap_instantiate_tt__PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2118 */
#ifndef SOAP_TYPE_tt__PTZStreamExtension
#define SOAP_TYPE_tt__PTZStreamExtension (799)
/* Type tt__PTZStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStreamExtension complex type: */
class SOAP_CMAC tt__PTZStreamExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStreamExtension (799)
	virtual int soap_type(void) const { return 799; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStreamExtension, default initialized and not managed by a soap context
	virtual tt__PTZStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStreamExtension); }
	         tt__PTZStreamExtension() { tt__PTZStreamExtension::soap_default(NULL); }
	virtual ~tt__PTZStreamExtension() { }
	friend tt__PTZStreamExtension *soap_instantiate_tt__PTZStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:22172 */
#ifndef SOAP_TYPE__tt__union_EventStream
#define SOAP_TYPE__tt__union_EventStream (2052)
/* xsd:choice complex type: */
union _tt__union_EventStream
{
#define SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage	(1)
	wsnt__NotificationMessageHolderType *wsnt__NotificationMessage;
#define SOAP_UNION__tt__union_EventStream_Extension	(2)
	tt__EventStreamExtension *Extension;
};
#endif

/* onvif.h:22162 */
#ifndef SOAP_TYPE___tt__union_EventStream
#define SOAP_TYPE___tt__union_EventStream (2049)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_EventStream
{
public:
	int __union_EventStream;	/* union discriminant (of union defined below) */
	union _tt__union_EventStream union_EventStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_EventStream (2049)
	virtual int soap_type(void) const { return 2049; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_EventStream, default initialized and not managed by a soap context
	virtual __tt__union_EventStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_EventStream); }
	         __tt__union_EventStream() { __tt__union_EventStream::soap_default(NULL); }
	virtual ~__tt__union_EventStream() { }
	friend __tt__union_EventStream *soap_instantiate___tt__union_EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2121 */
#ifndef SOAP_TYPE_tt__EventStream
#define SOAP_TYPE_tt__EventStream (800)
/* Type tt__EventStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventStream complex type: */
class SOAP_CMAC tt__EventStream : public xsd__anyType
{
public:
	int __size_EventStream;	/* sequence of elements <-union-EventStream> of XSD type -tt:union-EventStream */
	__tt__union_EventStream *__union_EventStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventStream (800)
	virtual int soap_type(void) const { return 800; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventStream, default initialized and not managed by a soap context
	virtual tt__EventStream *soap_alloc(void) const { return SOAP_NEW(tt__EventStream); }
	         tt__EventStream() { tt__EventStream::soap_default(NULL); }
	virtual ~tt__EventStream() { }
	friend tt__EventStream *soap_instantiate_tt__EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2124 */
#ifndef SOAP_TYPE_tt__EventStreamExtension
#define SOAP_TYPE_tt__EventStreamExtension (801)
/* Type tt__EventStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventStreamExtension complex type: */
class SOAP_CMAC tt__EventStreamExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventStreamExtension (801)
	virtual int soap_type(void) const { return 801; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventStreamExtension, default initialized and not managed by a soap context
	virtual tt__EventStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__EventStreamExtension); }
	         tt__EventStreamExtension() { tt__EventStreamExtension::soap_default(NULL); }
	virtual ~tt__EventStreamExtension() { }
	friend tt__EventStreamExtension *soap_instantiate_tt__EventStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2127 */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (802)
/* Type tt__PaneConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneConfiguration complex type: */
class SOAP_CMAC tt__PaneConfiguration : public xsd__anyType
{
public:
	std::string *PaneName;	/* optional element of XSD type xsd:string */
	std::string *AudioOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *AudioSourceToken;	/* optional element of XSD type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	std::string *ReceiverToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneConfiguration (802)
	virtual int soap_type(void) const { return 802; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneConfiguration, default initialized and not managed by a soap context
	virtual tt__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PaneConfiguration); }
	         tt__PaneConfiguration() { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
	friend tt__PaneConfiguration *soap_instantiate_tt__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2130 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (803)
/* Type tt__PaneLayout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneLayout complex type: */
class SOAP_CMAC tt__PaneLayout : public xsd__anyType
{
public:
	std::string Pane;	/* required element of XSD type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of XSD type tt:Rectangle */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayout (803)
	virtual int soap_type(void) const { return 803; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
	virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayout); }
	         tt__PaneLayout() { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
	friend tt__PaneLayout *soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2133 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (804)
/* Type tt__Layout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Layout complex type: */
class SOAP_CMAC tt__Layout : public xsd__anyType
{
public:
	std::vector<tt__PaneLayout *> PaneLayout;	/* required element of XSD type tt:PaneLayout */
	tt__LayoutExtension *Extension;	/* optional element of XSD type tt:LayoutExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Layout (804)
	virtual int soap_type(void) const { return 804; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Layout, default initialized and not managed by a soap context
	virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW(tt__Layout); }
	         tt__Layout() { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
	friend tt__Layout *soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2136 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (805)
/* Type tt__LayoutExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutExtension complex type: */
class SOAP_CMAC tt__LayoutExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutExtension (805)
	virtual int soap_type(void) const { return 805; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
	virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutExtension); }
	         tt__LayoutExtension() { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
	friend tt__LayoutExtension *soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2139 */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (806)
/* Type tt__CodingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CodingCapabilities complex type: */
class SOAP_CMAC tt__CodingCapabilities : public xsd__anyType
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of XSD type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of XSD type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of XSD type tt:VideoDecoderConfigurationOptions */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CodingCapabilities (806)
	virtual int soap_type(void) const { return 806; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CodingCapabilities, default initialized and not managed by a soap context
	virtual tt__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__CodingCapabilities); }
	         tt__CodingCapabilities() { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
	friend tt__CodingCapabilities *soap_instantiate_tt__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2142 */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (807)
/* Type tt__LayoutOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutOptions complex type: */
class SOAP_CMAC tt__LayoutOptions : public xsd__anyType
{
public:
	std::vector<tt__PaneLayoutOptions *> PaneLayoutOptions;	/* required element of XSD type tt:PaneLayoutOptions */
	tt__LayoutOptionsExtension *Extension;	/* optional element of XSD type tt:LayoutOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptions (807)
	virtual int soap_type(void) const { return 807; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptions, default initialized and not managed by a soap context
	virtual tt__LayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptions); }
	         tt__LayoutOptions() { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
	friend tt__LayoutOptions *soap_instantiate_tt__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2145 */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (808)
/* Type tt__LayoutOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutOptionsExtension complex type: */
class SOAP_CMAC tt__LayoutOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptionsExtension (808)
	virtual int soap_type(void) const { return 808; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptionsExtension, default initialized and not managed by a soap context
	virtual tt__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptionsExtension); }
	         tt__LayoutOptionsExtension() { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
	friend tt__LayoutOptionsExtension *soap_instantiate_tt__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2148 */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (809)
/* Type tt__PaneLayoutOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneLayoutOptions complex type: */
class SOAP_CMAC tt__PaneLayoutOptions : public xsd__anyType
{
public:
	std::vector<tt__Rectangle *> Area;	/* required element of XSD type tt:Rectangle */
	tt__PaneOptionExtension *Extension;	/* optional element of XSD type tt:PaneOptionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayoutOptions (809)
	virtual int soap_type(void) const { return 809; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayoutOptions, default initialized and not managed by a soap context
	virtual tt__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayoutOptions); }
	         tt__PaneLayoutOptions() { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
	friend tt__PaneLayoutOptions *soap_instantiate_tt__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2151 */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (810)
/* Type tt__PaneOptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneOptionExtension complex type: */
class SOAP_CMAC tt__PaneOptionExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneOptionExtension (810)
	virtual int soap_type(void) const { return 810; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneOptionExtension, default initialized and not managed by a soap context
	virtual tt__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PaneOptionExtension); }
	         tt__PaneOptionExtension() { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
	friend tt__PaneOptionExtension *soap_instantiate_tt__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2154 */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (811)
/* Type tt__Receiver is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Receiver complex type: */
class SOAP_CMAC tt__Receiver : public xsd__anyType
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Receiver (811)
	virtual int soap_type(void) const { return 811; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Receiver, default initialized and not managed by a soap context
	virtual tt__Receiver *soap_alloc(void) const { return SOAP_NEW(tt__Receiver); }
	         tt__Receiver() { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
	friend tt__Receiver *soap_instantiate_tt__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2157 */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (812)
/* Type tt__ReceiverConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverConfiguration complex type: */
class SOAP_CMAC tt__ReceiverConfiguration : public xsd__anyType
{
public:
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	std::string MediaUri;	/* required element of XSD type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverConfiguration (812)
	virtual int soap_type(void) const { return 812; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverConfiguration, default initialized and not managed by a soap context
	virtual tt__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverConfiguration); }
	         tt__ReceiverConfiguration() { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
	friend tt__ReceiverConfiguration *soap_instantiate_tt__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2160 */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (813)
/* Type tt__ReceiverStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverStateInformation complex type: */
class SOAP_CMAC tt__ReceiverStateInformation : public xsd__anyType
{
public:
	enum tt__ReceiverState State;	/* required element of XSD type tt:ReceiverState */
	bool AutoCreated;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverStateInformation (813)
	virtual int soap_type(void) const { return 813; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverStateInformation, default initialized and not managed by a soap context
	virtual tt__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverStateInformation); }
	         tt__ReceiverStateInformation() { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
	friend tt__ReceiverStateInformation *soap_instantiate_tt__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2163 */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (814)
/* Type tt__SourceReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceReference complex type: */
class SOAP_CMAC tt__SourceReference : public xsd__anyType
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	std::string Type;	/* optional attribute of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceReference (814)
	virtual int soap_type(void) const { return 814; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceReference, default initialized and not managed by a soap context
	virtual tt__SourceReference *soap_alloc(void) const { return SOAP_NEW(tt__SourceReference); }
	         tt__SourceReference() { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
	friend tt__SourceReference *soap_instantiate_tt__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2166 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (815)
/* Type tt__DateTimeRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DateTimeRange complex type: */
class SOAP_CMAC tt__DateTimeRange : public xsd__anyType
{
public:
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTimeRange (815)
	virtual int soap_type(void) const { return 815; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
	virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW(tt__DateTimeRange); }
	         tt__DateTimeRange() { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
	friend tt__DateTimeRange *soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2169 */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (816)
/* Type tt__RecordingSummary is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingSummary complex type: */
class SOAP_CMAC tt__RecordingSummary : public xsd__anyType
{
public:
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataUntil;	/* required element of XSD type xsd:dateTime */
	int NumberRecordings;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSummary (816)
	virtual int soap_type(void) const { return 816; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSummary, default initialized and not managed by a soap context
	virtual tt__RecordingSummary *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSummary); }
	         tt__RecordingSummary() { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
	friend tt__RecordingSummary *soap_instantiate_tt__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2172 */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (817)
/* Type tt__SearchScope is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchScope complex type: */
class SOAP_CMAC tt__SearchScope : public xsd__anyType
{
public:
	std::vector<tt__SourceReference *> IncludedSources;	/* optional element of XSD type tt:SourceReference */
	std::vector<std::string> IncludedRecordings;	/* optional element of XSD type tt:RecordingReference */
	std::string *RecordingInformationFilter;	/* optional element of XSD type tt:XPathExpression */
	tt__SearchScopeExtension *Extension;	/* optional element of XSD type tt:SearchScopeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScope (817)
	virtual int soap_type(void) const { return 817; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScope, default initialized and not managed by a soap context
	virtual tt__SearchScope *soap_alloc(void) const { return SOAP_NEW(tt__SearchScope); }
	         tt__SearchScope() { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
	friend tt__SearchScope *soap_instantiate_tt__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2175 */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (818)
/* Type tt__SearchScopeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchScopeExtension complex type: */
class SOAP_CMAC tt__SearchScopeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScopeExtension (818)
	virtual int soap_type(void) const { return 818; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScopeExtension, default initialized and not managed by a soap context
	virtual tt__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SearchScopeExtension); }
	         tt__SearchScopeExtension() { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
	friend tt__SearchScopeExtension *soap_instantiate_tt__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2181 */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (820)
/* Type tt__PTZPositionFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPositionFilter complex type: */
class SOAP_CMAC tt__PTZPositionFilter : public xsd__anyType
{
public:
	tt__PTZVector *MinPosition;	/* required element of XSD type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of XSD type tt:PTZVector */
	bool EnterOrExit;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPositionFilter (820)
	virtual int soap_type(void) const { return 820; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPositionFilter, default initialized and not managed by a soap context
	virtual tt__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZPositionFilter); }
	         tt__PTZPositionFilter() { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
	friend tt__PTZPositionFilter *soap_instantiate_tt__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2184 */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (821)
/* Type tt__MetadataFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataFilter complex type: */
class SOAP_CMAC tt__MetadataFilter : public xsd__anyType
{
public:
	std::string MetadataStreamFilter;	/* required element of XSD type tt:XPathExpression */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataFilter (821)
	virtual int soap_type(void) const { return 821; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataFilter, default initialized and not managed by a soap context
	virtual tt__MetadataFilter *soap_alloc(void) const { return SOAP_NEW(tt__MetadataFilter); }
	         tt__MetadataFilter() { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
	friend tt__MetadataFilter *soap_instantiate_tt__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2187 */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (822)
/* Type tt__FindRecordingResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindRecordingResultList complex type: */
class SOAP_CMAC tt__FindRecordingResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__RecordingInformation *> RecordingInformation;	/* optional element of XSD type tt:RecordingInformation */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindRecordingResultList (822)
	virtual int soap_type(void) const { return 822; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindRecordingResultList, default initialized and not managed by a soap context
	virtual tt__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindRecordingResultList); }
	         tt__FindRecordingResultList() { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
	friend tt__FindRecordingResultList *soap_instantiate_tt__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2190 */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (823)
/* Type tt__FindEventResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindEventResultList complex type: */
class SOAP_CMAC tt__FindEventResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindEventResult *> Result;	/* optional element of XSD type tt:FindEventResult */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResultList (823)
	virtual int soap_type(void) const { return 823; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResultList, default initialized and not managed by a soap context
	virtual tt__FindEventResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResultList); }
	         tt__FindEventResultList() { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
	friend tt__FindEventResultList *soap_instantiate_tt__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2193 */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (824)
/* Type tt__FindEventResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindEventResult complex type: */
class SOAP_CMAC tt__FindEventResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	wsnt__NotificationMessageHolderType *Event;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResult (824)
	virtual int soap_type(void) const { return 824; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResult, default initialized and not managed by a soap context
	virtual tt__FindEventResult *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResult); }
	         tt__FindEventResult() { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
	friend tt__FindEventResult *soap_instantiate_tt__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2196 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (825)
/* Type tt__FindPTZPositionResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindPTZPositionResultList complex type: */
class SOAP_CMAC tt__FindPTZPositionResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindPTZPositionResult *> Result;	/* optional element of XSD type tt:FindPTZPositionResult */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResultList (825)
	virtual int soap_type(void) const { return 825; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResultList, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResultList); }
	         tt__FindPTZPositionResultList() { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
	friend tt__FindPTZPositionResultList *soap_instantiate_tt__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2199 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (826)
/* Type tt__FindPTZPositionResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindPTZPositionResult complex type: */
class SOAP_CMAC tt__FindPTZPositionResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResult (826)
	virtual int soap_type(void) const { return 826; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResult, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResult); }
	         tt__FindPTZPositionResult() { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
	friend tt__FindPTZPositionResult *soap_instantiate_tt__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2202 */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (827)
/* Type tt__FindMetadataResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindMetadataResultList complex type: */
class SOAP_CMAC tt__FindMetadataResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindMetadataResult *> Result;	/* optional element of XSD type tt:FindMetadataResult */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResultList (827)
	virtual int soap_type(void) const { return 827; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResultList, default initialized and not managed by a soap context
	virtual tt__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResultList); }
	         tt__FindMetadataResultList() { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
	friend tt__FindMetadataResultList *soap_instantiate_tt__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2205 */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (828)
/* Type tt__FindMetadataResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindMetadataResult complex type: */
class SOAP_CMAC tt__FindMetadataResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResult (828)
	virtual int soap_type(void) const { return 828; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResult, default initialized and not managed by a soap context
	virtual tt__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResult); }
	         tt__FindMetadataResult() { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
	friend tt__FindMetadataResult *soap_instantiate_tt__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2208 */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (829)
/* Type tt__RecordingInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingInformation complex type: */
class SOAP_CMAC tt__RecordingInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of XSD type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of XSD type xsd:dateTime */
	std::string Content;	/* required element of XSD type tt:Description */
	std::vector<tt__TrackInformation *> Track;	/* optional element of XSD type tt:TrackInformation */
	enum tt__RecordingStatus RecordingStatus;	/* required element of XSD type tt:RecordingStatus */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingInformation (829)
	virtual int soap_type(void) const { return 829; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingInformation, default initialized and not managed by a soap context
	virtual tt__RecordingInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingInformation); }
	         tt__RecordingInformation() { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
	friend tt__RecordingInformation *soap_instantiate_tt__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2211 */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (830)
/* Type tt__RecordingSourceInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingSourceInformation complex type: */
class SOAP_CMAC tt__RecordingSourceInformation : public xsd__anyType
{
public:
	std::string SourceId;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type tt:Name */
	std::string Location;	/* required element of XSD type tt:Description */
	std::string Description;	/* required element of XSD type tt:Description */
	std::string Address;	/* required element of XSD type xsd:anyURI */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSourceInformation (830)
	virtual int soap_type(void) const { return 830; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSourceInformation, default initialized and not managed by a soap context
	virtual tt__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSourceInformation); }
	         tt__RecordingSourceInformation() { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
	friend tt__RecordingSourceInformation *soap_instantiate_tt__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2214 */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (831)
/* Type tt__TrackInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackInformation complex type: */
class SOAP_CMAC tt__TrackInformation : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	std::string Description;	/* required element of XSD type tt:Description */
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataTo;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackInformation (831)
	virtual int soap_type(void) const { return 831; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackInformation, default initialized and not managed by a soap context
	virtual tt__TrackInformation *soap_alloc(void) const { return SOAP_NEW(tt__TrackInformation); }
	         tt__TrackInformation() { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
	friend tt__TrackInformation *soap_instantiate_tt__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2217 */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (832)
/* Type tt__MediaAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaAttributes complex type: */
class SOAP_CMAC tt__MediaAttributes : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::vector<tt__TrackAttributes *> TrackAttributes;	/* optional element of XSD type tt:TrackAttributes */
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaAttributes (832)
	virtual int soap_type(void) const { return 832; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaAttributes, default initialized and not managed by a soap context
	virtual tt__MediaAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MediaAttributes); }
	         tt__MediaAttributes() { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
	friend tt__MediaAttributes *soap_instantiate_tt__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2220 */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (833)
/* Type tt__TrackAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackAttributes complex type: */
class SOAP_CMAC tt__TrackAttributes : public xsd__anyType
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of XSD type tt:TrackInformation */
	tt__VideoAttributes *VideoAttributes;	/* optional element of XSD type tt:VideoAttributes */
	tt__AudioAttributes *AudioAttributes;	/* optional element of XSD type tt:AudioAttributes */
	tt__MetadataAttributes *MetadataAttributes;	/* optional element of XSD type tt:MetadataAttributes */
	tt__TrackAttributesExtension *Extension;	/* optional element of XSD type tt:TrackAttributesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributes (833)
	virtual int soap_type(void) const { return 833; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributes, default initialized and not managed by a soap context
	virtual tt__TrackAttributes *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributes); }
	         tt__TrackAttributes() { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
	friend tt__TrackAttributes *soap_instantiate_tt__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2223 */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (834)
/* Type tt__TrackAttributesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackAttributesExtension complex type: */
class SOAP_CMAC tt__TrackAttributesExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributesExtension (834)
	virtual int soap_type(void) const { return 834; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributesExtension, default initialized and not managed by a soap context
	virtual tt__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributesExtension); }
	         tt__TrackAttributesExtension() { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
	friend tt__TrackAttributesExtension *soap_instantiate_tt__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2226 */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (835)
/* Type tt__VideoAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAttributes complex type: */
class SOAP_CMAC tt__VideoAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	float Framerate;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAttributes (835)
	virtual int soap_type(void) const { return 835; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAttributes, default initialized and not managed by a soap context
	virtual tt__VideoAttributes *soap_alloc(void) const { return SOAP_NEW(tt__VideoAttributes); }
	         tt__VideoAttributes() { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
	friend tt__VideoAttributes *soap_instantiate_tt__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2229 */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (836)
/* Type tt__AudioAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioAttributes complex type: */
class SOAP_CMAC tt__AudioAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Samplerate;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAttributes (836)
	virtual int soap_type(void) const { return 836; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAttributes, default initialized and not managed by a soap context
	virtual tt__AudioAttributes *soap_alloc(void) const { return SOAP_NEW(tt__AudioAttributes); }
	         tt__AudioAttributes() { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
	friend tt__AudioAttributes *soap_instantiate_tt__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2232 */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (837)
/* Type tt__MetadataAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataAttributes complex type: */
class SOAP_CMAC tt__MetadataAttributes : public xsd__anyType
{
public:
	bool CanContainPTZ;	/* required element of XSD type xsd:boolean */
	bool CanContainAnalytics;	/* required element of XSD type xsd:boolean */
	bool CanContainNotifications;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	std::string *PtzSpaces;	/* optional attribute of XSD type tt:StringAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataAttributes (837)
	virtual int soap_type(void) const { return 837; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataAttributes, default initialized and not managed by a soap context
	virtual tt__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MetadataAttributes); }
	         tt__MetadataAttributes() { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
	friend tt__MetadataAttributes *soap_instantiate_tt__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2235 */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (838)
/* Type tt__RecordingConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingConfiguration complex type: */
class SOAP_CMAC tt__RecordingConfiguration : public xsd__anyType
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	std::string Content;	/* required element of XSD type tt:Description */
	LONG64 MaximumRetentionTime;	/* external (custom serializer) */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingConfiguration (838)
	virtual int soap_type(void) const { return 838; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingConfiguration); }
	         tt__RecordingConfiguration() { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
	friend tt__RecordingConfiguration *soap_instantiate_tt__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2238 */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (839)
/* Type tt__TrackConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackConfiguration complex type: */
class SOAP_CMAC tt__TrackConfiguration : public xsd__anyType
{
public:
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	std::string Description;	/* required element of XSD type tt:Description */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackConfiguration (839)
	virtual int soap_type(void) const { return 839; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackConfiguration, default initialized and not managed by a soap context
	virtual tt__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TrackConfiguration); }
	         tt__TrackConfiguration() { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
	friend tt__TrackConfiguration *soap_instantiate_tt__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2241 */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (840)
/* Type tt__GetRecordingsResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetRecordingsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingsResponseItem : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of XSD type tt:RecordingConfiguration */
	tt__GetTracksResponseList *Tracks;	/* required element of XSD type tt:GetTracksResponseList */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingsResponseItem (840)
	virtual int soap_type(void) const { return 840; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingsResponseItem); }
	         tt__GetRecordingsResponseItem() { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
	friend tt__GetRecordingsResponseItem *soap_instantiate_tt__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2244 */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (841)
/* Type tt__GetTracksResponseList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetTracksResponseList complex type: */
class SOAP_CMAC tt__GetTracksResponseList : public xsd__anyType
{
public:
	std::vector<tt__GetTracksResponseItem *> Track;	/* optional element of XSD type tt:GetTracksResponseItem */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseList (841)
	virtual int soap_type(void) const { return 841; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseList, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseList); }
	         tt__GetTracksResponseList() { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
	friend tt__GetTracksResponseList *soap_instantiate_tt__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2247 */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (842)
/* Type tt__GetTracksResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetTracksResponseItem complex type: */
class SOAP_CMAC tt__GetTracksResponseItem : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of XSD type tt:TrackConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseItem (842)
	virtual int soap_type(void) const { return 842; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseItem, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseItem); }
	         tt__GetTracksResponseItem() { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
	friend tt__GetTracksResponseItem *soap_instantiate_tt__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2250 */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (843)
/* Type tt__RecordingJobConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobConfiguration complex type: */
class SOAP_CMAC tt__RecordingJobConfiguration : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string Mode;	/* required element of XSD type tt:RecordingJobMode */
	int Priority;	/* required element of XSD type xsd:int */
	std::vector<tt__RecordingJobSource *> Source;	/* optional element of XSD type tt:RecordingJobSource */
	tt__RecordingJobConfigurationExtension *Extension;	/* optional element of XSD type tt:RecordingJobConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfiguration (843)
	virtual int soap_type(void) const { return 843; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfiguration); }
	         tt__RecordingJobConfiguration() { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
	friend tt__RecordingJobConfiguration *soap_instantiate_tt__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2253 */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (844)
/* Type tt__RecordingJobConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobConfigurationExtension complex type: */
class SOAP_CMAC tt__RecordingJobConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfigurationExtension (844)
	virtual int soap_type(void) const { return 844; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfigurationExtension); }
	         tt__RecordingJobConfigurationExtension() { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
	friend tt__RecordingJobConfigurationExtension *soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2256 */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (845)
/* Type tt__RecordingJobSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobSource complex type: */
class SOAP_CMAC tt__RecordingJobSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* optional element of XSD type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__RecordingJobTrack *> Tracks;	/* optional element of XSD type tt:RecordingJobTrack */
	tt__RecordingJobSourceExtension *Extension;	/* optional element of XSD type tt:RecordingJobSourceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSource (845)
	virtual int soap_type(void) const { return 845; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSource); }
	         tt__RecordingJobSource() { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
	friend tt__RecordingJobSource *soap_instantiate_tt__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2259 */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (846)
/* Type tt__RecordingJobSourceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobSourceExtension complex type: */
class SOAP_CMAC tt__RecordingJobSourceExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSourceExtension (846)
	virtual int soap_type(void) const { return 846; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSourceExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSourceExtension); }
	         tt__RecordingJobSourceExtension() { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
	friend tt__RecordingJobSourceExtension *soap_instantiate_tt__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2262 */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (847)
/* Type tt__RecordingJobTrack is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobTrack complex type: */
class SOAP_CMAC tt__RecordingJobTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of XSD type xsd:string */
	std::string Destination;	/* required element of XSD type tt:TrackReference */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobTrack (847)
	virtual int soap_type(void) const { return 847; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobTrack); }
	         tt__RecordingJobTrack() { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
	friend tt__RecordingJobTrack *soap_instantiate_tt__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2265 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (848)
/* Type tt__RecordingJobStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateInformation complex type: */
class SOAP_CMAC tt__RecordingJobStateInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	std::vector<tt__RecordingJobStateSource *> Sources;	/* optional element of XSD type tt:RecordingJobStateSource */
	tt__RecordingJobStateInformationExtension *Extension;	/* optional element of XSD type tt:RecordingJobStateInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformation (848)
	virtual int soap_type(void) const { return 848; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformation, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformation); }
	         tt__RecordingJobStateInformation() { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
	friend tt__RecordingJobStateInformation *soap_instantiate_tt__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2268 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (849)
/* Type tt__RecordingJobStateInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateInformationExtension complex type: */
class SOAP_CMAC tt__RecordingJobStateInformationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformationExtension (849)
	virtual int soap_type(void) const { return 849; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformationExtension); }
	         tt__RecordingJobStateInformationExtension() { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
	friend tt__RecordingJobStateInformationExtension *soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2271 */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (850)
/* Type tt__RecordingJobStateSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateSource complex type: */
class SOAP_CMAC tt__RecordingJobStateSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* required element of XSD type tt:SourceReference */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	tt__RecordingJobStateTracks *Tracks;	/* required element of XSD type tt:RecordingJobStateTracks */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateSource (850)
	virtual int soap_type(void) const { return 850; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateSource); }
	         tt__RecordingJobStateSource() { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
	friend tt__RecordingJobStateSource *soap_instantiate_tt__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2274 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (851)
/* Type tt__RecordingJobStateTracks is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateTracks complex type: */
class SOAP_CMAC tt__RecordingJobStateTracks : public xsd__anyType
{
public:
	std::vector<tt__RecordingJobStateTrack *> Track;	/* optional element of XSD type tt:RecordingJobStateTrack */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTracks (851)
	virtual int soap_type(void) const { return 851; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTracks, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTracks); }
	         tt__RecordingJobStateTracks() { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
	friend tt__RecordingJobStateTracks *soap_instantiate_tt__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2277 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (852)
/* Type tt__RecordingJobStateTrack is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateTrack complex type: */
class SOAP_CMAC tt__RecordingJobStateTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of XSD type xsd:string */
	std::string Destination;	/* required element of XSD type tt:TrackReference */
	std::string *Error;	/* optional element of XSD type xsd:string */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTrack (852)
	virtual int soap_type(void) const { return 852; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTrack); }
	         tt__RecordingJobStateTrack() { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
	friend tt__RecordingJobStateTrack *soap_instantiate_tt__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2280 */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (853)
/* Type tt__GetRecordingJobsResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetRecordingJobsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingJobsResponseItem : public xsd__anyType
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingJobsResponseItem (853)
	virtual int soap_type(void) const { return 853; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingJobsResponseItem); }
	         tt__GetRecordingJobsResponseItem() { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
	friend tt__GetRecordingJobsResponseItem *soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2283 */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (854)
/* Type tt__ReplayConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReplayConfiguration complex type: */
class SOAP_CMAC tt__ReplayConfiguration : public xsd__anyType
{
public:
	LONG64 SessionTimeout;	/* external (custom serializer) */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayConfiguration (854)
	virtual int soap_type(void) const { return 854; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayConfiguration, default initialized and not managed by a soap context
	virtual tt__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReplayConfiguration); }
	         tt__ReplayConfiguration() { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
	friend tt__ReplayConfiguration *soap_instantiate_tt__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2289 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (856)
/* Type tt__AnalyticsDeviceEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__EngineConfiguration *> EngineConfiguration;	/* required element of XSD type tt:EngineConfiguration */
	tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (856)
	virtual int soap_type(void) const { return 856; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfiguration); }
	         tt__AnalyticsDeviceEngineConfiguration() { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
	friend tt__AnalyticsDeviceEngineConfiguration *soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2292 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (857)
/* Type tt__AnalyticsDeviceEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (857)
	virtual int soap_type(void) const { return 857; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfigurationExtension); }
	         tt__AnalyticsDeviceEngineConfigurationExtension() { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
	friend tt__AnalyticsDeviceEngineConfigurationExtension *soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2295 */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (858)
/* Type tt__EngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EngineConfiguration complex type: */
class SOAP_CMAC tt__EngineConfiguration : public xsd__anyType
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of XSD type tt:AnalyticsEngineInputInfo */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EngineConfiguration (858)
	virtual int soap_type(void) const { return 858; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EngineConfiguration, default initialized and not managed by a soap context
	virtual tt__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EngineConfiguration); }
	         tt__EngineConfiguration() { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
	friend tt__EngineConfiguration *soap_instantiate_tt__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2298 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (859)
/* Type tt__AnalyticsEngineInputInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInputInfo complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfo : public xsd__anyType
{
public:
	tt__Config *InputInfo;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineInputInfoExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfo (859)
	virtual int soap_type(void) const { return 859; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfo); }
	         tt__AnalyticsEngineInputInfo() { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
	friend tt__AnalyticsEngineInputInfo *soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2301 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (860)
/* Type tt__AnalyticsEngineInputInfoExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInputInfoExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (860)
	virtual int soap_type(void) const { return 860; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfoExtension); }
	         tt__AnalyticsEngineInputInfoExtension() { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
	friend tt__AnalyticsEngineInputInfoExtension *soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2307 */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (862)
/* Type tt__SourceIdentification is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceIdentification complex type: */
class SOAP_CMAC tt__SourceIdentification : public xsd__anyType
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	std::vector<std::string> Token;	/* required element of XSD type tt:ReferenceToken */
	tt__SourceIdentificationExtension *Extension;	/* optional element of XSD type tt:SourceIdentificationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentification (862)
	virtual int soap_type(void) const { return 862; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentification, default initialized and not managed by a soap context
	virtual tt__SourceIdentification *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentification); }
	         tt__SourceIdentification() { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
	friend tt__SourceIdentification *soap_instantiate_tt__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2310 */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (863)
/* Type tt__SourceIdentificationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceIdentificationExtension complex type: */
class SOAP_CMAC tt__SourceIdentificationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentificationExtension (863)
	virtual int soap_type(void) const { return 863; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentificationExtension, default initialized and not managed by a soap context
	virtual tt__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentificationExtension); }
	         tt__SourceIdentificationExtension() { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
	friend tt__SourceIdentificationExtension *soap_instantiate_tt__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2313 */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (864)
/* Type tt__MetadataInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataInput complex type: */
class SOAP_CMAC tt__MetadataInput : public xsd__anyType
{
public:
	std::vector<tt__Config *> MetadataConfig;	/* optional element of XSD type tt:Config */
	tt__MetadataInputExtension *Extension;	/* optional element of XSD type tt:MetadataInputExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInput (864)
	virtual int soap_type(void) const { return 864; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInput, default initialized and not managed by a soap context
	virtual tt__MetadataInput *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInput); }
	         tt__MetadataInput() { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
	friend tt__MetadataInput *soap_instantiate_tt__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2316 */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (865)
/* Type tt__MetadataInputExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataInputExtension complex type: */
class SOAP_CMAC tt__MetadataInputExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInputExtension (865)
	virtual int soap_type(void) const { return 865; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInputExtension, default initialized and not managed by a soap context
	virtual tt__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInputExtension); }
	         tt__MetadataInputExtension() { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
	friend tt__MetadataInputExtension *soap_instantiate_tt__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2322 */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (867)
/* Type tt__AnalyticsStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsStateInformation complex type: */
class SOAP_CMAC tt__AnalyticsStateInformation : public xsd__anyType
{
public:
	std::string AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	tt__AnalyticsState *State;	/* required element of XSD type tt:AnalyticsState */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsStateInformation (867)
	virtual int soap_type(void) const { return 867; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsStateInformation, default initialized and not managed by a soap context
	virtual tt__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsStateInformation); }
	         tt__AnalyticsStateInformation() { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
	friend tt__AnalyticsStateInformation *soap_instantiate_tt__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2325 */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (868)
/* Type tt__AnalyticsState is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsState complex type: */
class SOAP_CMAC tt__AnalyticsState : public xsd__anyType
{
public:
	std::string *Error;	/* optional element of XSD type xsd:string */
	std::string State;	/* required element of XSD type xsd:string */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsState (868)
	virtual int soap_type(void) const { return 868; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsState, default initialized and not managed by a soap context
	virtual tt__AnalyticsState *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsState); }
	         tt__AnalyticsState() { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
	friend tt__AnalyticsState *soap_instantiate_tt__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2328 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (869)
/* Type tt__ActionEngineEventPayload is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ActionEngineEventPayload complex type: */
class SOAP_CMAC tt__ActionEngineEventPayload : public xsd__anyType
{
public:
	struct SOAP_ENV__Envelope *RequestInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Envelope *ResponseInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of XSD type SOAP-ENV:Fault */
	tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of XSD type tt:ActionEngineEventPayloadExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayload (869)
	virtual int soap_type(void) const { return 869; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayload, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayload); }
	         tt__ActionEngineEventPayload() { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
	friend tt__ActionEngineEventPayload *soap_instantiate_tt__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2331 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (870)
/* Type tt__ActionEngineEventPayloadExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ActionEngineEventPayloadExtension complex type: */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayloadExtension (870)
	virtual int soap_type(void) const { return 870; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayloadExtension); }
	         tt__ActionEngineEventPayloadExtension() { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
	friend tt__ActionEngineEventPayloadExtension *soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2334 */
#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (871)
/* Type tt__AudioClassCandidate is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioClassCandidate complex type: */
class SOAP_CMAC tt__AudioClassCandidate : public xsd__anyType
{
public:
	std::string Type;	/* required element of XSD type tt:AudioClassType */
	float Likelihood;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassCandidate (871)
	virtual int soap_type(void) const { return 871; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassCandidate, default initialized and not managed by a soap context
	virtual tt__AudioClassCandidate *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassCandidate); }
	         tt__AudioClassCandidate() { tt__AudioClassCandidate::soap_default(NULL); }
	virtual ~tt__AudioClassCandidate() { }
	friend tt__AudioClassCandidate *soap_instantiate_tt__AudioClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2337 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (872)
/* Type tt__AudioClassDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioClassDescriptor complex type: */
class SOAP_CMAC tt__AudioClassDescriptor : public xsd__anyType
{
public:
	std::vector<tt__AudioClassCandidate *> ClassCandidate;	/* optional element of XSD type tt:AudioClassCandidate */
	tt__AudioClassDescriptorExtension *Extension;	/* optional element of XSD type tt:AudioClassDescriptorExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptor (872)
	virtual int soap_type(void) const { return 872; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptor, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptor); }
	         tt__AudioClassDescriptor() { tt__AudioClassDescriptor::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptor() { }
	friend tt__AudioClassDescriptor *soap_instantiate_tt__AudioClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2340 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (873)
/* Type tt__AudioClassDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioClassDescriptorExtension complex type: */
class SOAP_CMAC tt__AudioClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptorExtension (873)
	virtual int soap_type(void) const { return 873; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptorExtension); }
	         tt__AudioClassDescriptorExtension() { tt__AudioClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptorExtension() { }
	friend tt__AudioClassDescriptorExtension *soap_instantiate_tt__AudioClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2346 */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (875)
/* Type tt__OSDPosConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDPosConfiguration complex type: */
class SOAP_CMAC tt__OSDPosConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of XSD type xsd:string */
	tt__Vector *Pos;	/* optional element of XSD type tt:Vector */
	tt__OSDPosConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDPosConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfiguration (875)
	virtual int soap_type(void) const { return 875; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfiguration); }
	         tt__OSDPosConfiguration() { tt__OSDPosConfiguration::soap_default(NULL); }
	virtual ~tt__OSDPosConfiguration() { }
	friend tt__OSDPosConfiguration *soap_instantiate_tt__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2349 */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (876)
/* Type tt__OSDPosConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDPosConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDPosConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfigurationExtension (876)
	virtual int soap_type(void) const { return 876; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfigurationExtension); }
	         tt__OSDPosConfigurationExtension() { tt__OSDPosConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDPosConfigurationExtension() { }
	friend tt__OSDPosConfigurationExtension *soap_instantiate_tt__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2352 */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (877)
/* Type tt__OSDColor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDColor complex type: */
class SOAP_CMAC tt__OSDColor : public xsd__anyType
{
public:
	tt__Color *Color;	/* required element of XSD type tt:Color */
	int *Transparent;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColor (877)
	virtual int soap_type(void) const { return 877; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColor, default initialized and not managed by a soap context
	virtual tt__OSDColor *soap_alloc(void) const { return SOAP_NEW(tt__OSDColor); }
	         tt__OSDColor() { tt__OSDColor::soap_default(NULL); }
	virtual ~tt__OSDColor() { }
	friend tt__OSDColor *soap_instantiate_tt__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2355 */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (878)
/* Type tt__OSDTextConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDTextConfiguration complex type: */
class SOAP_CMAC tt__OSDTextConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of XSD type xsd:string */
	std::string *DateFormat;	/* optional element of XSD type xsd:string */
	std::string *TimeFormat;	/* optional element of XSD type xsd:string */
	int *FontSize;	/* optional element of XSD type xsd:int */
	tt__OSDColor *FontColor;	/* optional element of XSD type tt:OSDColor */
	tt__OSDColor *BackgroundColor;	/* optional element of XSD type tt:OSDColor */
	std::string *PlainText;	/* optional element of XSD type xsd:string */
	tt__OSDTextConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDTextConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfiguration (878)
	virtual int soap_type(void) const { return 878; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfiguration); }
	         tt__OSDTextConfiguration() { tt__OSDTextConfiguration::soap_default(NULL); }
	virtual ~tt__OSDTextConfiguration() { }
	friend tt__OSDTextConfiguration *soap_instantiate_tt__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2358 */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (879)
/* Type tt__OSDTextConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDTextConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDTextConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfigurationExtension (879)
	virtual int soap_type(void) const { return 879; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfigurationExtension); }
	         tt__OSDTextConfigurationExtension() { tt__OSDTextConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDTextConfigurationExtension() { }
	friend tt__OSDTextConfigurationExtension *soap_instantiate_tt__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2361 */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (880)
/* Type tt__OSDImgConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDImgConfiguration complex type: */
class SOAP_CMAC tt__OSDImgConfiguration : public xsd__anyType
{
public:
	std::string ImgPath;	/* required element of XSD type xsd:anyURI */
	tt__OSDImgConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDImgConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfiguration (880)
	virtual int soap_type(void) const { return 880; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfiguration); }
	         tt__OSDImgConfiguration() { tt__OSDImgConfiguration::soap_default(NULL); }
	virtual ~tt__OSDImgConfiguration() { }
	friend tt__OSDImgConfiguration *soap_instantiate_tt__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2364 */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (881)
/* Type tt__OSDImgConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDImgConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDImgConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfigurationExtension (881)
	virtual int soap_type(void) const { return 881; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfigurationExtension); }
	         tt__OSDImgConfigurationExtension() { tt__OSDImgConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDImgConfigurationExtension() { }
	friend tt__OSDImgConfigurationExtension *soap_instantiate_tt__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2367 */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (882)
/* Type tt__ColorspaceRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorspaceRange complex type: */
class SOAP_CMAC tt__ColorspaceRange : public xsd__anyType
{
public:
	tt__FloatRange *X;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Y;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Z;	/* required element of XSD type tt:FloatRange */
	std::string Colorspace;	/* required element of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorspaceRange (882)
	virtual int soap_type(void) const { return 882; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorspaceRange, default initialized and not managed by a soap context
	virtual tt__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW(tt__ColorspaceRange); }
	         tt__ColorspaceRange() { tt__ColorspaceRange::soap_default(NULL); }
	virtual ~tt__ColorspaceRange() { }
	friend tt__ColorspaceRange *soap_instantiate_tt__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25010 */
#ifndef SOAP_TYPE__tt__union_ColorOptions
#define SOAP_TYPE__tt__union_ColorOptions (2130)
/* xsd:choice complex type: */
union _tt__union_ColorOptions
{
#define SOAP_UNION__tt__union_ColorOptions_ColorList	(1)
	std::vector<tt__Color *> *ColorList;
#define SOAP_UNION__tt__union_ColorOptions_ColorspaceRange	(2)
	std::vector<tt__ColorspaceRange *> *ColorspaceRange;
};
#endif

/* onvif.h:2370 */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (883)
/* Type tt__ColorOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorOptions complex type: */
class SOAP_CMAC tt__ColorOptions : public xsd__anyType
{
public:
	int __union_ColorOptions;	/* union discriminant (of union defined below) */
	union _tt__union_ColorOptions union_ColorOptions;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorOptions (883)
	virtual int soap_type(void) const { return 883; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorOptions, default initialized and not managed by a soap context
	virtual tt__ColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__ColorOptions); }
	         tt__ColorOptions() { tt__ColorOptions::soap_default(NULL); }
	virtual ~tt__ColorOptions() { }
	friend tt__ColorOptions *soap_instantiate_tt__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2373 */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (884)
/* Type tt__OSDColorOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDColorOptions complex type: */
class SOAP_CMAC tt__OSDColorOptions : public xsd__anyType
{
public:
	tt__ColorOptions *Color;	/* optional element of XSD type tt:ColorOptions */
	tt__IntRange *Transparent;	/* optional element of XSD type tt:IntRange */
	tt__OSDColorOptionsExtension *Extension;	/* optional element of XSD type tt:OSDColorOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptions (884)
	virtual int soap_type(void) const { return 884; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptions, default initialized and not managed by a soap context
	virtual tt__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptions); }
	         tt__OSDColorOptions() { tt__OSDColorOptions::soap_default(NULL); }
	virtual ~tt__OSDColorOptions() { }
	friend tt__OSDColorOptions *soap_instantiate_tt__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2376 */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (885)
/* Type tt__OSDColorOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDColorOptionsExtension complex type: */
class SOAP_CMAC tt__OSDColorOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptionsExtension (885)
	virtual int soap_type(void) const { return 885; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptionsExtension); }
	         tt__OSDColorOptionsExtension() { tt__OSDColorOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDColorOptionsExtension() { }
	friend tt__OSDColorOptionsExtension *soap_instantiate_tt__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2379 */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (886)
/* Type tt__OSDTextOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDTextOptions complex type: */
class SOAP_CMAC tt__OSDTextOptions : public xsd__anyType
{
public:
	std::vector<std::string> Type;	/* required element of XSD type xsd:string */
	tt__IntRange *FontSizeRange;	/* optional element of XSD type tt:IntRange */
	std::vector<std::string> DateFormat;	/* optional element of XSD type xsd:string */
	std::vector<std::string> TimeFormat;	/* optional element of XSD type xsd:string */
	tt__OSDColorOptions *FontColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDColorOptions *BackgroundColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDTextOptionsExtension *Extension;	/* optional element of XSD type tt:OSDTextOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptions (886)
	virtual int soap_type(void) const { return 886; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptions, default initialized and not managed by a soap context
	virtual tt__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptions); }
	         tt__OSDTextOptions() { tt__OSDTextOptions::soap_default(NULL); }
	virtual ~tt__OSDTextOptions() { }
	friend tt__OSDTextOptions *soap_instantiate_tt__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2382 */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (887)
/* Type tt__OSDTextOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDTextOptionsExtension complex type: */
class SOAP_CMAC tt__OSDTextOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptionsExtension (887)
	virtual int soap_type(void) const { return 887; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptionsExtension); }
	         tt__OSDTextOptionsExtension() { tt__OSDTextOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDTextOptionsExtension() { }
	friend tt__OSDTextOptionsExtension *soap_instantiate_tt__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2385 */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (888)
/* Type tt__OSDImgOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDImgOptions complex type: */
class SOAP_CMAC tt__OSDImgOptions : public xsd__anyType
{
public:
	std::vector<std::string> ImagePath;	/* required element of XSD type xsd:anyURI */
	tt__OSDImgOptionsExtension *Extension;	/* optional element of XSD type tt:OSDImgOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptions (888)
	virtual int soap_type(void) const { return 888; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptions, default initialized and not managed by a soap context
	virtual tt__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptions); }
	         tt__OSDImgOptions() { tt__OSDImgOptions::soap_default(NULL); }
	virtual ~tt__OSDImgOptions() { }
	friend tt__OSDImgOptions *soap_instantiate_tt__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2388 */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (889)
/* Type tt__OSDImgOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDImgOptionsExtension complex type: */
class SOAP_CMAC tt__OSDImgOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptionsExtension (889)
	virtual int soap_type(void) const { return 889; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptionsExtension); }
	         tt__OSDImgOptionsExtension() { tt__OSDImgOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDImgOptionsExtension() { }
	friend tt__OSDImgOptionsExtension *soap_instantiate_tt__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2394 */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (891)
/* Type tt__OSDConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationExtension (891)
	virtual int soap_type(void) const { return 891; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationExtension); }
	         tt__OSDConfigurationExtension() { tt__OSDConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationExtension() { }
	friend tt__OSDConfigurationExtension *soap_instantiate_tt__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2397 */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (892)
/* Type tt__MaximumNumberOfOSDs is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MaximumNumberOfOSDs simple type: */
class SOAP_CMAC tt__MaximumNumberOfOSDs : public xsd__anyType
{
public:
	int Total;	/* required attribute of XSD type xsd:int */
	int *Image;	/* optional attribute of XSD type xsd:int */
	int *PlainText;	/* optional attribute of XSD type xsd:int */
	int *Date;	/* optional attribute of XSD type xsd:int */
	int *Time;	/* optional attribute of XSD type xsd:int */
	int *DateAndTime;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MaximumNumberOfOSDs (892)
	virtual int soap_type(void) const { return 892; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MaximumNumberOfOSDs, default initialized and not managed by a soap context
	virtual tt__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW(tt__MaximumNumberOfOSDs); }
	         tt__MaximumNumberOfOSDs() { tt__MaximumNumberOfOSDs::soap_default(NULL); }
	virtual ~tt__MaximumNumberOfOSDs() { }
	friend tt__MaximumNumberOfOSDs *soap_instantiate_tt__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2400 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (893)
/* Type tt__OSDConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfigurationOptions complex type: */
class SOAP_CMAC tt__OSDConfigurationOptions : public xsd__anyType
{
public:
	tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;	/* required element of XSD type tt:MaximumNumberOfOSDs */
	std::vector<enum tt__OSDType> Type;	/* required element of XSD type tt:OSDType */
	std::vector<std::string> PositionOption;	/* required element of XSD type xsd:string */
	tt__OSDTextOptions *TextOption;	/* optional element of XSD type tt:OSDTextOptions */
	tt__OSDImgOptions *ImageOption;	/* optional element of XSD type tt:OSDImgOptions */
	tt__OSDConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptions (893)
	virtual int soap_type(void) const { return 893; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptions); }
	         tt__OSDConfigurationOptions() { tt__OSDConfigurationOptions::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptions() { }
	friend tt__OSDConfigurationOptions *soap_instantiate_tt__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2403 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (894)
/* Type tt__OSDConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptionsExtension (894)
	virtual int soap_type(void) const { return 894; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptionsExtension); }
	         tt__OSDConfigurationOptionsExtension() { tt__OSDConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptionsExtension() { }
	friend tt__OSDConfigurationOptionsExtension *soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2406 */
#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (895)
/* Type tt__FileProgress is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FileProgress complex type: */
class SOAP_CMAC tt__FileProgress : public xsd__anyType
{
public:
	std::string FileName;	/* required element of XSD type xsd:string */
	float Progress;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FileProgress (895)
	virtual int soap_type(void) const { return 895; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FileProgress, default initialized and not managed by a soap context
	virtual tt__FileProgress *soap_alloc(void) const { return SOAP_NEW(tt__FileProgress); }
	         tt__FileProgress() { tt__FileProgress::soap_default(NULL); }
	virtual ~tt__FileProgress() { }
	friend tt__FileProgress *soap_instantiate_tt__FileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2409 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (896)
/* Type tt__ArrayOfFileProgress is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ArrayOfFileProgress complex type: */
class SOAP_CMAC tt__ArrayOfFileProgress : public xsd__anyType
{
public:
	std::vector<tt__FileProgress *> FileProgress;	/* optional element of XSD type tt:FileProgress */
	tt__ArrayOfFileProgressExtension *Extension;	/* optional element of XSD type tt:ArrayOfFileProgressExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgress (896)
	virtual int soap_type(void) const { return 896; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgress, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgress *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgress); }
	         tt__ArrayOfFileProgress() { tt__ArrayOfFileProgress::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgress() { }
	friend tt__ArrayOfFileProgress *soap_instantiate_tt__ArrayOfFileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2412 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (897)
/* Type tt__ArrayOfFileProgressExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ArrayOfFileProgressExtension complex type: */
class SOAP_CMAC tt__ArrayOfFileProgressExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgressExtension (897)
	virtual int soap_type(void) const { return 897; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgressExtension, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgressExtension *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgressExtension); }
	         tt__ArrayOfFileProgressExtension() { tt__ArrayOfFileProgressExtension::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgressExtension() { }
	friend tt__ArrayOfFileProgressExtension *soap_instantiate_tt__ArrayOfFileProgressExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2415 */
#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (898)
/* Type tt__StorageReferencePath is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StorageReferencePath complex type: */
class SOAP_CMAC tt__StorageReferencePath : public xsd__anyType
{
public:
	std::string StorageToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *RelativePath;	/* optional element of XSD type xsd:string */
	tt__StorageReferencePathExtension *Extension;	/* optional element of XSD type tt:StorageReferencePathExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePath (898)
	virtual int soap_type(void) const { return 898; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePath, default initialized and not managed by a soap context
	virtual tt__StorageReferencePath *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePath); }
	         tt__StorageReferencePath() { tt__StorageReferencePath::soap_default(NULL); }
	virtual ~tt__StorageReferencePath() { }
	friend tt__StorageReferencePath *soap_instantiate_tt__StorageReferencePath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2418 */
#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (899)
/* Type tt__StorageReferencePathExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StorageReferencePathExtension complex type: */
class SOAP_CMAC tt__StorageReferencePathExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePathExtension (899)
	virtual int soap_type(void) const { return 899; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePathExtension, default initialized and not managed by a soap context
	virtual tt__StorageReferencePathExtension *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePathExtension); }
	         tt__StorageReferencePathExtension() { tt__StorageReferencePathExtension::soap_default(NULL); }
	virtual ~tt__StorageReferencePathExtension() { }
	friend tt__StorageReferencePathExtension *soap_instantiate_tt__StorageReferencePathExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2421 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (900)
/* tt:Message complex type: */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Key;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Data;	/* optional element of XSD type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of XSD type tt:MessageExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute of XSD type tt:PropertyOperation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Message (900)
	virtual int soap_type(void) const { return 900; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Message, default initialized and not managed by a soap context
	virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW(_tt__Message); }
	         _tt__Message() { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
	friend _tt__Message *soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2424 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (901)
/* Type wsnt__QueryExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:QueryExpressionType complex type: */
class SOAP_CMAC wsnt__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__QueryExpressionType (901)
	virtual int soap_type(void) const { return 901; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
	virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__QueryExpressionType); }
	         wsnt__QueryExpressionType() { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
	friend wsnt__QueryExpressionType *soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2427 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (902)
/* Type wsnt__TopicExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionType complex type: */
class SOAP_CMAC wsnt__TopicExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionType (902)
	virtual int soap_type(void) const { return 902; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionType); }
	         wsnt__TopicExpressionType() { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
	friend wsnt__TopicExpressionType *soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2430 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (903)
/* Type wsnt__FilterType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:FilterType complex type: */
class SOAP_CMAC wsnt__FilterType : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__FilterType (903)
	virtual int soap_type(void) const { return 903; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
	virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW(wsnt__FilterType); }
	         wsnt__FilterType() { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
	friend wsnt__FilterType *soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2433 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (904)
/* Type wsnt__SubscriptionPolicyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscriptionPolicyType complex type: */
class SOAP_CMAC wsnt__SubscriptionPolicyType : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscriptionPolicyType (904)
	virtual int soap_type(void) const { return 904; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
	virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscriptionPolicyType); }
	         wsnt__SubscriptionPolicyType() { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
	friend wsnt__SubscriptionPolicyType *soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25718 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (2149)
/* wsnt:NotificationMessageHolderType-Message complex type: */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (2149)
	virtual int soap_type(void) const { return 2149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
	virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationMessageHolderType_Message); }
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
	friend _wsnt__NotificationMessageHolderType_Message *soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2436 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (905)
/* Type wsnt__NotificationMessageHolderType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotificationMessageHolderType complex type: */
class SOAP_CMAC wsnt__NotificationMessageHolderType : public xsd__anyType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of XSD type wsnt:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of XSD type wsnt:NotificationMessageHolderType-Message */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotificationMessageHolderType (905)
	virtual int soap_type(void) const { return 905; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
	virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotificationMessageHolderType); }
	         wsnt__NotificationMessageHolderType() { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
	friend wsnt__NotificationMessageHolderType *soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2499 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (926)
/* wsnt:NotificationProducerRP complex type: */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	std::vector<wsnt__TopicExpressionType *> TopicExpression;	/* optional element of XSD type wsnt:TopicExpressionType */
	bool FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	std::vector<std::string> TopicExpressionDialect;	/* optional element of XSD type xsd:anyURI */
	wstop__TopicSetType *wstop__TopicSet;	/* optional element of XSD type wstop:TopicSetType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationProducerRP (926)
	virtual int soap_type(void) const { return 926; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
	virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationProducerRP); }
	         _wsnt__NotificationProducerRP() { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
	friend _wsnt__NotificationProducerRP *soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2502 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (927)
/* wsnt:SubscriptionManagerRP complex type: */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of XSD type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscriptionManagerRP (927)
	virtual int soap_type(void) const { return 927; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
	virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscriptionManagerRP); }
	         _wsnt__SubscriptionManagerRP() { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
	friend _wsnt__SubscriptionManagerRP *soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2505 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (928)
/* wsnt:Notify complex type: */
class SOAP_CMAC _wsnt__Notify
{
public:
	std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Notify (928)
	virtual int soap_type(void) const { return 928; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
	virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW(_wsnt__Notify); }
	         _wsnt__Notify() { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
	friend _wsnt__Notify *soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2508 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (929)
/* wsnt:UseRaw complex type: */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UseRaw (929)
	virtual int soap_type(void) const { return 929; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
	virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW(_wsnt__UseRaw); }
	         _wsnt__UseRaw() { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
	friend _wsnt__UseRaw *soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25861 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (2155)
/* wsnt:Subscribe-SubscriptionPolicy complex type: */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (2155)
	virtual int soap_type(void) const { return 2155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe_SubscriptionPolicy); }
	         _wsnt__Subscribe_SubscriptionPolicy() { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
	friend _wsnt__Subscribe_SubscriptionPolicy *soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2511 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (930)
/* wsnt:Subscribe complex type: */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	std::string *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type wsnt:Subscribe-SubscriptionPolicy */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe (930)
	virtual int soap_type(void) const { return 930; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe); }
	         _wsnt__Subscribe() { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
	friend _wsnt__Subscribe *soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2514 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (931)
/* wsnt:SubscribeResponse complex type: */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscribeResponse (931)
	virtual int soap_type(void) const { return 931; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscribeResponse); }
	         _wsnt__SubscribeResponse() { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
	friend _wsnt__SubscribeResponse *soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2517 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (932)
/* wsnt:GetCurrentMessage complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of XSD type wsnt:TopicExpressionType */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessage (932)
	virtual int soap_type(void) const { return 932; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessage); }
	         _wsnt__GetCurrentMessage() { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
	friend _wsnt__GetCurrentMessage *soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2520 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (933)
/* wsnt:GetCurrentMessageResponse complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessageResponse (933)
	virtual int soap_type(void) const { return 933; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessageResponse); }
	         _wsnt__GetCurrentMessageResponse() { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
	friend _wsnt__GetCurrentMessageResponse *soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2523 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (934)
/* wsnt:GetMessages complex type: */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	std::string *MaximumNumber;	/* optional element of XSD type xsd:nonNegativeInteger */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessages (934)
	virtual int soap_type(void) const { return 934; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
	virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessages); }
	         _wsnt__GetMessages() { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
	friend _wsnt__GetMessages *soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2526 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (935)
/* wsnt:GetMessagesResponse complex type: */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type wsnt:NotificationMessageHolderType */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessagesResponse (935)
	virtual int soap_type(void) const { return 935; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessagesResponse); }
	         _wsnt__GetMessagesResponse() { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
	friend _wsnt__GetMessagesResponse *soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2529 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (936)
/* wsnt:DestroyPullPoint complex type: */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPoint (936)
	virtual int soap_type(void) const { return 936; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPoint); }
	         _wsnt__DestroyPullPoint() { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
	friend _wsnt__DestroyPullPoint *soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2532 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (937)
/* wsnt:DestroyPullPointResponse complex type: */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPointResponse (937)
	virtual int soap_type(void) const { return 937; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPointResponse); }
	         _wsnt__DestroyPullPointResponse() { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
	friend _wsnt__DestroyPullPointResponse *soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2535 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (938)
/* wsnt:CreatePullPoint complex type: */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPoint (938)
	virtual int soap_type(void) const { return 938; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPoint); }
	         _wsnt__CreatePullPoint() { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
	friend _wsnt__CreatePullPoint *soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2538 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (939)
/* wsnt:CreatePullPointResponse complex type: */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPointResponse (939)
	virtual int soap_type(void) const { return 939; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPointResponse); }
	         _wsnt__CreatePullPointResponse() { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
	friend _wsnt__CreatePullPointResponse *soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2541 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (940)
/* wsnt:Renew complex type: */
class SOAP_CMAC _wsnt__Renew
{
public:
	std::string *TerminationTime;	/* required element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Renew (940)
	virtual int soap_type(void) const { return 940; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
	virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW(_wsnt__Renew); }
	         _wsnt__Renew() { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
	friend _wsnt__Renew *soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2544 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (941)
/* wsnt:RenewResponse complex type: */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__RenewResponse (941)
	virtual int soap_type(void) const { return 941; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
	virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__RenewResponse); }
	         _wsnt__RenewResponse() { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
	friend _wsnt__RenewResponse *soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2547 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (942)
/* wsnt:Unsubscribe complex type: */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Unsubscribe (942)
	virtual int soap_type(void) const { return 942; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
	virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Unsubscribe); }
	         _wsnt__Unsubscribe() { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
	friend _wsnt__Unsubscribe *soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2550 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (943)
/* wsnt:UnsubscribeResponse complex type: */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UnsubscribeResponse (943)
	virtual int soap_type(void) const { return 943; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__UnsubscribeResponse); }
	         _wsnt__UnsubscribeResponse() { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
	friend _wsnt__UnsubscribeResponse *soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2553 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (944)
/* wsnt:PauseSubscription complex type: */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscription (944)
	virtual int soap_type(void) const { return 944; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscription); }
	         _wsnt__PauseSubscription() { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
	friend _wsnt__PauseSubscription *soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2556 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (945)
/* wsnt:PauseSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscriptionResponse (945)
	virtual int soap_type(void) const { return 945; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscriptionResponse); }
	         _wsnt__PauseSubscriptionResponse() { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
	friend _wsnt__PauseSubscriptionResponse *soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2559 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (946)
/* wsnt:ResumeSubscription complex type: */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscription (946)
	virtual int soap_type(void) const { return 946; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscription); }
	         _wsnt__ResumeSubscription() { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
	friend _wsnt__ResumeSubscription *soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2562 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (947)
/* wsnt:ResumeSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscriptionResponse (947)
	virtual int soap_type(void) const { return 947; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscriptionResponse); }
	         _wsnt__ResumeSubscriptionResponse() { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
	friend _wsnt__ResumeSubscriptionResponse *soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26423 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (2158)
/* wsrfbf:BaseFaultType-ErrorCode complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (2158)
	virtual int soap_type(void) const { return 2158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode); }
	         _wsrfbf__BaseFaultType_ErrorCode() { _wsrfbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
	friend _wsrfbf__BaseFaultType_ErrorCode *soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26444 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (2160)
/* wsrfbf:BaseFaultType-Description simple type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description
{
public:
	std::string __item;	/* mixed XML content */
	std::string *xml__lang;	/* optional attribute of XSD type xml:lang */
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_Description (2160)
	virtual int soap_type(void) const { return 2160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_Description); }
	         _wsrfbf__BaseFaultType_Description() { _wsrfbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_Description() { }
	friend _wsrfbf__BaseFaultType_Description *soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26461 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (2164)
/* wsrfbf:BaseFaultType-FaultCause complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (2164)
	virtual int soap_type(void) const { return 2164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause); }
	         _wsrfbf__BaseFaultType_FaultCause() { _wsrfbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
	friend _wsrfbf__BaseFaultType_FaultCause *soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2565 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (948)
/* Type wsrfbf__BaseFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfbf:BaseFaultType complex type: */
class SOAP_CMAC wsrfbf__BaseFaultType : public xsd__anyType
{
public:
	std::vector<char *> __any;
	time_t Timestamp;	/* required element of XSD type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of XSD type wsrfbf:BaseFaultType-ErrorCode */
	std::vector<_wsrfbf__BaseFaultType_Description> *Description;	/* optional element of XSD type wsrfbf:BaseFaultType-Description */
	_wsrfbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of XSD type wsrfbf:BaseFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfbf__BaseFaultType (948)
	virtual int soap_type(void) const { return 948; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
	virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfbf__BaseFaultType); }
	         wsrfbf__BaseFaultType() { wsrfbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsrfbf__BaseFaultType() { }
	friend wsrfbf__BaseFaultType *soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2568 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (949)
/* Type wstop__Documentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:Documentation complex type: */
class SOAP_CMAC wstop__Documentation : public xsd__anyType
{
public:
	std::vector<char *> __any;
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__Documentation (949)
	virtual int soap_type(void) const { return 949; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
	virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW(wstop__Documentation); }
	         wstop__Documentation() { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
	friend wstop__Documentation *soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2571 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (950)
/* Type wstop__ExtensibleDocumented is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ExtensibleDocumented complex type: */
class SOAP_CMAC wstop__ExtensibleDocumented : public xsd__anyType
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ExtensibleDocumented (950)
	virtual int soap_type(void) const { return 950; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
	virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(wstop__ExtensibleDocumented); }
	         wstop__ExtensibleDocumented() { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
	friend wstop__ExtensibleDocumented *soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2574 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (951)
/* Type wstop__QueryExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:QueryExpressionType complex type: */
class SOAP_CMAC wstop__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__QueryExpressionType (951)
	virtual int soap_type(void) const { return 951; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
	virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wstop__QueryExpressionType); }
	         wstop__QueryExpressionType() { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
	friend wstop__QueryExpressionType *soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2586 */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (955)
/* Type tev__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tev:Capabilities complex type: */
class SOAP_CMAC tev__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *WSSubscriptionPolicySupport;	/* optional attribute of XSD type xsd:boolean */
	bool *WSPullPointSupport;	/* optional attribute of XSD type xsd:boolean */
	bool *WSPausableSubscriptionManagerInterfaceSupport;	/* optional attribute of XSD type xsd:boolean */
	int *MaxNotificationProducers;	/* optional attribute of XSD type xsd:int */
	int *MaxPullPoints;	/* optional attribute of XSD type xsd:int */
	bool *PersistentNotificationStorage;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tev__Capabilities (955)
	virtual int soap_type(void) const { return 955; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tev__Capabilities, default initialized and not managed by a soap context
	virtual tev__Capabilities *soap_alloc(void) const { return SOAP_NEW(tev__Capabilities); }
	         tev__Capabilities() { tev__Capabilities::soap_default(NULL); }
	virtual ~tev__Capabilities() { }
	friend tev__Capabilities *soap_instantiate_tev__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2589 */
#ifndef SOAP_TYPE_tev__SubscriptionPolicy
#define SOAP_TYPE_tev__SubscriptionPolicy (956)
/* Type tev__SubscriptionPolicy is a recursive data type (in)directly referencing itself through its (base) class members */
/* tev:SubscriptionPolicy complex type: */
class SOAP_CMAC tev__SubscriptionPolicy : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *ChangedOnly;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tev__SubscriptionPolicy (956)
	virtual int soap_type(void) const { return 956; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tev__SubscriptionPolicy, default initialized and not managed by a soap context
	virtual tev__SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(tev__SubscriptionPolicy); }
	         tev__SubscriptionPolicy() { tev__SubscriptionPolicy::soap_default(NULL); }
	virtual ~tev__SubscriptionPolicy() { }
	friend tev__SubscriptionPolicy *soap_instantiate_tev__SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2592 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (957)
/* tev:GetServiceCapabilities complex type: */
class SOAP_CMAC _tev__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetServiceCapabilities (957)
	virtual int soap_type(void) const { return 957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tev__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tev__GetServiceCapabilities); }
	         _tev__GetServiceCapabilities() { _tev__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tev__GetServiceCapabilities() { }
	friend _tev__GetServiceCapabilities *soap_instantiate__tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2595 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (958)
/* tev:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tev__GetServiceCapabilitiesResponse
{
public:
	tev__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tev:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetServiceCapabilitiesResponse (958)
	virtual int soap_type(void) const { return 958; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tev__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__GetServiceCapabilitiesResponse); }
	         _tev__GetServiceCapabilitiesResponse() { _tev__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tev__GetServiceCapabilitiesResponse() { }
	friend _tev__GetServiceCapabilitiesResponse *soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26750 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (2168)
/* tev:CreatePullPointSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscription_SubscriptionPolicy
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (2168)
	virtual int soap_type(void) const { return 2168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscription_SubscriptionPolicy); }
	         _tev__CreatePullPointSubscription_SubscriptionPolicy() { _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription_SubscriptionPolicy() { }
	friend _tev__CreatePullPointSubscription_SubscriptionPolicy *soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2598 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (959)
/* tev:CreatePullPointSubscription complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscription
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	std::string *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_tev__CreatePullPointSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tev:CreatePullPointSubscription-SubscriptionPolicy */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscription (959)
	virtual int soap_type(void) const { return 959; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscription, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscription *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscription); }
	         _tev__CreatePullPointSubscription() { _tev__CreatePullPointSubscription::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription() { }
	friend _tev__CreatePullPointSubscription *soap_instantiate__tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2601 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (960)
/* tev:CreatePullPointSubscriptionResponse complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscriptionResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t wsnt__CurrentTime;	/* required element of XSD type xsd:dateTime */
	time_t wsnt__TerminationTime;	/* required element of XSD type xsd:dateTime */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (960)
	virtual int soap_type(void) const { return 960; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscriptionResponse, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscriptionResponse); }
	         _tev__CreatePullPointSubscriptionResponse() { _tev__CreatePullPointSubscriptionResponse::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscriptionResponse() { }
	friend _tev__CreatePullPointSubscriptionResponse *soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2604 */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (961)
/* tev:PullMessages complex type: */
class SOAP_CMAC _tev__PullMessages
{
public:
	LONG64 Timeout;	/* external (custom serializer) */
	int MessageLimit;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessages (961)
	virtual int soap_type(void) const { return 961; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessages, default initialized and not managed by a soap context
	virtual _tev__PullMessages *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessages); }
	         _tev__PullMessages() { _tev__PullMessages::soap_default(NULL); }
	virtual ~_tev__PullMessages() { }
	friend _tev__PullMessages *soap_instantiate__tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2607 */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (962)
/* tev:PullMessagesResponse complex type: */
class SOAP_CMAC _tev__PullMessagesResponse
{
public:
	time_t CurrentTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	time_t TerminationTime;	/* required element of XSD type xsd:dateTime */
	std::vector<wsnt__NotificationMessageHolderType *> wsnt__NotificationMessage;	/* optional element of XSD type wsnt:NotificationMessageHolderType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessagesResponse (962)
	virtual int soap_type(void) const { return 962; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessagesResponse, default initialized and not managed by a soap context
	virtual _tev__PullMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessagesResponse); }
	         _tev__PullMessagesResponse() { _tev__PullMessagesResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesResponse() { }
	friend _tev__PullMessagesResponse *soap_instantiate__tev__PullMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2610 */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (963)
/* tev:PullMessagesFaultResponse complex type: */
class SOAP_CMAC _tev__PullMessagesFaultResponse
{
public:
	LONG64 MaxTimeout;	/* external (custom serializer) */
	int MaxMessageLimit;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessagesFaultResponse (963)
	virtual int soap_type(void) const { return 963; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessagesFaultResponse, default initialized and not managed by a soap context
	virtual _tev__PullMessagesFaultResponse *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessagesFaultResponse); }
	         _tev__PullMessagesFaultResponse() { _tev__PullMessagesFaultResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesFaultResponse() { }
	friend _tev__PullMessagesFaultResponse *soap_instantiate__tev__PullMessagesFaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2613 */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (964)
/* tev:Seek complex type: */
class SOAP_CMAC _tev__Seek
{
public:
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	bool *Reverse;	/* optional element of XSD type xsd:boolean */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__Seek (964)
	virtual int soap_type(void) const { return 964; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__Seek, default initialized and not managed by a soap context
	virtual _tev__Seek *soap_alloc(void) const { return SOAP_NEW(_tev__Seek); }
	         _tev__Seek() { _tev__Seek::soap_default(NULL); }
	virtual ~_tev__Seek() { }
	friend _tev__Seek *soap_instantiate__tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2616 */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (965)
/* tev:SeekResponse complex type: */
class SOAP_CMAC _tev__SeekResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SeekResponse (965)
	virtual int soap_type(void) const { return 965; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SeekResponse, default initialized and not managed by a soap context
	virtual _tev__SeekResponse *soap_alloc(void) const { return SOAP_NEW(_tev__SeekResponse); }
	         _tev__SeekResponse() { _tev__SeekResponse::soap_default(NULL); }
	virtual ~_tev__SeekResponse() { }
	friend _tev__SeekResponse *soap_instantiate__tev__SeekResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2619 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (966)
/* tev:SetSynchronizationPoint complex type: */
class SOAP_CMAC _tev__SetSynchronizationPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SetSynchronizationPoint (966)
	virtual int soap_type(void) const { return 966; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SetSynchronizationPoint, default initialized and not managed by a soap context
	virtual _tev__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_tev__SetSynchronizationPoint); }
	         _tev__SetSynchronizationPoint() { _tev__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPoint() { }
	friend _tev__SetSynchronizationPoint *soap_instantiate__tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2622 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (967)
/* tev:SetSynchronizationPointResponse complex type: */
class SOAP_CMAC _tev__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SetSynchronizationPointResponse (967)
	virtual int soap_type(void) const { return 967; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SetSynchronizationPointResponse, default initialized and not managed by a soap context
	virtual _tev__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_tev__SetSynchronizationPointResponse); }
	         _tev__SetSynchronizationPointResponse() { _tev__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPointResponse() { }
	friend _tev__SetSynchronizationPointResponse *soap_instantiate__tev__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2625 */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (968)
/* tev:GetEventProperties complex type: */
class SOAP_CMAC _tev__GetEventProperties
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetEventProperties (968)
	virtual int soap_type(void) const { return 968; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetEventProperties, default initialized and not managed by a soap context
	virtual _tev__GetEventProperties *soap_alloc(void) const { return SOAP_NEW(_tev__GetEventProperties); }
	         _tev__GetEventProperties() { _tev__GetEventProperties::soap_default(NULL); }
	virtual ~_tev__GetEventProperties() { }
	friend _tev__GetEventProperties *soap_instantiate__tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2628 */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (969)
/* tev:GetEventPropertiesResponse complex type: */
class SOAP_CMAC _tev__GetEventPropertiesResponse
{
public:
	std::vector<std::string> TopicNamespaceLocation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	bool wsnt__FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	wstop__TopicSetType *wstop__TopicSet;	/* required element of XSD type wstop:TopicSetType */
	std::vector<std::string> wsnt__TopicExpressionDialect;	/* required element of XSD type xsd:anyURI */
	std::vector<std::string> MessageContentFilterDialect;	/* required element of XSD type xsd:anyURI */
	std::vector<std::string> ProducerPropertiesFilterDialect;	/* optional element of XSD type xsd:anyURI */
	std::vector<std::string> MessageContentSchemaLocation;	/* required element of XSD type xsd:anyURI */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetEventPropertiesResponse (969)
	virtual int soap_type(void) const { return 969; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetEventPropertiesResponse, default initialized and not managed by a soap context
	virtual _tev__GetEventPropertiesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__GetEventPropertiesResponse); }
	         _tev__GetEventPropertiesResponse() { _tev__GetEventPropertiesResponse::soap_default(NULL); }
	virtual ~_tev__GetEventPropertiesResponse() { }
	friend _tev__GetEventPropertiesResponse *soap_instantiate__tev__GetEventPropertiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2637 */
#ifndef SOAP_TYPE_tls__Capabilities
#define SOAP_TYPE_tls__Capabilities (972)
/* Type tls__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tls:Capabilities complex type: */
class SOAP_CMAC tls__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *FixedLayout;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tls__Capabilities (972)
	virtual int soap_type(void) const { return 972; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tls__Capabilities, default initialized and not managed by a soap context
	virtual tls__Capabilities *soap_alloc(void) const { return SOAP_NEW(tls__Capabilities); }
	         tls__Capabilities() { tls__Capabilities::soap_default(NULL); }
	virtual ~tls__Capabilities() { }
	friend tls__Capabilities *soap_instantiate_tls__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2640 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilities
#define SOAP_TYPE__tls__GetServiceCapabilities (973)
/* tls:GetServiceCapabilities complex type: */
class SOAP_CMAC _tls__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilities (973)
	virtual int soap_type(void) const { return 973; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilities); }
	         _tls__GetServiceCapabilities() { _tls__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilities() { }
	friend _tls__GetServiceCapabilities *soap_instantiate__tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2643 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tls__GetServiceCapabilitiesResponse (974)
/* tls:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tls__GetServiceCapabilitiesResponse
{
public:
	tls__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tls:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilitiesResponse (974)
	virtual int soap_type(void) const { return 974; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilitiesResponse); }
	         _tls__GetServiceCapabilitiesResponse() { _tls__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilitiesResponse() { }
	friend _tls__GetServiceCapabilitiesResponse *soap_instantiate__tls__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2646 */
#ifndef SOAP_TYPE__tls__GetLayout
#define SOAP_TYPE__tls__GetLayout (975)
/* tls:GetLayout complex type: */
class SOAP_CMAC _tls__GetLayout
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayout (975)
	virtual int soap_type(void) const { return 975; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayout, default initialized and not managed by a soap context
	virtual _tls__GetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayout); }
	         _tls__GetLayout() { _tls__GetLayout::soap_default(NULL); }
	virtual ~_tls__GetLayout() { }
	friend _tls__GetLayout *soap_instantiate__tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2649 */
#ifndef SOAP_TYPE__tls__GetLayoutResponse
#define SOAP_TYPE__tls__GetLayoutResponse (976)
/* tls:GetLayoutResponse complex type: */
class SOAP_CMAC _tls__GetLayoutResponse
{
public:
	tt__Layout *Layout;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Layout */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayoutResponse (976)
	virtual int soap_type(void) const { return 976; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__GetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayoutResponse); }
	         _tls__GetLayoutResponse() { _tls__GetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__GetLayoutResponse() { }
	friend _tls__GetLayoutResponse *soap_instantiate__tls__GetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2652 */
#ifndef SOAP_TYPE__tls__SetLayout
#define SOAP_TYPE__tls__SetLayout (977)
/* tls:SetLayout complex type: */
class SOAP_CMAC _tls__SetLayout
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayout (977)
	virtual int soap_type(void) const { return 977; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayout, default initialized and not managed by a soap context
	virtual _tls__SetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayout); }
	         _tls__SetLayout() { _tls__SetLayout::soap_default(NULL); }
	virtual ~_tls__SetLayout() { }
	friend _tls__SetLayout *soap_instantiate__tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2655 */
#ifndef SOAP_TYPE__tls__SetLayoutResponse
#define SOAP_TYPE__tls__SetLayoutResponse (978)
/* tls:SetLayoutResponse complex type: */
class SOAP_CMAC _tls__SetLayoutResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayoutResponse (978)
	virtual int soap_type(void) const { return 978; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__SetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayoutResponse); }
	         _tls__SetLayoutResponse() { _tls__SetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__SetLayoutResponse() { }
	friend _tls__SetLayoutResponse *soap_instantiate__tls__SetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2658 */
#ifndef SOAP_TYPE__tls__GetDisplayOptions
#define SOAP_TYPE__tls__GetDisplayOptions (979)
/* tls:GetDisplayOptions complex type: */
class SOAP_CMAC _tls__GetDisplayOptions
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptions (979)
	virtual int soap_type(void) const { return 979; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptions, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptions *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptions); }
	         _tls__GetDisplayOptions() { _tls__GetDisplayOptions::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptions() { }
	friend _tls__GetDisplayOptions *soap_instantiate__tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2661 */
#ifndef SOAP_TYPE__tls__GetDisplayOptionsResponse
#define SOAP_TYPE__tls__GetDisplayOptionsResponse (980)
/* tls:GetDisplayOptionsResponse complex type: */
class SOAP_CMAC _tls__GetDisplayOptionsResponse
{
public:
	tt__LayoutOptions *LayoutOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:LayoutOptions */
	tt__CodingCapabilities *CodingCapabilities;	/* required element of XSD type tt:CodingCapabilities */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptionsResponse (980)
	virtual int soap_type(void) const { return 980; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptionsResponse, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptionsResponse); }
	         _tls__GetDisplayOptionsResponse() { _tls__GetDisplayOptionsResponse::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptionsResponse() { }
	friend _tls__GetDisplayOptionsResponse *soap_instantiate__tls__GetDisplayOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2664 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurations
#define SOAP_TYPE__tls__GetPaneConfigurations (981)
/* tls:GetPaneConfigurations complex type: */
class SOAP_CMAC _tls__GetPaneConfigurations
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurations (981)
	virtual int soap_type(void) const { return 981; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurations); }
	         _tls__GetPaneConfigurations() { _tls__GetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurations() { }
	friend _tls__GetPaneConfigurations *soap_instantiate__tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2667 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationsResponse
#define SOAP_TYPE__tls__GetPaneConfigurationsResponse (982)
/* tls:GetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationsResponse
{
public:
	std::vector<tt__PaneConfiguration *> PaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationsResponse (982)
	virtual int soap_type(void) const { return 982; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationsResponse); }
	         _tls__GetPaneConfigurationsResponse() { _tls__GetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationsResponse() { }
	friend _tls__GetPaneConfigurationsResponse *soap_instantiate__tls__GetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2670 */
#ifndef SOAP_TYPE__tls__GetPaneConfiguration
#define SOAP_TYPE__tls__GetPaneConfiguration (983)
/* tls:GetPaneConfiguration complex type: */
class SOAP_CMAC _tls__GetPaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::string Pane;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfiguration (983)
	virtual int soap_type(void) const { return 983; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfiguration); }
	         _tls__GetPaneConfiguration() { _tls__GetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__GetPaneConfiguration() { }
	friend _tls__GetPaneConfiguration *soap_instantiate__tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2673 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationResponse
#define SOAP_TYPE__tls__GetPaneConfigurationResponse (984)
/* tls:GetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationResponse
{
public:
	tt__PaneConfiguration *PaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PaneConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationResponse (984)
	virtual int soap_type(void) const { return 984; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationResponse); }
	         _tls__GetPaneConfigurationResponse() { _tls__GetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationResponse() { }
	friend _tls__GetPaneConfigurationResponse *soap_instantiate__tls__GetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2676 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurations
#define SOAP_TYPE__tls__SetPaneConfigurations (985)
/* tls:SetPaneConfigurations complex type: */
class SOAP_CMAC _tls__SetPaneConfigurations
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::vector<tt__PaneConfiguration *> PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurations (985)
	virtual int soap_type(void) const { return 985; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurations); }
	         _tls__SetPaneConfigurations() { _tls__SetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurations() { }
	friend _tls__SetPaneConfigurations *soap_instantiate__tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2679 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationsResponse
#define SOAP_TYPE__tls__SetPaneConfigurationsResponse (986)
/* tls:SetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationsResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationsResponse (986)
	virtual int soap_type(void) const { return 986; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationsResponse); }
	         _tls__SetPaneConfigurationsResponse() { _tls__SetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationsResponse() { }
	friend _tls__SetPaneConfigurationsResponse *soap_instantiate__tls__SetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2682 */
#ifndef SOAP_TYPE__tls__SetPaneConfiguration
#define SOAP_TYPE__tls__SetPaneConfiguration (987)
/* tls:SetPaneConfiguration complex type: */
class SOAP_CMAC _tls__SetPaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfiguration (987)
	virtual int soap_type(void) const { return 987; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfiguration); }
	         _tls__SetPaneConfiguration() { _tls__SetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__SetPaneConfiguration() { }
	friend _tls__SetPaneConfiguration *soap_instantiate__tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2685 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationResponse
#define SOAP_TYPE__tls__SetPaneConfigurationResponse (988)
/* tls:SetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationResponse (988)
	virtual int soap_type(void) const { return 988; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationResponse); }
	         _tls__SetPaneConfigurationResponse() { _tls__SetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationResponse() { }
	friend _tls__SetPaneConfigurationResponse *soap_instantiate__tls__SetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2688 */
#ifndef SOAP_TYPE__tls__CreatePaneConfiguration
#define SOAP_TYPE__tls__CreatePaneConfiguration (989)
/* tls:CreatePaneConfiguration complex type: */
class SOAP_CMAC _tls__CreatePaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfiguration (989)
	virtual int soap_type(void) const { return 989; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfiguration); }
	         _tls__CreatePaneConfiguration() { _tls__CreatePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfiguration() { }
	friend _tls__CreatePaneConfiguration *soap_instantiate__tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2691 */
#ifndef SOAP_TYPE__tls__CreatePaneConfigurationResponse
#define SOAP_TYPE__tls__CreatePaneConfigurationResponse (990)
/* tls:CreatePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__CreatePaneConfigurationResponse
{
public:
	std::string PaneToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfigurationResponse (990)
	virtual int soap_type(void) const { return 990; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfigurationResponse); }
	         _tls__CreatePaneConfigurationResponse() { _tls__CreatePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfigurationResponse() { }
	friend _tls__CreatePaneConfigurationResponse *soap_instantiate__tls__CreatePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2694 */
#ifndef SOAP_TYPE__tls__DeletePaneConfiguration
#define SOAP_TYPE__tls__DeletePaneConfiguration (991)
/* tls:DeletePaneConfiguration complex type: */
class SOAP_CMAC _tls__DeletePaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::string PaneToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfiguration (991)
	virtual int soap_type(void) const { return 991; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfiguration); }
	         _tls__DeletePaneConfiguration() { _tls__DeletePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfiguration() { }
	friend _tls__DeletePaneConfiguration *soap_instantiate__tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2697 */
#ifndef SOAP_TYPE__tls__DeletePaneConfigurationResponse
#define SOAP_TYPE__tls__DeletePaneConfigurationResponse (992)
/* tls:DeletePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__DeletePaneConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfigurationResponse (992)
	virtual int soap_type(void) const { return 992; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfigurationResponse); }
	         _tls__DeletePaneConfigurationResponse() { _tls__DeletePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfigurationResponse() { }
	friend _tls__DeletePaneConfigurationResponse *soap_instantiate__tls__DeletePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2700 */
#ifndef SOAP_TYPE_tmd__Capabilities
#define SOAP_TYPE_tmd__Capabilities (993)
/* Type tmd__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:Capabilities complex type: */
class SOAP_CMAC tmd__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	int VideoSources;	/* optional attribute of XSD type xsd:int */
	int VideoOutputs;	/* optional attribute of XSD type xsd:int */
	int AudioSources;	/* optional attribute of XSD type xsd:int */
	int AudioOutputs;	/* optional attribute of XSD type xsd:int */
	int RelayOutputs;	/* optional attribute of XSD type xsd:int */
	int SerialPorts;	/* optional attribute of XSD type xsd:int */
	int DigitalInputs;	/* optional attribute of XSD type xsd:int */
	bool DigitalInputOptions;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__Capabilities (993)
	virtual int soap_type(void) const { return 993; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__Capabilities, default initialized and not managed by a soap context
	virtual tmd__Capabilities *soap_alloc(void) const { return SOAP_NEW(tmd__Capabilities); }
	         tmd__Capabilities() { tmd__Capabilities::soap_default(NULL); }
	virtual ~tmd__Capabilities() { }
	friend tmd__Capabilities *soap_instantiate_tmd__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2703 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptions
#define SOAP_TYPE_tmd__RelayOutputOptions (994)
/* Type tmd__RelayOutputOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:RelayOutputOptions complex type: */
class SOAP_CMAC tmd__RelayOutputOptions : public xsd__anyType
{
public:
	std::vector<enum tt__RelayMode> Mode;	/* required element of XSD type tt:RelayMode */
	std::string *DelayTimes;	/* optional element of XSD type tmd:DelayTimes */
	bool *Discrete;	/* optional element of XSD type xsd:boolean */
	tmd__RelayOutputOptionsExtension *Extension;	/* optional element of XSD type tmd:RelayOutputOptionsExtension */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptions (994)
	virtual int soap_type(void) const { return 994; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptions, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptions); }
	         tmd__RelayOutputOptions() { tmd__RelayOutputOptions::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptions() { }
	friend tmd__RelayOutputOptions *soap_instantiate_tmd__RelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2706 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptionsExtension
#define SOAP_TYPE_tmd__RelayOutputOptionsExtension (995)
/* Type tmd__RelayOutputOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:RelayOutputOptionsExtension complex type: */
class SOAP_CMAC tmd__RelayOutputOptionsExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptionsExtension (995)
	virtual int soap_type(void) const { return 995; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptionsExtension, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptionsExtension); }
	         tmd__RelayOutputOptionsExtension() { tmd__RelayOutputOptionsExtension::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptionsExtension() { }
	friend tmd__RelayOutputOptionsExtension *soap_instantiate_tmd__RelayOutputOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2709 */
#ifndef SOAP_TYPE_tmd__Get
#define SOAP_TYPE_tmd__Get (996)
/* Type tmd__Get is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:Get simple type: */
class SOAP_CMAC tmd__Get : public xsd__anyType
{
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__Get (996)
	virtual int soap_type(void) const { return 996; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__Get, default initialized and not managed by a soap context
	virtual tmd__Get *soap_alloc(void) const { return SOAP_NEW(tmd__Get); }
	         tmd__Get() { tmd__Get::soap_default(NULL); }
	virtual ~tmd__Get() { }
	friend tmd__Get *soap_instantiate_tmd__Get(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2712 */
#ifndef SOAP_TYPE_tmd__GetResponse
#define SOAP_TYPE_tmd__GetResponse (997)
/* Type tmd__GetResponse is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:GetResponse complex type: */
class SOAP_CMAC tmd__GetResponse : public xsd__anyType
{
public:
	std::vector<std::string> Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__GetResponse (997)
	virtual int soap_type(void) const { return 997; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__GetResponse, default initialized and not managed by a soap context
	virtual tmd__GetResponse *soap_alloc(void) const { return SOAP_NEW(tmd__GetResponse); }
	         tmd__GetResponse() { tmd__GetResponse::soap_default(NULL); }
	virtual ~tmd__GetResponse() { }
	friend tmd__GetResponse *soap_instantiate_tmd__GetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2715 */
#ifndef SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions
#define SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions (998)
/* Type tmd__DigitalInputConfigurationInputOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:DigitalInputConfigurationInputOptions complex type: */
class SOAP_CMAC tmd__DigitalInputConfigurationInputOptions : public xsd__anyType
{
public:
	std::vector<enum tt__DigitalIdleState> IdleState;	/* required element of XSD type tt:DigitalIdleState */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions (998)
	virtual int soap_type(void) const { return 998; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__DigitalInputConfigurationInputOptions, default initialized and not managed by a soap context
	virtual tmd__DigitalInputConfigurationInputOptions *soap_alloc(void) const { return SOAP_NEW(tmd__DigitalInputConfigurationInputOptions); }
	         tmd__DigitalInputConfigurationInputOptions() { tmd__DigitalInputConfigurationInputOptions::soap_default(NULL); }
	virtual ~tmd__DigitalInputConfigurationInputOptions() { }
	friend tmd__DigitalInputConfigurationInputOptions *soap_instantiate_tmd__DigitalInputConfigurationInputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:28013 */
#ifndef SOAP_TYPE__tmd__union_SerialData
#define SOAP_TYPE__tmd__union_SerialData (2181)
/* xsd:choice complex type: */
union _tmd__union_SerialData
{
#define SOAP_UNION__tmd__union_SerialData_Binary	(1)
	xsd__base64Binary *Binary;
#define SOAP_UNION__tmd__union_SerialData_String	(2)
	std::string *String;
};
#endif

/* onvif.h:2718 */
#ifndef SOAP_TYPE_tmd__SerialData
#define SOAP_TYPE_tmd__SerialData (999)
/* Type tmd__SerialData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialData complex type: */
class SOAP_CMAC tmd__SerialData : public xsd__anyType
{
public:
	int __union_SerialData;	/* union discriminant (of union defined below) */
	union _tmd__union_SerialData union_SerialData;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialData (999)
	virtual int soap_type(void) const { return 999; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialData, default initialized and not managed by a soap context
	virtual tmd__SerialData *soap_alloc(void) const { return SOAP_NEW(tmd__SerialData); }
	         tmd__SerialData() { tmd__SerialData::soap_default(NULL); }
	virtual ~tmd__SerialData() { }
	friend tmd__SerialData *soap_instantiate_tmd__SerialData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2724 */
#ifndef SOAP_TYPE_tmd__SerialPortConfiguration
#define SOAP_TYPE_tmd__SerialPortConfiguration (1001)
/* Type tmd__SerialPortConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortConfiguration complex type: */
class SOAP_CMAC tmd__SerialPortConfiguration : public xsd__anyType
{
public:
	int BaudRate;	/* required element of XSD type xsd:int */
	enum tmd__ParityBit ParityBit;	/* required element of XSD type tmd:ParityBit */
	int CharacterLength;	/* required element of XSD type xsd:int */
	float StopBit;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	enum tmd__SerialPortType type;	/* required attribute of XSD type tmd:SerialPortType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfiguration (1001)
	virtual int soap_type(void) const { return 1001; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfiguration, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfiguration); }
	         tmd__SerialPortConfiguration() { tmd__SerialPortConfiguration::soap_default(NULL); }
	virtual ~tmd__SerialPortConfiguration() { }
	friend tmd__SerialPortConfiguration *soap_instantiate_tmd__SerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2727 */
#ifndef SOAP_TYPE_tmd__SerialPortConfigurationOptions
#define SOAP_TYPE_tmd__SerialPortConfigurationOptions (1002)
/* Type tmd__SerialPortConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortConfigurationOptions complex type: */
class SOAP_CMAC tmd__SerialPortConfigurationOptions : public xsd__anyType
{
public:
	tt__IntList *BaudRateList;	/* required element of XSD type tt:IntList */
	tmd__ParityBitList *ParityBitList;	/* required element of XSD type tmd:ParityBitList */
	tt__IntList *CharacterLengthList;	/* required element of XSD type tt:IntList */
	tt__FloatList *StopBitList;	/* required element of XSD type tt:FloatList */
	std::vector<char *> __any;
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfigurationOptions (1002)
	virtual int soap_type(void) const { return 1002; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfigurationOptions); }
	         tmd__SerialPortConfigurationOptions() { tmd__SerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~tmd__SerialPortConfigurationOptions() { }
	friend tmd__SerialPortConfigurationOptions *soap_instantiate_tmd__SerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2730 */
#ifndef SOAP_TYPE_tmd__ParityBitList
#define SOAP_TYPE_tmd__ParityBitList (1003)
/* Type tmd__ParityBitList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:ParityBitList complex type: */
class SOAP_CMAC tmd__ParityBitList : public xsd__anyType
{
public:
	std::vector<enum tmd__ParityBit> Items;	/* optional element of XSD type tmd:ParityBit */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__ParityBitList (1003)
	virtual int soap_type(void) const { return 1003; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__ParityBitList, default initialized and not managed by a soap context
	virtual tmd__ParityBitList *soap_alloc(void) const { return SOAP_NEW(tmd__ParityBitList); }
	         tmd__ParityBitList() { tmd__ParityBitList::soap_default(NULL); }
	virtual ~tmd__ParityBitList() { }
	friend tmd__ParityBitList *soap_instantiate_tmd__ParityBitList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2733 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilities
#define SOAP_TYPE__tmd__GetServiceCapabilities (1004)
/* tmd:GetServiceCapabilities complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilities (1004)
	virtual int soap_type(void) const { return 1004; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilities); }
	         _tmd__GetServiceCapabilities() { _tmd__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilities() { }
	friend _tmd__GetServiceCapabilities *soap_instantiate__tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2736 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (1005)
/* tmd:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilitiesResponse
{
public:
	tmd__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (1005)
	virtual int soap_type(void) const { return 1005; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilitiesResponse); }
	         _tmd__GetServiceCapabilitiesResponse() { _tmd__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilitiesResponse() { }
	friend _tmd__GetServiceCapabilitiesResponse *soap_instantiate__tmd__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2739 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptions
#define SOAP_TYPE__tmd__GetRelayOutputOptions (1006)
/* tmd:GetRelayOutputOptions complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptions
{
public:
	std::string *RelayOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptions (1006)
	virtual int soap_type(void) const { return 1006; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptions, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptions); }
	         _tmd__GetRelayOutputOptions() { _tmd__GetRelayOutputOptions::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptions() { }
	friend _tmd__GetRelayOutputOptions *soap_instantiate__tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2742 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
#define SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (1007)
/* tmd:GetRelayOutputOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptionsResponse
{
public:
	std::vector<tmd__RelayOutputOptions *> RelayOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:RelayOutputOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (1007)
	virtual int soap_type(void) const { return 1007; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptionsResponse); }
	         _tmd__GetRelayOutputOptionsResponse() { _tmd__GetRelayOutputOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptionsResponse() { }
	friend _tmd__GetRelayOutputOptionsResponse *soap_instantiate__tmd__GetRelayOutputOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2745 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputs
#define SOAP_TYPE__tmd__GetVideoOutputs (1008)
/* tmd:GetVideoOutputs complex type: */
class SOAP_CMAC _tmd__GetVideoOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputs (1008)
	virtual int soap_type(void) const { return 1008; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputs, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputs); }
	         _tmd__GetVideoOutputs() { _tmd__GetVideoOutputs::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputs() { }
	friend _tmd__GetVideoOutputs *soap_instantiate__tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2748 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputsResponse
#define SOAP_TYPE__tmd__GetVideoOutputsResponse (1009)
/* tmd:GetVideoOutputsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputsResponse
{
public:
	std::vector<tt__VideoOutput *> VideoOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputsResponse (1009)
	virtual int soap_type(void) const { return 1009; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputsResponse); }
	         _tmd__GetVideoOutputsResponse() { _tmd__GetVideoOutputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputsResponse() { }
	friend _tmd__GetVideoOutputsResponse *soap_instantiate__tmd__GetVideoOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2751 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfiguration
#define SOAP_TYPE__tmd__GetAudioSourceConfiguration (1010)
/* tmd:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfiguration
{
public:
	std::string AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfiguration (1010)
	virtual int soap_type(void) const { return 1010; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfiguration); }
	         _tmd__GetAudioSourceConfiguration() { _tmd__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfiguration() { }
	friend _tmd__GetAudioSourceConfiguration *soap_instantiate__tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2754 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (1011)
/* tmd:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (1011)
	virtual int soap_type(void) const { return 1011; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationResponse); }
	         _tmd__GetAudioSourceConfigurationResponse() { _tmd__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationResponse() { }
	friend _tmd__GetAudioSourceConfigurationResponse *soap_instantiate__tmd__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2757 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfiguration
#define SOAP_TYPE__tmd__GetAudioOutputConfiguration (1012)
/* tmd:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfiguration
{
public:
	std::string AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfiguration (1012)
	virtual int soap_type(void) const { return 1012; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfiguration); }
	         _tmd__GetAudioOutputConfiguration() { _tmd__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfiguration() { }
	friend _tmd__GetAudioOutputConfiguration *soap_instantiate__tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2760 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (1013)
/* tmd:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (1013)
	virtual int soap_type(void) const { return 1013; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationResponse); }
	         _tmd__GetAudioOutputConfigurationResponse() { _tmd__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationResponse() { }
	friend _tmd__GetAudioOutputConfigurationResponse *soap_instantiate__tmd__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2763 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfiguration
#define SOAP_TYPE__tmd__GetVideoSourceConfiguration (1014)
/* tmd:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfiguration
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfiguration (1014)
	virtual int soap_type(void) const { return 1014; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfiguration); }
	         _tmd__GetVideoSourceConfiguration() { _tmd__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfiguration() { }
	friend _tmd__GetVideoSourceConfiguration *soap_instantiate__tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2766 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (1015)
/* tmd:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (1015)
	virtual int soap_type(void) const { return 1015; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationResponse); }
	         _tmd__GetVideoSourceConfigurationResponse() { _tmd__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationResponse() { }
	friend _tmd__GetVideoSourceConfigurationResponse *soap_instantiate__tmd__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2769 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfiguration
#define SOAP_TYPE__tmd__GetVideoOutputConfiguration (1016)
/* tmd:GetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfiguration
{
public:
	std::string VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfiguration (1016)
	virtual int soap_type(void) const { return 1016; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfiguration); }
	         _tmd__GetVideoOutputConfiguration() { _tmd__GetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfiguration() { }
	friend _tmd__GetVideoOutputConfiguration *soap_instantiate__tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2772 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (1017)
/* tmd:GetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationResponse
{
public:
	tt__VideoOutputConfiguration *VideoOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (1017)
	virtual int soap_type(void) const { return 1017; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationResponse); }
	         _tmd__GetVideoOutputConfigurationResponse() { _tmd__GetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationResponse() { }
	friend _tmd__GetVideoOutputConfigurationResponse *soap_instantiate__tmd__GetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2775 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfiguration
#define SOAP_TYPE__tmd__SetAudioSourceConfiguration (1018)
/* tmd:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfiguration (1018)
	virtual int soap_type(void) const { return 1018; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfiguration); }
	         _tmd__SetAudioSourceConfiguration() { _tmd__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfiguration() { }
	friend _tmd__SetAudioSourceConfiguration *soap_instantiate__tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2778 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (1019)
/* tmd:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (1019)
	virtual int soap_type(void) const { return 1019; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfigurationResponse); }
	         _tmd__SetAudioSourceConfigurationResponse() { _tmd__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfigurationResponse() { }
	friend _tmd__SetAudioSourceConfigurationResponse *soap_instantiate__tmd__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2781 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfiguration
#define SOAP_TYPE__tmd__SetAudioOutputConfiguration (1020)
/* tmd:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfiguration (1020)
	virtual int soap_type(void) const { return 1020; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfiguration); }
	         _tmd__SetAudioOutputConfiguration() { _tmd__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfiguration() { }
	friend _tmd__SetAudioOutputConfiguration *soap_instantiate__tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2784 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (1021)
/* tmd:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (1021)
	virtual int soap_type(void) const { return 1021; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfigurationResponse); }
	         _tmd__SetAudioOutputConfigurationResponse() { _tmd__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfigurationResponse() { }
	friend _tmd__SetAudioOutputConfigurationResponse *soap_instantiate__tmd__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2787 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfiguration
#define SOAP_TYPE__tmd__SetVideoSourceConfiguration (1022)
/* tmd:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfiguration (1022)
	virtual int soap_type(void) const { return 1022; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfiguration); }
	         _tmd__SetVideoSourceConfiguration() { _tmd__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfiguration() { }
	friend _tmd__SetVideoSourceConfiguration *soap_instantiate__tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2790 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (1023)
/* tmd:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (1023)
	virtual int soap_type(void) const { return 1023; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfigurationResponse); }
	         _tmd__SetVideoSourceConfigurationResponse() { _tmd__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfigurationResponse() { }
	friend _tmd__SetVideoSourceConfigurationResponse *soap_instantiate__tmd__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2793 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfiguration
#define SOAP_TYPE__tmd__SetVideoOutputConfiguration (1024)
/* tmd:SetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfiguration
{
public:
	tt__VideoOutputConfiguration *Configuration;	/* required element of XSD type tt:VideoOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfiguration (1024)
	virtual int soap_type(void) const { return 1024; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfiguration); }
	         _tmd__SetVideoOutputConfiguration() { _tmd__SetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfiguration() { }
	friend _tmd__SetVideoOutputConfiguration *soap_instantiate__tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2796 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (1025)
/* tmd:SetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfigurationResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (1025)
	virtual int soap_type(void) const { return 1025; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfigurationResponse); }
	         _tmd__SetVideoOutputConfigurationResponse() { _tmd__SetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfigurationResponse() { }
	friend _tmd__SetVideoOutputConfigurationResponse *soap_instantiate__tmd__SetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2799 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (1026)
/* tmd:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptions
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (1026)
	virtual int soap_type(void) const { return 1026; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptions); }
	         _tmd__GetVideoSourceConfigurationOptions() { _tmd__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptions() { }
	friend _tmd__GetVideoSourceConfigurationOptions *soap_instantiate__tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2802 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (1027)
/* tmd:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *VideoSourceConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (1027)
	virtual int soap_type(void) const { return 1027; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptionsResponse); }
	         _tmd__GetVideoSourceConfigurationOptionsResponse() { _tmd__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptionsResponse() { }
	friend _tmd__GetVideoSourceConfigurationOptionsResponse *soap_instantiate__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2805 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (1028)
/* tmd:GetVideoOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptions
{
public:
	std::string VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (1028)
	virtual int soap_type(void) const { return 1028; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptions); }
	         _tmd__GetVideoOutputConfigurationOptions() { _tmd__GetVideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptions() { }
	friend _tmd__GetVideoOutputConfigurationOptions *soap_instantiate__tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2808 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (1029)
/* tmd:GetVideoOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptionsResponse
{
public:
	tt__VideoOutputConfigurationOptions *VideoOutputConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfigurationOptions */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (1029)
	virtual int soap_type(void) const { return 1029; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptionsResponse); }
	         _tmd__GetVideoOutputConfigurationOptionsResponse() { _tmd__GetVideoOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptionsResponse() { }
	friend _tmd__GetVideoOutputConfigurationOptionsResponse *soap_instantiate__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2811 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (1030)
/* tmd:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptions
{
public:
	std::string AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (1030)
	virtual int soap_type(void) const { return 1030; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptions); }
	         _tmd__GetAudioSourceConfigurationOptions() { _tmd__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptions() { }
	friend _tmd__GetAudioSourceConfigurationOptions *soap_instantiate__tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2814 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (1031)
/* tmd:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *AudioSourceOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (1031)
	virtual int soap_type(void) const { return 1031; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptionsResponse); }
	         _tmd__GetAudioSourceConfigurationOptionsResponse() { _tmd__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptionsResponse() { }
	friend _tmd__GetAudioSourceConfigurationOptionsResponse *soap_instantiate__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2817 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (1032)
/* tmd:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptions
{
public:
	std::string AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (1032)
	virtual int soap_type(void) const { return 1032; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptions); }
	         _tmd__GetAudioOutputConfigurationOptions() { _tmd__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptions() { }
	friend _tmd__GetAudioOutputConfigurationOptions *soap_instantiate__tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2820 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (1033)
/* tmd:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *AudioOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (1033)
	virtual int soap_type(void) const { return 1033; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptionsResponse); }
	         _tmd__GetAudioOutputConfigurationOptionsResponse() { _tmd__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptionsResponse() { }
	friend _tmd__GetAudioOutputConfigurationOptionsResponse *soap_instantiate__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2823 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettings
#define SOAP_TYPE__tmd__SetRelayOutputSettings (1034)
/* tmd:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettings
{
public:
	tt__RelayOutput *RelayOutput;	/* required element of XSD type tt:RelayOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettings (1034)
	virtual int soap_type(void) const { return 1034; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettings); }
	         _tmd__SetRelayOutputSettings() { _tmd__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettings() { }
	friend _tmd__SetRelayOutputSettings *soap_instantiate__tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2826 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (1035)
/* tmd:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (1035)
	virtual int soap_type(void) const { return 1035; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettingsResponse); }
	         _tmd__SetRelayOutputSettingsResponse() { _tmd__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettingsResponse() { }
	friend _tmd__SetRelayOutputSettingsResponse *soap_instantiate__tmd__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2829 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputs
#define SOAP_TYPE__tmd__GetDigitalInputs (1036)
/* tmd:GetDigitalInputs complex type: */
class SOAP_CMAC _tmd__GetDigitalInputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputs (1036)
	virtual int soap_type(void) const { return 1036; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputs, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputs); }
	         _tmd__GetDigitalInputs() { _tmd__GetDigitalInputs::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputs() { }
	friend _tmd__GetDigitalInputs *soap_instantiate__tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2832 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputsResponse
#define SOAP_TYPE__tmd__GetDigitalInputsResponse (1037)
/* tmd:GetDigitalInputsResponse complex type: */
class SOAP_CMAC _tmd__GetDigitalInputsResponse
{
public:
	std::vector<tt__DigitalInput *> DigitalInputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:DigitalInput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputsResponse (1037)
	virtual int soap_type(void) const { return 1037; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputsResponse); }
	         _tmd__GetDigitalInputsResponse() { _tmd__GetDigitalInputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputsResponse() { }
	friend _tmd__GetDigitalInputsResponse *soap_instantiate__tmd__GetDigitalInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2835 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (1038)
/* tmd:GetDigitalInputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptions
{
public:
	std::string *Token;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (1038)
	virtual int soap_type(void) const { return 1038; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputConfigurationOptions); }
	         _tmd__GetDigitalInputConfigurationOptions() { _tmd__GetDigitalInputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputConfigurationOptions() { }
	friend _tmd__GetDigitalInputConfigurationOptions *soap_instantiate__tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2838 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (1039)
/* tmd:GetDigitalInputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptionsResponse
{
public:
	tmd__DigitalInputConfigurationInputOptions *DigitalInputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:DigitalInputConfigurationInputOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (1039)
	virtual int soap_type(void) const { return 1039; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputConfigurationOptionsResponse); }
	         _tmd__GetDigitalInputConfigurationOptionsResponse() { _tmd__GetDigitalInputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputConfigurationOptionsResponse() { }
	friend _tmd__GetDigitalInputConfigurationOptionsResponse *soap_instantiate__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2841 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurations
#define SOAP_TYPE__tmd__SetDigitalInputConfigurations (1040)
/* tmd:SetDigitalInputConfigurations complex type: */
class SOAP_CMAC _tmd__SetDigitalInputConfigurations
{
public:
	std::vector<tt__DigitalInput *> DigitalInputs;	/* required element of XSD type tt:DigitalInput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetDigitalInputConfigurations (1040)
	virtual int soap_type(void) const { return 1040; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetDigitalInputConfigurations, default initialized and not managed by a soap context
	virtual _tmd__SetDigitalInputConfigurations *soap_alloc(void) const { return SOAP_NEW(_tmd__SetDigitalInputConfigurations); }
	         _tmd__SetDigitalInputConfigurations() { _tmd__SetDigitalInputConfigurations::soap_default(NULL); }
	virtual ~_tmd__SetDigitalInputConfigurations() { }
	friend _tmd__SetDigitalInputConfigurations *soap_instantiate__tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2844 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse
#define SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (1041)
/* tmd:SetDigitalInputConfigurationsResponse complex type: */
class SOAP_CMAC _tmd__SetDigitalInputConfigurationsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (1041)
	virtual int soap_type(void) const { return 1041; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetDigitalInputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tmd__SetDigitalInputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetDigitalInputConfigurationsResponse); }
	         _tmd__SetDigitalInputConfigurationsResponse() { _tmd__SetDigitalInputConfigurationsResponse::soap_default(NULL); }
	virtual ~_tmd__SetDigitalInputConfigurationsResponse() { }
	friend _tmd__SetDigitalInputConfigurationsResponse *soap_instantiate__tmd__SetDigitalInputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2847 */
#ifndef SOAP_TYPE__tmd__GetSerialPorts
#define SOAP_TYPE__tmd__GetSerialPorts (1042)
/* tmd:GetSerialPorts complex type: */
class SOAP_CMAC _tmd__GetSerialPorts
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPorts (1042)
	virtual int soap_type(void) const { return 1042; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPorts, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPorts *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPorts); }
	         _tmd__GetSerialPorts() { _tmd__GetSerialPorts::soap_default(NULL); }
	virtual ~_tmd__GetSerialPorts() { }
	friend _tmd__GetSerialPorts *soap_instantiate__tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2850 */
#ifndef SOAP_TYPE__tmd__GetSerialPortsResponse
#define SOAP_TYPE__tmd__GetSerialPortsResponse (1043)
/* tmd:GetSerialPortsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortsResponse
{
public:
	std::vector<tmd__SerialPort *> SerialPort;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:SerialPort */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortsResponse (1043)
	virtual int soap_type(void) const { return 1043; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortsResponse); }
	         _tmd__GetSerialPortsResponse() { _tmd__GetSerialPortsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortsResponse() { }
	friend _tmd__GetSerialPortsResponse *soap_instantiate__tmd__GetSerialPortsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2853 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfiguration
#define SOAP_TYPE__tmd__GetSerialPortConfiguration (1044)
/* tmd:GetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfiguration
{
public:
	std::string SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfiguration (1044)
	virtual int soap_type(void) const { return 1044; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfiguration); }
	         _tmd__GetSerialPortConfiguration() { _tmd__GetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfiguration() { }
	friend _tmd__GetSerialPortConfiguration *soap_instantiate__tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2856 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (1045)
/* tmd:GetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationResponse
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (1045)
	virtual int soap_type(void) const { return 1045; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationResponse); }
	         _tmd__GetSerialPortConfigurationResponse() { _tmd__GetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationResponse() { }
	friend _tmd__GetSerialPortConfigurationResponse *soap_instantiate__tmd__GetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2859 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfiguration
#define SOAP_TYPE__tmd__SetSerialPortConfiguration (1046)
/* tmd:SetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfiguration
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* required element of XSD type tmd:SerialPortConfiguration */
	bool ForcePersistance;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfiguration (1046)
	virtual int soap_type(void) const { return 1046; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfiguration); }
	         _tmd__SetSerialPortConfiguration() { _tmd__SetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfiguration() { }
	friend _tmd__SetSerialPortConfiguration *soap_instantiate__tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2862 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (1047)
/* tmd:SetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (1047)
	virtual int soap_type(void) const { return 1047; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfigurationResponse); }
	         _tmd__SetSerialPortConfigurationResponse() { _tmd__SetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfigurationResponse() { }
	friend _tmd__SetSerialPortConfigurationResponse *soap_instantiate__tmd__SetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2865 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (1048)
/* tmd:GetSerialPortConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptions
{
public:
	std::string SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (1048)
	virtual int soap_type(void) const { return 1048; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptions); }
	         _tmd__GetSerialPortConfigurationOptions() { _tmd__GetSerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptions() { }
	friend _tmd__GetSerialPortConfigurationOptions *soap_instantiate__tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2868 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (1049)
/* tmd:GetSerialPortConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptionsResponse
{
public:
	tmd__SerialPortConfigurationOptions *SerialPortOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (1049)
	virtual int soap_type(void) const { return 1049; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptionsResponse); }
	         _tmd__GetSerialPortConfigurationOptionsResponse() { _tmd__GetSerialPortConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptionsResponse() { }
	friend _tmd__GetSerialPortConfigurationOptionsResponse *soap_instantiate__tmd__GetSerialPortConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2871 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommand
#define SOAP_TYPE__tmd__SendReceiveSerialCommand (1050)
/* tmd:SendReceiveSerialCommand complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommand
{
public:
	tmd__SerialData *SerialData;	/* optional element of XSD type tmd:SerialData */
	LONG64 *TimeOut;	/* optional element of XSD type xsd:duration */
	std::string *DataLength;	/* optional element of XSD type xsd:integer */
	std::string *Delimiter;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommand (1050)
	virtual int soap_type(void) const { return 1050; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommand, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommand *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommand); }
	         _tmd__SendReceiveSerialCommand() { _tmd__SendReceiveSerialCommand::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommand() { }
	friend _tmd__SendReceiveSerialCommand *soap_instantiate__tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2874 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
#define SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (1051)
/* tmd:SendReceiveSerialCommandResponse complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommandResponse
{
public:
	tmd__SerialData *SerialData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:SerialData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (1051)
	virtual int soap_type(void) const { return 1051; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommandResponse, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommandResponse); }
	         _tmd__SendReceiveSerialCommandResponse() { _tmd__SendReceiveSerialCommandResponse::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommandResponse() { }
	friend _tmd__SendReceiveSerialCommandResponse *soap_instantiate__tmd__SendReceiveSerialCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2877 */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (1052)
/* Type timg__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* timg:Capabilities complex type: */
class SOAP_CMAC timg__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *ImageStabilization;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_timg__Capabilities (1052)
	virtual int soap_type(void) const { return 1052; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type timg__Capabilities, default initialized and not managed by a soap context
	virtual timg__Capabilities *soap_alloc(void) const { return SOAP_NEW(timg__Capabilities); }
	         timg__Capabilities() { timg__Capabilities::soap_default(NULL); }
	virtual ~timg__Capabilities() { }
	friend timg__Capabilities *soap_instantiate_timg__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2880 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (1053)
/* timg:GetServiceCapabilities complex type: */
class SOAP_CMAC _timg__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetServiceCapabilities (1053)
	virtual int soap_type(void) const { return 1053; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _timg__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_timg__GetServiceCapabilities); }
	         _timg__GetServiceCapabilities() { _timg__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_timg__GetServiceCapabilities() { }
	friend _timg__GetServiceCapabilities *soap_instantiate__timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2883 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (1054)
/* timg:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _timg__GetServiceCapabilitiesResponse
{
public:
	timg__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type timg:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetServiceCapabilitiesResponse (1054)
	virtual int soap_type(void) const { return 1054; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _timg__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetServiceCapabilitiesResponse); }
	         _timg__GetServiceCapabilitiesResponse() { _timg__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_timg__GetServiceCapabilitiesResponse() { }
	friend _timg__GetServiceCapabilitiesResponse *soap_instantiate__timg__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2886 */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (1055)
/* timg:GetImagingSettings complex type: */
class SOAP_CMAC _timg__GetImagingSettings
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetImagingSettings (1055)
	virtual int soap_type(void) const { return 1055; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetImagingSettings, default initialized and not managed by a soap context
	virtual _timg__GetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_timg__GetImagingSettings); }
	         _timg__GetImagingSettings() { _timg__GetImagingSettings::soap_default(NULL); }
	virtual ~_timg__GetImagingSettings() { }
	friend _timg__GetImagingSettings *soap_instantiate__timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2889 */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (1056)
/* timg:GetImagingSettingsResponse complex type: */
class SOAP_CMAC _timg__GetImagingSettingsResponse
{
public:
	tt__ImagingSettings20 *ImagingSettings;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingSettings20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetImagingSettingsResponse (1056)
	virtual int soap_type(void) const { return 1056; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetImagingSettingsResponse, default initialized and not managed by a soap context
	virtual _timg__GetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetImagingSettingsResponse); }
	         _timg__GetImagingSettingsResponse() { _timg__GetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__GetImagingSettingsResponse() { }
	friend _timg__GetImagingSettingsResponse *soap_instantiate__timg__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2892 */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (1057)
/* timg:SetImagingSettings complex type: */
class SOAP_CMAC _timg__SetImagingSettings
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__ImagingSettings20 *ImagingSettings;	/* required element of XSD type tt:ImagingSettings20 */
	bool *ForcePersistence;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__SetImagingSettings (1057)
	virtual int soap_type(void) const { return 1057; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__SetImagingSettings, default initialized and not managed by a soap context
	virtual _timg__SetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_timg__SetImagingSettings); }
	         _timg__SetImagingSettings() { _timg__SetImagingSettings::soap_default(NULL); }
	virtual ~_timg__SetImagingSettings() { }
	friend _timg__SetImagingSettings *soap_instantiate__timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2895 */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (1058)
/* timg:SetImagingSettingsResponse complex type: */
class SOAP_CMAC _timg__SetImagingSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__SetImagingSettingsResponse (1058)
	virtual int soap_type(void) const { return 1058; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__SetImagingSettingsResponse, default initialized and not managed by a soap context
	virtual _timg__SetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__SetImagingSettingsResponse); }
	         _timg__SetImagingSettingsResponse() { _timg__SetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__SetImagingSettingsResponse() { }
	friend _timg__SetImagingSettingsResponse *soap_instantiate__timg__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2898 */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (1059)
/* timg:GetOptions complex type: */
class SOAP_CMAC _timg__GetOptions
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetOptions (1059)
	virtual int soap_type(void) const { return 1059; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetOptions, default initialized and not managed by a soap context
	virtual _timg__GetOptions *soap_alloc(void) const { return SOAP_NEW(_timg__GetOptions); }
	         _timg__GetOptions() { _timg__GetOptions::soap_default(NULL); }
	virtual ~_timg__GetOptions() { }
	friend _timg__GetOptions *soap_instantiate__timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2901 */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (1060)
/* timg:GetOptionsResponse complex type: */
class SOAP_CMAC _timg__GetOptionsResponse
{
public:
	tt__ImagingOptions20 *ImagingOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingOptions20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetOptionsResponse (1060)
	virtual int soap_type(void) const { return 1060; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetOptionsResponse, default initialized and not managed by a soap context
	virtual _timg__GetOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetOptionsResponse); }
	         _timg__GetOptionsResponse() { _timg__GetOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetOptionsResponse() { }
	friend _timg__GetOptionsResponse *soap_instantiate__timg__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2904 */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (1061)
/* timg:Move complex type: */
class SOAP_CMAC _timg__Move
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__FocusMove *Focus;	/* required element of XSD type tt:FocusMove */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__Move (1061)
	virtual int soap_type(void) const { return 1061; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__Move, default initialized and not managed by a soap context
	virtual _timg__Move *soap_alloc(void) const { return SOAP_NEW(_timg__Move); }
	         _timg__Move() { _timg__Move::soap_default(NULL); }
	virtual ~_timg__Move() { }
	friend _timg__Move *soap_instantiate__timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2907 */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (1062)
/* timg:MoveResponse complex type: */
class SOAP_CMAC _timg__MoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__MoveResponse (1062)
	virtual int soap_type(void) const { return 1062; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__MoveResponse, default initialized and not managed by a soap context
	virtual _timg__MoveResponse *soap_alloc(void) const { return SOAP_NEW(_timg__MoveResponse); }
	         _timg__MoveResponse() { _timg__MoveResponse::soap_default(NULL); }
	virtual ~_timg__MoveResponse() { }
	friend _timg__MoveResponse *soap_instantiate__timg__MoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2910 */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (1063)
/* timg:GetMoveOptions complex type: */
class SOAP_CMAC _timg__GetMoveOptions
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetMoveOptions (1063)
	virtual int soap_type(void) const { return 1063; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetMoveOptions, default initialized and not managed by a soap context
	virtual _timg__GetMoveOptions *soap_alloc(void) const { return SOAP_NEW(_timg__GetMoveOptions); }
	         _timg__GetMoveOptions() { _timg__GetMoveOptions::soap_default(NULL); }
	virtual ~_timg__GetMoveOptions() { }
	friend _timg__GetMoveOptions *soap_instantiate__timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2913 */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (1064)
/* timg:GetMoveOptionsResponse complex type: */
class SOAP_CMAC _timg__GetMoveOptionsResponse
{
public:
	tt__MoveOptions20 *MoveOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MoveOptions20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetMoveOptionsResponse (1064)
	virtual int soap_type(void) const { return 1064; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetMoveOptionsResponse, default initialized and not managed by a soap context
	virtual _timg__GetMoveOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetMoveOptionsResponse); }
	         _timg__GetMoveOptionsResponse() { _timg__GetMoveOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetMoveOptionsResponse() { }
	friend _timg__GetMoveOptionsResponse *soap_instantiate__timg__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2916 */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (1065)
/* timg:Stop complex type: */
class SOAP_CMAC _timg__Stop
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__Stop (1065)
	virtual int soap_type(void) const { return 1065; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__Stop, default initialized and not managed by a soap context
	virtual _timg__Stop *soap_alloc(void) const { return SOAP_NEW(_timg__Stop); }
	         _timg__Stop() { _timg__Stop::soap_default(NULL); }
	virtual ~_timg__Stop() { }
	friend _timg__Stop *soap_instantiate__timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2919 */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (1066)
/* timg:StopResponse complex type: */
class SOAP_CMAC _timg__StopResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__StopResponse (1066)
	virtual int soap_type(void) const { return 1066; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__StopResponse, default initialized and not managed by a soap context
	virtual _timg__StopResponse *soap_alloc(void) const { return SOAP_NEW(_timg__StopResponse); }
	         _timg__StopResponse() { _timg__StopResponse::soap_default(NULL); }
	virtual ~_timg__StopResponse() { }
	friend _timg__StopResponse *soap_instantiate__timg__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2922 */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (1067)
/* timg:GetStatus complex type: */
class SOAP_CMAC _timg__GetStatus
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetStatus (1067)
	virtual int soap_type(void) const { return 1067; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetStatus, default initialized and not managed by a soap context
	virtual _timg__GetStatus *soap_alloc(void) const { return SOAP_NEW(_timg__GetStatus); }
	         _timg__GetStatus() { _timg__GetStatus::soap_default(NULL); }
	virtual ~_timg__GetStatus() { }
	friend _timg__GetStatus *soap_instantiate__timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2925 */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (1068)
/* timg:GetStatusResponse complex type: */
class SOAP_CMAC _timg__GetStatusResponse
{
public:
	tt__ImagingStatus20 *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingStatus20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetStatusResponse (1068)
	virtual int soap_type(void) const { return 1068; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetStatusResponse, default initialized and not managed by a soap context
	virtual _timg__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetStatusResponse); }
	         _timg__GetStatusResponse() { _timg__GetStatusResponse::soap_default(NULL); }
	virtual ~_timg__GetStatusResponse() { }
	friend _timg__GetStatusResponse *soap_instantiate__timg__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2928 */
#ifndef SOAP_TYPE_trt__Capabilities
#define SOAP_TYPE_trt__Capabilities (1069)
/* Type trt__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:Capabilities complex type: */
class SOAP_CMAC trt__Capabilities : public xsd__anyType
{
public:
	trt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type trt:ProfileCapabilities */
	trt__StreamingCapabilities *StreamingCapabilities;	/* required element of XSD type trt:StreamingCapabilities */
	std::vector<char *> __any;
	bool *SnapshotUri;	/* optional attribute of XSD type xsd:boolean */
	bool *Rotation;	/* optional attribute of XSD type xsd:boolean */
	bool *VideoSourceMode;	/* optional attribute of XSD type xsd:boolean */
	bool *OSD;	/* optional attribute of XSD type xsd:boolean */
	bool *EXICompression;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__Capabilities (1069)
	virtual int soap_type(void) const { return 1069; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__Capabilities, default initialized and not managed by a soap context
	virtual trt__Capabilities *soap_alloc(void) const { return SOAP_NEW(trt__Capabilities); }
	         trt__Capabilities() { trt__Capabilities::soap_default(NULL); }
	virtual ~trt__Capabilities() { }
	friend trt__Capabilities *soap_instantiate_trt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2931 */
#ifndef SOAP_TYPE_trt__ProfileCapabilities
#define SOAP_TYPE_trt__ProfileCapabilities (1070)
/* Type trt__ProfileCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:ProfileCapabilities complex type: */
class SOAP_CMAC trt__ProfileCapabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	int *MaximumNumberOfProfiles;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__ProfileCapabilities (1070)
	virtual int soap_type(void) const { return 1070; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual trt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__ProfileCapabilities); }
	         trt__ProfileCapabilities() { trt__ProfileCapabilities::soap_default(NULL); }
	virtual ~trt__ProfileCapabilities() { }
	friend trt__ProfileCapabilities *soap_instantiate_trt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2934 */
#ifndef SOAP_TYPE_trt__StreamingCapabilities
#define SOAP_TYPE_trt__StreamingCapabilities (1071)
/* Type trt__StreamingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:StreamingCapabilities complex type: */
class SOAP_CMAC trt__StreamingCapabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *RTPMulticast;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *NonAggregateControl;	/* optional attribute of XSD type xsd:boolean */
	bool *NoRTSPStreaming;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__StreamingCapabilities (1071)
	virtual int soap_type(void) const { return 1071; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__StreamingCapabilities, default initialized and not managed by a soap context
	virtual trt__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__StreamingCapabilities); }
	         trt__StreamingCapabilities() { trt__StreamingCapabilities::soap_default(NULL); }
	virtual ~trt__StreamingCapabilities() { }
	friend trt__StreamingCapabilities *soap_instantiate_trt__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2937 */
#ifndef SOAP_TYPE_trt__VideoSourceMode
#define SOAP_TYPE_trt__VideoSourceMode (1072)
/* Type trt__VideoSourceMode is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:VideoSourceMode complex type: */
class SOAP_CMAC trt__VideoSourceMode : public xsd__anyType
{
public:
	float MaxFramerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *MaxResolution;	/* required element of XSD type tt:VideoResolution */
	std::string Encodings;	/* required element of XSD type trt:EncodingTypes */
	bool Reboot;	/* required element of XSD type xsd:boolean */
	std::string *Description;	/* optional element of XSD type tt:Description */
	trt__VideoSourceModeExtension *Extension;	/* optional element of XSD type trt:VideoSourceModeExtension */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *Enabled;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__VideoSourceMode (1072)
	virtual int soap_type(void) const { return 1072; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__VideoSourceMode, default initialized and not managed by a soap context
	virtual trt__VideoSourceMode *soap_alloc(void) const { return SOAP_NEW(trt__VideoSourceMode); }
	         trt__VideoSourceMode() { trt__VideoSourceMode::soap_default(NULL); }
	virtual ~trt__VideoSourceMode() { }
	friend trt__VideoSourceMode *soap_instantiate_trt__VideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2940 */
#ifndef SOAP_TYPE_trt__VideoSourceModeExtension
#define SOAP_TYPE_trt__VideoSourceModeExtension (1073)
/* Type trt__VideoSourceModeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:VideoSourceModeExtension complex type: */
class SOAP_CMAC trt__VideoSourceModeExtension : public xsd__anyType
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_trt__VideoSourceModeExtension (1073)
	virtual int soap_type(void) const { return 1073; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__VideoSourceModeExtension, default initialized and not managed by a soap context
	virtual trt__VideoSourceModeExtension *soap_alloc(void) const { return SOAP_NEW(trt__VideoSourceModeExtension); }
	         trt__VideoSourceModeExtension() { trt__VideoSourceModeExtension::soap_default(NULL); }
	virtual ~trt__VideoSourceModeExtension() { }
	friend trt__VideoSourceModeExtension *soap_instantiate_trt__VideoSourceModeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2943 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilities
#define SOAP_TYPE__trt__GetServiceCapabilities (1074)
/* trt:GetServiceCapabilities complex type: */
class SOAP_CMAC _trt__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilities (1074)
	virtual int soap_type(void) const { return 1074; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilities); }
	         _trt__GetServiceCapabilities() { _trt__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilities() { }
	friend _trt__GetServiceCapabilities *soap_instantiate__trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2946 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trt__GetServiceCapabilitiesResponse (1075)
/* trt:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trt__GetServiceCapabilitiesResponse
{
public:
	trt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilitiesResponse (1075)
	virtual int soap_type(void) const { return 1075; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilitiesResponse); }
	         _trt__GetServiceCapabilitiesResponse() { _trt__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilitiesResponse() { }
	friend _trt__GetServiceCapabilitiesResponse *soap_instantiate__trt__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2949 */
#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (1076)
/* trt:GetVideoSources complex type: */
class SOAP_CMAC _trt__GetVideoSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSources (1076)
	virtual int soap_type(void) const { return 1076; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSources, default initialized and not managed by a soap context
	virtual _trt__GetVideoSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSources); }
	         _trt__GetVideoSources() { _trt__GetVideoSources::soap_default(NULL); }
	virtual ~_trt__GetVideoSources() { }
	friend _trt__GetVideoSources *soap_instantiate__trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2952 */
#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (1077)
/* trt:GetVideoSourcesResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourcesResponse
{
public:
	std::vector<tt__VideoSource *> VideoSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoSource */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourcesResponse (1077)
	virtual int soap_type(void) const { return 1077; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourcesResponse); }
	         _trt__GetVideoSourcesResponse() { _trt__GetVideoSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourcesResponse() { }
	friend _trt__GetVideoSourcesResponse *soap_instantiate__trt__GetVideoSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2955 */
#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (1078)
/* trt:GetAudioSources complex type: */
class SOAP_CMAC _trt__GetAudioSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSources (1078)
	virtual int soap_type(void) const { return 1078; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSources, default initialized and not managed by a soap context
	virtual _trt__GetAudioSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSources); }
	         _trt__GetAudioSources() { _trt__GetAudioSources::soap_default(NULL); }
	virtual ~_trt__GetAudioSources() { }
	friend _trt__GetAudioSources *soap_instantiate__trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2958 */
#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (1079)
/* trt:GetAudioSourcesResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourcesResponse
{
public:
	std::vector<tt__AudioSource *> AudioSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioSource */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourcesResponse (1079)
	virtual int soap_type(void) const { return 1079; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourcesResponse); }
	         _trt__GetAudioSourcesResponse() { _trt__GetAudioSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourcesResponse() { }
	friend _trt__GetAudioSourcesResponse *soap_instantiate__trt__GetAudioSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2961 */
#ifndef SOAP_TYPE__trt__GetAudioOutputs
#define SOAP_TYPE__trt__GetAudioOutputs (1080)
/* trt:GetAudioOutputs complex type: */
class SOAP_CMAC _trt__GetAudioOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputs (1080)
	virtual int soap_type(void) const { return 1080; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputs, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputs *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputs); }
	         _trt__GetAudioOutputs() { _trt__GetAudioOutputs::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputs() { }
	friend _trt__GetAudioOutputs *soap_instantiate__trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2964 */
#ifndef SOAP_TYPE__trt__GetAudioOutputsResponse
#define SOAP_TYPE__trt__GetAudioOutputsResponse (1081)
/* trt:GetAudioOutputsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputsResponse
{
public:
	std::vector<tt__AudioOutput *> AudioOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputsResponse (1081)
	virtual int soap_type(void) const { return 1081; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputsResponse); }
	         _trt__GetAudioOutputsResponse() { _trt__GetAudioOutputsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputsResponse() { }
	friend _trt__GetAudioOutputsResponse *soap_instantiate__trt__GetAudioOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2967 */
#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (1082)
/* trt:CreateProfile complex type: */
class SOAP_CMAC _trt__CreateProfile
{
public:
	std::string Name;	/* required element of XSD type tt:Name */
	std::string *Token;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfile (1082)
	virtual int soap_type(void) const { return 1082; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfile, default initialized and not managed by a soap context
	virtual _trt__CreateProfile *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfile); }
	         _trt__CreateProfile() { _trt__CreateProfile::soap_default(NULL); }
	virtual ~_trt__CreateProfile() { }
	friend _trt__CreateProfile *soap_instantiate__trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2970 */
#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (1083)
/* trt:CreateProfileResponse complex type: */
class SOAP_CMAC _trt__CreateProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfileResponse (1083)
	virtual int soap_type(void) const { return 1083; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfileResponse, default initialized and not managed by a soap context
	virtual _trt__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfileResponse); }
	         _trt__CreateProfileResponse() { _trt__CreateProfileResponse::soap_default(NULL); }
	virtual ~_trt__CreateProfileResponse() { }
	friend _trt__CreateProfileResponse *soap_instantiate__trt__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2973 */
#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (1084)
/* trt:GetProfile complex type: */
class SOAP_CMAC _trt__GetProfile
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfile (1084)
	virtual int soap_type(void) const { return 1084; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfile, default initialized and not managed by a soap context
	virtual _trt__GetProfile *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfile); }
	         _trt__GetProfile() { _trt__GetProfile::soap_default(NULL); }
	virtual ~_trt__GetProfile() { }
	friend _trt__GetProfile *soap_instantiate__trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2976 */
#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (1085)
/* trt:GetProfileResponse complex type: */
class SOAP_CMAC _trt__GetProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfileResponse (1085)
	virtual int soap_type(void) const { return 1085; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfileResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfileResponse); }
	         _trt__GetProfileResponse() { _trt__GetProfileResponse::soap_default(NULL); }
	virtual ~_trt__GetProfileResponse() { }
	friend _trt__GetProfileResponse *soap_instantiate__trt__GetProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2979 */
#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (1086)
/* trt:GetProfiles complex type: */
class SOAP_CMAC _trt__GetProfiles
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfiles (1086)
	virtual int soap_type(void) const { return 1086; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfiles, default initialized and not managed by a soap context
	virtual _trt__GetProfiles *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfiles); }
	         _trt__GetProfiles() { _trt__GetProfiles::soap_default(NULL); }
	virtual ~_trt__GetProfiles() { }
	friend _trt__GetProfiles *soap_instantiate__trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2982 */
#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (1087)
/* trt:GetProfilesResponse complex type: */
class SOAP_CMAC _trt__GetProfilesResponse
{
public:
	std::vector<tt__Profile *> Profiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfilesResponse (1087)
	virtual int soap_type(void) const { return 1087; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfilesResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfilesResponse); }
	         _trt__GetProfilesResponse() { _trt__GetProfilesResponse::soap_default(NULL); }
	virtual ~_trt__GetProfilesResponse() { }
	friend _trt__GetProfilesResponse *soap_instantiate__trt__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2985 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (1088)
/* trt:AddVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfiguration (1088)
	virtual int soap_type(void) const { return 1088; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfiguration); }
	         _trt__AddVideoEncoderConfiguration() { _trt__AddVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfiguration() { }
	friend _trt__AddVideoEncoderConfiguration *soap_instantiate__trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2988 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (1089)
/* trt:AddVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (1089)
	virtual int soap_type(void) const { return 1089; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfigurationResponse); }
	         _trt__AddVideoEncoderConfigurationResponse() { _trt__AddVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfigurationResponse() { }
	friend _trt__AddVideoEncoderConfigurationResponse *soap_instantiate__trt__AddVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2991 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (1090)
/* trt:RemoveVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (1090)
	virtual int soap_type(void) const { return 1090; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfiguration); }
	         _trt__RemoveVideoEncoderConfiguration() { _trt__RemoveVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfiguration() { }
	friend _trt__RemoveVideoEncoderConfiguration *soap_instantiate__trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2994 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (1091)
/* trt:RemoveVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (1091)
	virtual int soap_type(void) const { return 1091; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfigurationResponse); }
	         _trt__RemoveVideoEncoderConfigurationResponse() { _trt__RemoveVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfigurationResponse() { }
	friend _trt__RemoveVideoEncoderConfigurationResponse *soap_instantiate__trt__RemoveVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2997 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (1092)
/* trt:AddVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfiguration (1092)
	virtual int soap_type(void) const { return 1092; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfiguration); }
	         _trt__AddVideoSourceConfiguration() { _trt__AddVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfiguration() { }
	friend _trt__AddVideoSourceConfiguration *soap_instantiate__trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3000 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (1093)
/* trt:AddVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (1093)
	virtual int soap_type(void) const { return 1093; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfigurationResponse); }
	         _trt__AddVideoSourceConfigurationResponse() { _trt__AddVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfigurationResponse() { }
	friend _trt__AddVideoSourceConfigurationResponse *soap_instantiate__trt__AddVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3003 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (1094)
/* trt:RemoveVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfiguration (1094)
	virtual int soap_type(void) const { return 1094; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfiguration); }
	         _trt__RemoveVideoSourceConfiguration() { _trt__RemoveVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfiguration() { }
	friend _trt__RemoveVideoSourceConfiguration *soap_instantiate__trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3006 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (1095)
/* trt:RemoveVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (1095)
	virtual int soap_type(void) const { return 1095; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfigurationResponse); }
	         _trt__RemoveVideoSourceConfigurationResponse() { _trt__RemoveVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfigurationResponse() { }
	friend _trt__RemoveVideoSourceConfigurationResponse *soap_instantiate__trt__RemoveVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3009 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (1096)
/* trt:AddAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfiguration (1096)
	virtual int soap_type(void) const { return 1096; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfiguration); }
	         _trt__AddAudioEncoderConfiguration() { _trt__AddAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfiguration() { }
	friend _trt__AddAudioEncoderConfiguration *soap_instantiate__trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3012 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (1097)
/* trt:AddAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (1097)
	virtual int soap_type(void) const { return 1097; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfigurationResponse); }
	         _trt__AddAudioEncoderConfigurationResponse() { _trt__AddAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfigurationResponse() { }
	friend _trt__AddAudioEncoderConfigurationResponse *soap_instantiate__trt__AddAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3015 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (1098)
/* trt:RemoveAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (1098)
	virtual int soap_type(void) const { return 1098; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfiguration); }
	         _trt__RemoveAudioEncoderConfiguration() { _trt__RemoveAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfiguration() { }
	friend _trt__RemoveAudioEncoderConfiguration *soap_instantiate__trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3018 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (1099)
/* trt:RemoveAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (1099)
	virtual int soap_type(void) const { return 1099; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfigurationResponse); }
	         _trt__RemoveAudioEncoderConfigurationResponse() { _trt__RemoveAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfigurationResponse() { }
	friend _trt__RemoveAudioEncoderConfigurationResponse *soap_instantiate__trt__RemoveAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3021 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (1100)
/* trt:AddAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfiguration (1100)
	virtual int soap_type(void) const { return 1100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfiguration); }
	         _trt__AddAudioSourceConfiguration() { _trt__AddAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfiguration() { }
	friend _trt__AddAudioSourceConfiguration *soap_instantiate__trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3024 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (1101)
/* trt:AddAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (1101)
	virtual int soap_type(void) const { return 1101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfigurationResponse); }
	         _trt__AddAudioSourceConfigurationResponse() { _trt__AddAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfigurationResponse() { }
	friend _trt__AddAudioSourceConfigurationResponse *soap_instantiate__trt__AddAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3027 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (1102)
/* trt:RemoveAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfiguration (1102)
	virtual int soap_type(void) const { return 1102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfiguration); }
	         _trt__RemoveAudioSourceConfiguration() { _trt__RemoveAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfiguration() { }
	friend _trt__RemoveAudioSourceConfiguration *soap_instantiate__trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3030 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (1103)
/* trt:RemoveAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (1103)
	virtual int soap_type(void) const { return 1103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfigurationResponse); }
	         _trt__RemoveAudioSourceConfigurationResponse() { _trt__RemoveAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfigurationResponse() { }
	friend _trt__RemoveAudioSourceConfigurationResponse *soap_instantiate__trt__RemoveAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3033 */
#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (1104)
/* trt:AddPTZConfiguration complex type: */
class SOAP_CMAC _trt__AddPTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfiguration (1104)
	virtual int soap_type(void) const { return 1104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfiguration); }
	         _trt__AddPTZConfiguration() { _trt__AddPTZConfiguration::soap_default(NULL); }
	virtual ~_trt__AddPTZConfiguration() { }
	friend _trt__AddPTZConfiguration *soap_instantiate__trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3036 */
#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (1105)
/* trt:AddPTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddPTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfigurationResponse (1105)
	virtual int soap_type(void) const { return 1105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfigurationResponse); }
	         _trt__AddPTZConfigurationResponse() { _trt__AddPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddPTZConfigurationResponse() { }
	friend _trt__AddPTZConfigurationResponse *soap_instantiate__trt__AddPTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3039 */
#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (1106)
/* trt:RemovePTZConfiguration complex type: */
class SOAP_CMAC _trt__RemovePTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfiguration (1106)
	virtual int soap_type(void) const { return 1106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfiguration); }
	         _trt__RemovePTZConfiguration() { _trt__RemovePTZConfiguration::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfiguration() { }
	friend _trt__RemovePTZConfiguration *soap_instantiate__trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3042 */
#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (1107)
/* trt:RemovePTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemovePTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfigurationResponse (1107)
	virtual int soap_type(void) const { return 1107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfigurationResponse); }
	         _trt__RemovePTZConfigurationResponse() { _trt__RemovePTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfigurationResponse() { }
	friend _trt__RemovePTZConfigurationResponse *soap_instantiate__trt__RemovePTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3045 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (1108)
/* trt:AddVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (1108)
	virtual int soap_type(void) const { return 1108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfiguration); }
	         _trt__AddVideoAnalyticsConfiguration() { _trt__AddVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfiguration() { }
	friend _trt__AddVideoAnalyticsConfiguration *soap_instantiate__trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3048 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (1109)
/* trt:AddVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (1109)
	virtual int soap_type(void) const { return 1109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfigurationResponse); }
	         _trt__AddVideoAnalyticsConfigurationResponse() { _trt__AddVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfigurationResponse() { }
	friend _trt__AddVideoAnalyticsConfigurationResponse *soap_instantiate__trt__AddVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3051 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (1110)
/* trt:RemoveVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (1110)
	virtual int soap_type(void) const { return 1110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfiguration); }
	         _trt__RemoveVideoAnalyticsConfiguration() { _trt__RemoveVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfiguration() { }
	friend _trt__RemoveVideoAnalyticsConfiguration *soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3054 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (1111)
/* trt:RemoveVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (1111)
	virtual int soap_type(void) const { return 1111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfigurationResponse); }
	         _trt__RemoveVideoAnalyticsConfigurationResponse() { _trt__RemoveVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfigurationResponse() { }
	friend _trt__RemoveVideoAnalyticsConfigurationResponse *soap_instantiate__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3057 */
#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (1112)
/* trt:AddMetadataConfiguration complex type: */
class SOAP_CMAC _trt__AddMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfiguration (1112)
	virtual int soap_type(void) const { return 1112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfiguration); }
	         _trt__AddMetadataConfiguration() { _trt__AddMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfiguration() { }
	friend _trt__AddMetadataConfiguration *soap_instantiate__trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3060 */
#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (1113)
/* trt:AddMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfigurationResponse (1113)
	virtual int soap_type(void) const { return 1113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfigurationResponse); }
	         _trt__AddMetadataConfigurationResponse() { _trt__AddMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfigurationResponse() { }
	friend _trt__AddMetadataConfigurationResponse *soap_instantiate__trt__AddMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3063 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (1114)
/* trt:RemoveMetadataConfiguration complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfiguration (1114)
	virtual int soap_type(void) const { return 1114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfiguration); }
	         _trt__RemoveMetadataConfiguration() { _trt__RemoveMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfiguration() { }
	friend _trt__RemoveMetadataConfiguration *soap_instantiate__trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3066 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (1115)
/* trt:RemoveMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (1115)
	virtual int soap_type(void) const { return 1115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfigurationResponse); }
	         _trt__RemoveMetadataConfigurationResponse() { _trt__RemoveMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfigurationResponse() { }
	friend _trt__RemoveMetadataConfigurationResponse *soap_instantiate__trt__RemoveMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3069 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfiguration
#define SOAP_TYPE__trt__AddAudioOutputConfiguration (1116)
/* trt:AddAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfiguration (1116)
	virtual int soap_type(void) const { return 1116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfiguration); }
	         _trt__AddAudioOutputConfiguration() { _trt__AddAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfiguration() { }
	friend _trt__AddAudioOutputConfiguration *soap_instantiate__trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3072 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (1117)
/* trt:AddAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (1117)
	virtual int soap_type(void) const { return 1117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfigurationResponse); }
	         _trt__AddAudioOutputConfigurationResponse() { _trt__AddAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfigurationResponse() { }
	friend _trt__AddAudioOutputConfigurationResponse *soap_instantiate__trt__AddAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3075 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE__trt__RemoveAudioOutputConfiguration (1118)
/* trt:RemoveAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfiguration (1118)
	virtual int soap_type(void) const { return 1118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfiguration); }
	         _trt__RemoveAudioOutputConfiguration() { _trt__RemoveAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfiguration() { }
	friend _trt__RemoveAudioOutputConfiguration *soap_instantiate__trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3078 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (1119)
/* trt:RemoveAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (1119)
	virtual int soap_type(void) const { return 1119; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfigurationResponse); }
	         _trt__RemoveAudioOutputConfigurationResponse() { _trt__RemoveAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfigurationResponse() { }
	friend _trt__RemoveAudioOutputConfigurationResponse *soap_instantiate__trt__RemoveAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3081 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfiguration
#define SOAP_TYPE__trt__AddAudioDecoderConfiguration (1120)
/* trt:AddAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfiguration (1120)
	virtual int soap_type(void) const { return 1120; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfiguration); }
	         _trt__AddAudioDecoderConfiguration() { _trt__AddAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfiguration() { }
	friend _trt__AddAudioDecoderConfiguration *soap_instantiate__trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3084 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (1121)
/* trt:AddAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (1121)
	virtual int soap_type(void) const { return 1121; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfigurationResponse); }
	         _trt__AddAudioDecoderConfigurationResponse() { _trt__AddAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfigurationResponse() { }
	friend _trt__AddAudioDecoderConfigurationResponse *soap_instantiate__trt__AddAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3087 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (1122)
/* trt:RemoveAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (1122)
	virtual int soap_type(void) const { return 1122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfiguration); }
	         _trt__RemoveAudioDecoderConfiguration() { _trt__RemoveAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfiguration() { }
	friend _trt__RemoveAudioDecoderConfiguration *soap_instantiate__trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3090 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (1123)
/* trt:RemoveAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (1123)
	virtual int soap_type(void) const { return 1123; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfigurationResponse); }
	         _trt__RemoveAudioDecoderConfigurationResponse() { _trt__RemoveAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfigurationResponse() { }
	friend _trt__RemoveAudioDecoderConfigurationResponse *soap_instantiate__trt__RemoveAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3093 */
#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (1124)
/* trt:DeleteProfile complex type: */
class SOAP_CMAC _trt__DeleteProfile
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfile (1124)
	virtual int soap_type(void) const { return 1124; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfile, default initialized and not managed by a soap context
	virtual _trt__DeleteProfile *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfile); }
	         _trt__DeleteProfile() { _trt__DeleteProfile::soap_default(NULL); }
	virtual ~_trt__DeleteProfile() { }
	friend _trt__DeleteProfile *soap_instantiate__trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3096 */
#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (1125)
/* trt:DeleteProfileResponse complex type: */
class SOAP_CMAC _trt__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfileResponse (1125)
	virtual int soap_type(void) const { return 1125; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfileResponse, default initialized and not managed by a soap context
	virtual _trt__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfileResponse); }
	         _trt__DeleteProfileResponse() { _trt__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_trt__DeleteProfileResponse() { }
	friend _trt__DeleteProfileResponse *soap_instantiate__trt__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3099 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (1126)
/* trt:GetVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurations (1126)
	virtual int soap_type(void) const { return 1126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurations); }
	         _trt__GetVideoEncoderConfigurations() { _trt__GetVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurations() { }
	friend _trt__GetVideoEncoderConfigurations *soap_instantiate__trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3102 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (1127)
/* trt:GetVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationsResponse
{
public:
	std::vector<tt__VideoEncoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (1127)
	virtual int soap_type(void) const { return 1127; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationsResponse); }
	         _trt__GetVideoEncoderConfigurationsResponse() { _trt__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationsResponse() { }
	friend _trt__GetVideoEncoderConfigurationsResponse *soap_instantiate__trt__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3105 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (1128)
/* trt:GetVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurations (1128)
	virtual int soap_type(void) const { return 1128; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurations); }
	         _trt__GetVideoSourceConfigurations() { _trt__GetVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurations() { }
	friend _trt__GetVideoSourceConfigurations *soap_instantiate__trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3108 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (1129)
/* trt:GetVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationsResponse
{
public:
	std::vector<tt__VideoSourceConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (1129)
	virtual int soap_type(void) const { return 1129; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationsResponse); }
	         _trt__GetVideoSourceConfigurationsResponse() { _trt__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationsResponse() { }
	friend _trt__GetVideoSourceConfigurationsResponse *soap_instantiate__trt__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3111 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (1130)
/* trt:GetAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurations (1130)
	virtual int soap_type(void) const { return 1130; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurations); }
	         _trt__GetAudioEncoderConfigurations() { _trt__GetAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurations() { }
	friend _trt__GetAudioEncoderConfigurations *soap_instantiate__trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3114 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (1131)
/* trt:GetAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationsResponse
{
public:
	std::vector<tt__AudioEncoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (1131)
	virtual int soap_type(void) const { return 1131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationsResponse); }
	         _trt__GetAudioEncoderConfigurationsResponse() { _trt__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationsResponse() { }
	friend _trt__GetAudioEncoderConfigurationsResponse *soap_instantiate__trt__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3117 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (1132)
/* trt:GetAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurations (1132)
	virtual int soap_type(void) const { return 1132; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurations); }
	         _trt__GetAudioSourceConfigurations() { _trt__GetAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurations() { }
	friend _trt__GetAudioSourceConfigurations *soap_instantiate__trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3120 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (1133)
/* trt:GetAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationsResponse
{
public:
	std::vector<tt__AudioSourceConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (1133)
	virtual int soap_type(void) const { return 1133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationsResponse); }
	         _trt__GetAudioSourceConfigurationsResponse() { _trt__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationsResponse() { }
	friend _trt__GetAudioSourceConfigurationsResponse *soap_instantiate__trt__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3123 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (1134)
/* trt:GetVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (1134)
	virtual int soap_type(void) const { return 1134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurations); }
	         _trt__GetVideoAnalyticsConfigurations() { _trt__GetVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurations() { }
	friend _trt__GetVideoAnalyticsConfigurations *soap_instantiate__trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3126 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (1135)
/* trt:GetVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<tt__VideoAnalyticsConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (1135)
	virtual int soap_type(void) const { return 1135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationsResponse); }
	         _trt__GetVideoAnalyticsConfigurationsResponse() { _trt__GetVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationsResponse() { }
	friend _trt__GetVideoAnalyticsConfigurationsResponse *soap_instantiate__trt__GetVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3129 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (1136)
/* trt:GetMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurations (1136)
	virtual int soap_type(void) const { return 1136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurations); }
	         _trt__GetMetadataConfigurations() { _trt__GetMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurations() { }
	friend _trt__GetMetadataConfigurations *soap_instantiate__trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3132 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (1137)
/* trt:GetMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationsResponse
{
public:
	std::vector<tt__MetadataConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:MetadataConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationsResponse (1137)
	virtual int soap_type(void) const { return 1137; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationsResponse); }
	         _trt__GetMetadataConfigurationsResponse() { _trt__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationsResponse() { }
	friend _trt__GetMetadataConfigurationsResponse *soap_instantiate__trt__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3135 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurations
#define SOAP_TYPE__trt__GetAudioOutputConfigurations (1138)
/* trt:GetAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurations (1138)
	virtual int soap_type(void) const { return 1138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurations); }
	         _trt__GetAudioOutputConfigurations() { _trt__GetAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurations() { }
	friend _trt__GetAudioOutputConfigurations *soap_instantiate__trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3138 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (1139)
/* trt:GetAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationsResponse
{
public:
	std::vector<tt__AudioOutputConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (1139)
	virtual int soap_type(void) const { return 1139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationsResponse); }
	         _trt__GetAudioOutputConfigurationsResponse() { _trt__GetAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationsResponse() { }
	friend _trt__GetAudioOutputConfigurationsResponse *soap_instantiate__trt__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3141 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetAudioDecoderConfigurations (1140)
/* trt:GetAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurations (1140)
	virtual int soap_type(void) const { return 1140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurations); }
	         _trt__GetAudioDecoderConfigurations() { _trt__GetAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurations() { }
	friend _trt__GetAudioDecoderConfigurations *soap_instantiate__trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3144 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (1141)
/* trt:GetAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationsResponse
{
public:
	std::vector<tt__AudioDecoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (1141)
	virtual int soap_type(void) const { return 1141; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationsResponse); }
	         _trt__GetAudioDecoderConfigurationsResponse() { _trt__GetAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationsResponse() { }
	friend _trt__GetAudioDecoderConfigurationsResponse *soap_instantiate__trt__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3147 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (1142)
/* trt:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfiguration (1142)
	virtual int soap_type(void) const { return 1142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfiguration); }
	         _trt__GetVideoSourceConfiguration() { _trt__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfiguration() { }
	friend _trt__GetVideoSourceConfiguration *soap_instantiate__trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3150 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (1143)
/* trt:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (1143)
	virtual int soap_type(void) const { return 1143; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationResponse); }
	         _trt__GetVideoSourceConfigurationResponse() { _trt__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationResponse() { }
	friend _trt__GetVideoSourceConfigurationResponse *soap_instantiate__trt__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3153 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (1144)
/* trt:GetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfiguration (1144)
	virtual int soap_type(void) const { return 1144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfiguration); }
	         _trt__GetVideoEncoderConfiguration() { _trt__GetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfiguration() { }
	friend _trt__GetVideoEncoderConfiguration *soap_instantiate__trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3156 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (1145)
/* trt:GetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationResponse
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (1145)
	virtual int soap_type(void) const { return 1145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationResponse); }
	         _trt__GetVideoEncoderConfigurationResponse() { _trt__GetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationResponse() { }
	friend _trt__GetVideoEncoderConfigurationResponse *soap_instantiate__trt__GetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3159 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (1146)
/* trt:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfiguration (1146)
	virtual int soap_type(void) const { return 1146; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfiguration); }
	         _trt__GetAudioSourceConfiguration() { _trt__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfiguration() { }
	friend _trt__GetAudioSourceConfiguration *soap_instantiate__trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3162 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (1147)
/* trt:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (1147)
	virtual int soap_type(void) const { return 1147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationResponse); }
	         _trt__GetAudioSourceConfigurationResponse() { _trt__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationResponse() { }
	friend _trt__GetAudioSourceConfigurationResponse *soap_instantiate__trt__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3165 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (1148)
/* trt:GetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfiguration (1148)
	virtual int soap_type(void) const { return 1148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfiguration); }
	         _trt__GetAudioEncoderConfiguration() { _trt__GetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfiguration() { }
	friend _trt__GetAudioEncoderConfiguration *soap_instantiate__trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3168 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (1149)
/* trt:GetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationResponse
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (1149)
	virtual int soap_type(void) const { return 1149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationResponse); }
	         _trt__GetAudioEncoderConfigurationResponse() { _trt__GetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationResponse() { }
	friend _trt__GetAudioEncoderConfigurationResponse *soap_instantiate__trt__GetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3171 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (1150)
/* trt:GetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (1150)
	virtual int soap_type(void) const { return 1150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfiguration); }
	         _trt__GetVideoAnalyticsConfiguration() { _trt__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfiguration() { }
	friend _trt__GetVideoAnalyticsConfiguration *soap_instantiate__trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3174 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (1151)
/* trt:GetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationResponse
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (1151)
	virtual int soap_type(void) const { return 1151; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationResponse); }
	         _trt__GetVideoAnalyticsConfigurationResponse() { _trt__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationResponse() { }
	friend _trt__GetVideoAnalyticsConfigurationResponse *soap_instantiate__trt__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3177 */
#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (1152)
/* trt:GetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__GetMetadataConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfiguration (1152)
	virtual int soap_type(void) const { return 1152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfiguration); }
	         _trt__GetMetadataConfiguration() { _trt__GetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfiguration() { }
	friend _trt__GetMetadataConfiguration *soap_instantiate__trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3180 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (1153)
/* trt:GetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationResponse
{
public:
	tt__MetadataConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationResponse (1153)
	virtual int soap_type(void) const { return 1153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationResponse); }
	         _trt__GetMetadataConfigurationResponse() { _trt__GetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationResponse() { }
	friend _trt__GetMetadataConfigurationResponse *soap_instantiate__trt__GetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3183 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfiguration
#define SOAP_TYPE__trt__GetAudioOutputConfiguration (1154)
/* trt:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfiguration (1154)
	virtual int soap_type(void) const { return 1154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfiguration); }
	         _trt__GetAudioOutputConfiguration() { _trt__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfiguration() { }
	friend _trt__GetAudioOutputConfiguration *soap_instantiate__trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3186 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (1155)
/* trt:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (1155)
	virtual int soap_type(void) const { return 1155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationResponse); }
	         _trt__GetAudioOutputConfigurationResponse() { _trt__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationResponse() { }
	friend _trt__GetAudioOutputConfigurationResponse *soap_instantiate__trt__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3189 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfiguration
#define SOAP_TYPE__trt__GetAudioDecoderConfiguration (1156)
/* trt:GetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfiguration (1156)
	virtual int soap_type(void) const { return 1156; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfiguration); }
	         _trt__GetAudioDecoderConfiguration() { _trt__GetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfiguration() { }
	friend _trt__GetAudioDecoderConfiguration *soap_instantiate__trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3192 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (1157)
/* trt:GetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationResponse
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (1157)
	virtual int soap_type(void) const { return 1157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationResponse); }
	         _trt__GetAudioDecoderConfigurationResponse() { _trt__GetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationResponse() { }
	friend _trt__GetAudioDecoderConfigurationResponse *soap_instantiate__trt__GetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3195 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (1158)
/* trt:GetCompatibleVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (1158)
	virtual int soap_type(void) const { return 1158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurations); }
	         _trt__GetCompatibleVideoEncoderConfigurations() { _trt__GetCompatibleVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurations() { }
	friend _trt__GetCompatibleVideoEncoderConfigurations *soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3198 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (1159)
/* trt:GetCompatibleVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurationsResponse
{
public:
	std::vector<tt__VideoEncoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (1159)
	virtual int soap_type(void) const { return 1159; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurationsResponse); }
	         _trt__GetCompatibleVideoEncoderConfigurationsResponse() { _trt__GetCompatibleVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurationsResponse() { }
	friend _trt__GetCompatibleVideoEncoderConfigurationsResponse *soap_instantiate__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3201 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (1160)
/* trt:GetCompatibleVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (1160)
	virtual int soap_type(void) const { return 1160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurations); }
	         _trt__GetCompatibleVideoSourceConfigurations() { _trt__GetCompatibleVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurations() { }
	friend _trt__GetCompatibleVideoSourceConfigurations *soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3204 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (1161)
/* trt:GetCompatibleVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurationsResponse
{
public:
	std::vector<tt__VideoSourceConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (1161)
	virtual int soap_type(void) const { return 1161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurationsResponse); }
	         _trt__GetCompatibleVideoSourceConfigurationsResponse() { _trt__GetCompatibleVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurationsResponse() { }
	friend _trt__GetCompatibleVideoSourceConfigurationsResponse *soap_instantiate__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3207 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (1162)
/* trt:GetCompatibleAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (1162)
	virtual int soap_type(void) const { return 1162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurations); }
	         _trt__GetCompatibleAudioEncoderConfigurations() { _trt__GetCompatibleAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurations() { }
	friend _trt__GetCompatibleAudioEncoderConfigurations *soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3210 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (1163)
/* trt:GetCompatibleAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurationsResponse
{
public:
	std::vector<tt__AudioEncoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (1163)
	virtual int soap_type(void) const { return 1163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioEncoderConfigurationsResponse() { _trt__GetCompatibleAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurationsResponse() { }
	friend _trt__GetCompatibleAudioEncoderConfigurationsResponse *soap_instantiate__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3213 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (1164)
/* trt:GetCompatibleAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (1164)
	virtual int soap_type(void) const { return 1164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurations); }
	         _trt__GetCompatibleAudioSourceConfigurations() { _trt__GetCompatibleAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurations() { }
	friend _trt__GetCompatibleAudioSourceConfigurations *soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3216 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (1165)
/* trt:GetCompatibleAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurationsResponse
{
public:
	std::vector<tt__AudioSourceConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (1165)
	virtual int soap_type(void) const { return 1165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurationsResponse); }
	         _trt__GetCompatibleAudioSourceConfigurationsResponse() { _trt__GetCompatibleAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurationsResponse() { }
	friend _trt__GetCompatibleAudioSourceConfigurationsResponse *soap_instantiate__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3219 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (1166)
/* trt:GetCompatibleVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (1166)
	virtual int soap_type(void) const { return 1166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurations); }
	         _trt__GetCompatibleVideoAnalyticsConfigurations() { _trt__GetCompatibleVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurations() { }
	friend _trt__GetCompatibleVideoAnalyticsConfigurations *soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3222 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (1167)
/* trt:GetCompatibleVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<tt__VideoAnalyticsConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (1167)
	virtual int soap_type(void) const { return 1167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse); }
	         _trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { _trt__GetCompatibleVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
	friend _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3225 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (1168)
/* trt:GetCompatibleMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (1168)
	virtual int soap_type(void) const { return 1168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurations); }
	         _trt__GetCompatibleMetadataConfigurations() { _trt__GetCompatibleMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurations() { }
	friend _trt__GetCompatibleMetadataConfigurations *soap_instantiate__trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3228 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (1169)
/* trt:GetCompatibleMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurationsResponse
{
public:
	std::vector<tt__MetadataConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:MetadataConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (1169)
	virtual int soap_type(void) const { return 1169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurationsResponse); }
	         _trt__GetCompatibleMetadataConfigurationsResponse() { _trt__GetCompatibleMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurationsResponse() { }
	friend _trt__GetCompatibleMetadataConfigurationsResponse *soap_instantiate__trt__GetCompatibleMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3231 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (1170)
/* trt:GetCompatibleAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (1170)
	virtual int soap_type(void) const { return 1170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurations); }
	         _trt__GetCompatibleAudioOutputConfigurations() { _trt__GetCompatibleAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurations() { }
	friend _trt__GetCompatibleAudioOutputConfigurations *soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3234 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (1171)
/* trt:GetCompatibleAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurationsResponse
{
public:
	std::vector<tt__AudioOutputConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (1171)
	virtual int soap_type(void) const { return 1171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurationsResponse); }
	         _trt__GetCompatibleAudioOutputConfigurationsResponse() { _trt__GetCompatibleAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurationsResponse() { }
	friend _trt__GetCompatibleAudioOutputConfigurationsResponse *soap_instantiate__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3237 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (1172)
/* trt:GetCompatibleAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (1172)
	virtual int soap_type(void) const { return 1172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurations); }
	         _trt__GetCompatibleAudioDecoderConfigurations() { _trt__GetCompatibleAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurations() { }
	friend _trt__GetCompatibleAudioDecoderConfigurations *soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3240 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (1173)
/* trt:GetCompatibleAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurationsResponse
{
public:
	std::vector<tt__AudioDecoderConfiguration *> Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (1173)
	virtual int soap_type(void) const { return 1173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioDecoderConfigurationsResponse() { _trt__GetCompatibleAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurationsResponse() { }
	friend _trt__GetCompatibleAudioDecoderConfigurationsResponse *soap_instantiate__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3243 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (1174)
/* trt:SetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfiguration
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* required element of XSD type tt:VideoEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfiguration (1174)
	virtual int soap_type(void) const { return 1174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfiguration); }
	         _trt__SetVideoEncoderConfiguration() { _trt__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfiguration() { }
	friend _trt__SetVideoEncoderConfiguration *soap_instantiate__trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3246 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (1175)
/* trt:SetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (1175)
	virtual int soap_type(void) const { return 1175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfigurationResponse); }
	         _trt__SetVideoEncoderConfigurationResponse() { _trt__SetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfigurationResponse() { }
	friend _trt__SetVideoEncoderConfigurationResponse *soap_instantiate__trt__SetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3249 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (1176)
/* trt:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfiguration (1176)
	virtual int soap_type(void) const { return 1176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfiguration); }
	         _trt__SetVideoSourceConfiguration() { _trt__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfiguration() { }
	friend _trt__SetVideoSourceConfiguration *soap_instantiate__trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3252 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (1177)
/* trt:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (1177)
	virtual int soap_type(void) const { return 1177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfigurationResponse); }
	         _trt__SetVideoSourceConfigurationResponse() { _trt__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfigurationResponse() { }
	friend _trt__SetVideoSourceConfigurationResponse *soap_instantiate__trt__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3255 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (1178)
/* trt:SetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfiguration
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* required element of XSD type tt:AudioEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfiguration (1178)
	virtual int soap_type(void) const { return 1178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfiguration); }
	         _trt__SetAudioEncoderConfiguration() { _trt__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfiguration() { }
	friend _trt__SetAudioEncoderConfiguration *soap_instantiate__trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3258 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (1179)
/* trt:SetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (1179)
	virtual int soap_type(void) const { return 1179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfigurationResponse); }
	         _trt__SetAudioEncoderConfigurationResponse() { _trt__SetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfigurationResponse() { }
	friend _trt__SetAudioEncoderConfigurationResponse *soap_instantiate__trt__SetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3261 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (1180)
/* trt:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfiguration (1180)
	virtual int soap_type(void) const { return 1180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfiguration); }
	         _trt__SetAudioSourceConfiguration() { _trt__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfiguration() { }
	friend _trt__SetAudioSourceConfiguration *soap_instantiate__trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3264 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (1181)
/* trt:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (1181)
	virtual int soap_type(void) const { return 1181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfigurationResponse); }
	         _trt__SetAudioSourceConfigurationResponse() { _trt__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfigurationResponse() { }
	friend _trt__SetAudioSourceConfigurationResponse *soap_instantiate__trt__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3267 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (1182)
/* trt:SetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (1182)
	virtual int soap_type(void) const { return 1182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfiguration); }
	         _trt__SetVideoAnalyticsConfiguration() { _trt__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfiguration() { }
	friend _trt__SetVideoAnalyticsConfiguration *soap_instantiate__trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3270 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (1183)
/* trt:SetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (1183)
	virtual int soap_type(void) const { return 1183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfigurationResponse); }
	         _trt__SetVideoAnalyticsConfigurationResponse() { _trt__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfigurationResponse() { }
	friend _trt__SetVideoAnalyticsConfigurationResponse *soap_instantiate__trt__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3273 */
#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (1184)
/* trt:SetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__SetMetadataConfiguration
{
public:
	tt__MetadataConfiguration *Configuration;	/* required element of XSD type tt:MetadataConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfiguration (1184)
	virtual int soap_type(void) const { return 1184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfiguration); }
	         _trt__SetMetadataConfiguration() { _trt__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfiguration() { }
	friend _trt__SetMetadataConfiguration *soap_instantiate__trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3276 */
#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (1185)
/* trt:SetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfigurationResponse (1185)
	virtual int soap_type(void) const { return 1185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfigurationResponse); }
	         _trt__SetMetadataConfigurationResponse() { _trt__SetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfigurationResponse() { }
	friend _trt__SetMetadataConfigurationResponse *soap_instantiate__trt__SetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3279 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfiguration
#define SOAP_TYPE__trt__SetAudioOutputConfiguration (1186)
/* trt:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfiguration (1186)
	virtual int soap_type(void) const { return 1186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfiguration); }
	         _trt__SetAudioOutputConfiguration() { _trt__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfiguration() { }
	friend _trt__SetAudioOutputConfiguration *soap_instantiate__trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3282 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (1187)
/* trt:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (1187)
	virtual int soap_type(void) const { return 1187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfigurationResponse); }
	         _trt__SetAudioOutputConfigurationResponse() { _trt__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfigurationResponse() { }
	friend _trt__SetAudioOutputConfigurationResponse *soap_instantiate__trt__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3285 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfiguration
#define SOAP_TYPE__trt__SetAudioDecoderConfiguration (1188)
/* trt:SetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfiguration
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* required element of XSD type tt:AudioDecoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfiguration (1188)
	virtual int soap_type(void) const { return 1188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfiguration); }
	         _trt__SetAudioDecoderConfiguration() { _trt__SetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfiguration() { }
	friend _trt__SetAudioDecoderConfiguration *soap_instantiate__trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3288 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (1189)
/* trt:SetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (1189)
	virtual int soap_type(void) const { return 1189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfigurationResponse); }
	         _trt__SetAudioDecoderConfigurationResponse() { _trt__SetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfigurationResponse() { }
	friend _trt__SetAudioDecoderConfigurationResponse *soap_instantiate__trt__SetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3291 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (1190)
/* trt:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (1190)
	virtual int soap_type(void) const { return 1190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptions); }
	         _trt__GetVideoSourceConfigurationOptions() { _trt__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptions() { }
	friend _trt__GetVideoSourceConfigurationOptions *soap_instantiate__trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3294 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (1191)
/* trt:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (1191)
	virtual int soap_type(void) const { return 1191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptionsResponse); }
	         _trt__GetVideoSourceConfigurationOptionsResponse() { _trt__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptionsResponse() { }
	friend _trt__GetVideoSourceConfigurationOptionsResponse *soap_instantiate__trt__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3297 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (1192)
/* trt:GetVideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (1192)
	virtual int soap_type(void) const { return 1192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptions); }
	         _trt__GetVideoEncoderConfigurationOptions() { _trt__GetVideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptions() { }
	friend _trt__GetVideoEncoderConfigurationOptions *soap_instantiate__trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3300 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (1193)
/* trt:GetVideoEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptionsResponse
{
public:
	tt__VideoEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (1193)
	virtual int soap_type(void) const { return 1193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptionsResponse); }
	         _trt__GetVideoEncoderConfigurationOptionsResponse() { _trt__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptionsResponse() { }
	friend _trt__GetVideoEncoderConfigurationOptionsResponse *soap_instantiate__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3303 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (1194)
/* trt:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (1194)
	virtual int soap_type(void) const { return 1194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptions); }
	         _trt__GetAudioSourceConfigurationOptions() { _trt__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptions() { }
	friend _trt__GetAudioSourceConfigurationOptions *soap_instantiate__trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3306 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (1195)
/* trt:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (1195)
	virtual int soap_type(void) const { return 1195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptionsResponse); }
	         _trt__GetAudioSourceConfigurationOptionsResponse() { _trt__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptionsResponse() { }
	friend _trt__GetAudioSourceConfigurationOptionsResponse *soap_instantiate__trt__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3309 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (1196)
/* trt:GetAudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (1196)
	virtual int soap_type(void) const { return 1196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptions); }
	         _trt__GetAudioEncoderConfigurationOptions() { _trt__GetAudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptions() { }
	friend _trt__GetAudioEncoderConfigurationOptions *soap_instantiate__trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3312 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (1197)
/* trt:GetAudioEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptionsResponse
{
public:
	tt__AudioEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (1197)
	virtual int soap_type(void) const { return 1197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptionsResponse); }
	         _trt__GetAudioEncoderConfigurationOptionsResponse() { _trt__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptionsResponse() { }
	friend _trt__GetAudioEncoderConfigurationOptionsResponse *soap_instantiate__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3315 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (1198)
/* trt:GetMetadataConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptions (1198)
	virtual int soap_type(void) const { return 1198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptions); }
	         _trt__GetMetadataConfigurationOptions() { _trt__GetMetadataConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptions() { }
	friend _trt__GetMetadataConfigurationOptions *soap_instantiate__trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3318 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (1199)
/* trt:GetMetadataConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptionsResponse
{
public:
	tt__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (1199)
	virtual int soap_type(void) const { return 1199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptionsResponse); }
	         _trt__GetMetadataConfigurationOptionsResponse() { _trt__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptionsResponse() { }
	friend _trt__GetMetadataConfigurationOptionsResponse *soap_instantiate__trt__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3321 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (1200)
/* trt:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (1200)
	virtual int soap_type(void) const { return 1200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptions); }
	         _trt__GetAudioOutputConfigurationOptions() { _trt__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptions() { }
	friend _trt__GetAudioOutputConfigurationOptions *soap_instantiate__trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3324 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (1201)
/* trt:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (1201)
	virtual int soap_type(void) const { return 1201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptionsResponse); }
	         _trt__GetAudioOutputConfigurationOptionsResponse() { _trt__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptionsResponse() { }
	friend _trt__GetAudioOutputConfigurationOptionsResponse *soap_instantiate__trt__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3327 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (1202)
/* trt:GetAudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (1202)
	virtual int soap_type(void) const { return 1202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptions); }
	         _trt__GetAudioDecoderConfigurationOptions() { _trt__GetAudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptions() { }
	friend _trt__GetAudioDecoderConfigurationOptions *soap_instantiate__trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3330 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (1203)
/* trt:GetAudioDecoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptionsResponse
{
public:
	tt__AudioDecoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (1203)
	virtual int soap_type(void) const { return 1203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptionsResponse); }
	         _trt__GetAudioDecoderConfigurationOptionsResponse() { _trt__GetAudioDecoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptionsResponse() { }
	friend _trt__GetAudioDecoderConfigurationOptionsResponse *soap_instantiate__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3333 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (1204)
/* trt:GetGuaranteedNumberOfVideoEncoderInstances complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (1204)
	virtual int soap_type(void) const { return 1204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstances, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstances); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstances() { _trt__GetGuaranteedNumberOfVideoEncoderInstances::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
	friend _trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3336 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1205)
/* trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
{
public:
	int TotalNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:int */
	int *JPEG;	/* optional element of XSD type xsd:int */
	int *H264;	/* optional element of XSD type xsd:int */
	int *MPEG4;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1205)
	virtual int soap_type(void) const { return 1205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
	friend _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3339 */
#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (1206)
/* trt:GetStreamUri complex type: */
class SOAP_CMAC _trt__GetStreamUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUri (1206)
	virtual int soap_type(void) const { return 1206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUri, default initialized and not managed by a soap context
	virtual _trt__GetStreamUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUri); }
	         _trt__GetStreamUri() { _trt__GetStreamUri::soap_default(NULL); }
	virtual ~_trt__GetStreamUri() { }
	friend _trt__GetStreamUri *soap_instantiate__trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3342 */
#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (1207)
/* trt:GetStreamUriResponse complex type: */
class SOAP_CMAC _trt__GetStreamUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUriResponse (1207)
	virtual int soap_type(void) const { return 1207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUriResponse); }
	         _trt__GetStreamUriResponse() { _trt__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_trt__GetStreamUriResponse() { }
	friend _trt__GetStreamUriResponse *soap_instantiate__trt__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3345 */
#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (1208)
/* trt:StartMulticastStreaming complex type: */
class SOAP_CMAC _trt__StartMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreaming (1208)
	virtual int soap_type(void) const { return 1208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreaming); }
	         _trt__StartMulticastStreaming() { _trt__StartMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreaming() { }
	friend _trt__StartMulticastStreaming *soap_instantiate__trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3348 */
#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (1209)
/* trt:StartMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StartMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreamingResponse (1209)
	virtual int soap_type(void) const { return 1209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreamingResponse); }
	         _trt__StartMulticastStreamingResponse() { _trt__StartMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreamingResponse() { }
	friend _trt__StartMulticastStreamingResponse *soap_instantiate__trt__StartMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3351 */
#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (1210)
/* trt:StopMulticastStreaming complex type: */
class SOAP_CMAC _trt__StopMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreaming (1210)
	virtual int soap_type(void) const { return 1210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreaming); }
	         _trt__StopMulticastStreaming() { _trt__StopMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreaming() { }
	friend _trt__StopMulticastStreaming *soap_instantiate__trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3354 */
#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (1211)
/* trt:StopMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StopMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreamingResponse (1211)
	virtual int soap_type(void) const { return 1211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreamingResponse); }
	         _trt__StopMulticastStreamingResponse() { _trt__StopMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreamingResponse() { }
	friend _trt__StopMulticastStreamingResponse *soap_instantiate__trt__StopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3357 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (1212)
/* trt:SetSynchronizationPoint complex type: */
class SOAP_CMAC _trt__SetSynchronizationPoint
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPoint (1212)
	virtual int soap_type(void) const { return 1212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPoint, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPoint); }
	         _trt__SetSynchronizationPoint() { _trt__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPoint() { }
	friend _trt__SetSynchronizationPoint *soap_instantiate__trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3360 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (1213)
/* trt:SetSynchronizationPointResponse complex type: */
class SOAP_CMAC _trt__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPointResponse (1213)
	virtual int soap_type(void) const { return 1213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPointResponse, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPointResponse); }
	         _trt__SetSynchronizationPointResponse() { _trt__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPointResponse() { }
	friend _trt__SetSynchronizationPointResponse *soap_instantiate__trt__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3363 */
#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (1214)
/* trt:GetSnapshotUri complex type: */
class SOAP_CMAC _trt__GetSnapshotUri
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUri (1214)
	virtual int soap_type(void) const { return 1214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUri, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUri); }
	         _trt__GetSnapshotUri() { _trt__GetSnapshotUri::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUri() { }
	friend _trt__GetSnapshotUri *soap_instantiate__trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3366 */
#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (1215)
/* trt:GetSnapshotUriResponse complex type: */
class SOAP_CMAC _trt__GetSnapshotUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUriResponse (1215)
	virtual int soap_type(void) const { return 1215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUriResponse); }
	         _trt__GetSnapshotUriResponse() { _trt__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUriResponse() { }
	friend _trt__GetSnapshotUriResponse *soap_instantiate__trt__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3369 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModes
#define SOAP_TYPE__trt__GetVideoSourceModes (1216)
/* trt:GetVideoSourceModes complex type: */
class SOAP_CMAC _trt__GetVideoSourceModes
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceModes (1216)
	virtual int soap_type(void) const { return 1216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceModes, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceModes *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceModes); }
	         _trt__GetVideoSourceModes() { _trt__GetVideoSourceModes::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceModes() { }
	friend _trt__GetVideoSourceModes *soap_instantiate__trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3372 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModesResponse
#define SOAP_TYPE__trt__GetVideoSourceModesResponse (1217)
/* trt:GetVideoSourceModesResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceModesResponse
{
public:
	std::vector<trt__VideoSourceMode *> VideoSourceModes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trt:VideoSourceMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceModesResponse (1217)
	virtual int soap_type(void) const { return 1217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceModesResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceModesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceModesResponse); }
	         _trt__GetVideoSourceModesResponse() { _trt__GetVideoSourceModesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceModesResponse() { }
	friend _trt__GetVideoSourceModesResponse *soap_instantiate__trt__GetVideoSourceModesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3375 */
#ifndef SOAP_TYPE__trt__SetVideoSourceMode
#define SOAP_TYPE__trt__SetVideoSourceMode (1218)
/* trt:SetVideoSourceMode complex type: */
class SOAP_CMAC _trt__SetVideoSourceMode
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::string VideoSourceModeToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceMode (1218)
	virtual int soap_type(void) const { return 1218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceMode, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceMode *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceMode); }
	         _trt__SetVideoSourceMode() { _trt__SetVideoSourceMode::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceMode() { }
	friend _trt__SetVideoSourceMode *soap_instantiate__trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3378 */
#ifndef SOAP_TYPE__trt__SetVideoSourceModeResponse
#define SOAP_TYPE__trt__SetVideoSourceModeResponse (1219)
/* trt:SetVideoSourceModeResponse complex type: */
class SOAP_CMAC _trt__SetVideoSourceModeResponse
{
public:
	bool Reboot;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceModeResponse (1219)
	virtual int soap_type(void) const { return 1219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceModeResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceModeResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceModeResponse); }
	         _trt__SetVideoSourceModeResponse() { _trt__SetVideoSourceModeResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceModeResponse() { }
	friend _trt__SetVideoSourceModeResponse *soap_instantiate__trt__SetVideoSourceModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3381 */
#ifndef SOAP_TYPE__trt__GetOSDs
#define SOAP_TYPE__trt__GetOSDs (1220)
/* trt:GetOSDs complex type: */
class SOAP_CMAC _trt__GetOSDs
{
public:
	std::string *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDs (1220)
	virtual int soap_type(void) const { return 1220; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDs, default initialized and not managed by a soap context
	virtual _trt__GetOSDs *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDs); }
	         _trt__GetOSDs() { _trt__GetOSDs::soap_default(NULL); }
	virtual ~_trt__GetOSDs() { }
	friend _trt__GetOSDs *soap_instantiate__trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3384 */
#ifndef SOAP_TYPE__trt__GetOSDsResponse
#define SOAP_TYPE__trt__GetOSDsResponse (1221)
/* trt:GetOSDsResponse complex type: */
class SOAP_CMAC _trt__GetOSDsResponse
{
public:
	std::vector<tt__OSDConfiguration *> OSDs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:OSDConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDsResponse (1221)
	virtual int soap_type(void) const { return 1221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDsResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDsResponse); }
	         _trt__GetOSDsResponse() { _trt__GetOSDsResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDsResponse() { }
	friend _trt__GetOSDsResponse *soap_instantiate__trt__GetOSDsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3387 */
#ifndef SOAP_TYPE__trt__GetOSD
#define SOAP_TYPE__trt__GetOSD (1222)
/* trt:GetOSD complex type: */
class SOAP_CMAC _trt__GetOSD
{
public:
	std::string OSDToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSD (1222)
	virtual int soap_type(void) const { return 1222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSD, default initialized and not managed by a soap context
	virtual _trt__GetOSD *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSD); }
	         _trt__GetOSD() { _trt__GetOSD::soap_default(NULL); }
	virtual ~_trt__GetOSD() { }
	friend _trt__GetOSD *soap_instantiate__trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3390 */
#ifndef SOAP_TYPE__trt__GetOSDResponse
#define SOAP_TYPE__trt__GetOSDResponse (1223)
/* trt:GetOSDResponse complex type: */
class SOAP_CMAC _trt__GetOSDResponse
{
public:
	tt__OSDConfiguration *OSD;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:OSDConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDResponse (1223)
	virtual int soap_type(void) const { return 1223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDResponse); }
	         _trt__GetOSDResponse() { _trt__GetOSDResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDResponse() { }
	friend _trt__GetOSDResponse *soap_instantiate__trt__GetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3393 */
#ifndef SOAP_TYPE__trt__SetOSD
#define SOAP_TYPE__trt__SetOSD (1224)
/* trt:SetOSD complex type: */
class SOAP_CMAC _trt__SetOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of XSD type tt:OSDConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetOSD (1224)
	virtual int soap_type(void) const { return 1224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetOSD, default initialized and not managed by a soap context
	virtual _trt__SetOSD *soap_alloc(void) const { return SOAP_NEW(_trt__SetOSD); }
	         _trt__SetOSD() { _trt__SetOSD::soap_default(NULL); }
	virtual ~_trt__SetOSD() { }
	friend _trt__SetOSD *soap_instantiate__trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3396 */
#ifndef SOAP_TYPE__trt__SetOSDResponse
#define SOAP_TYPE__trt__SetOSDResponse (1225)
/* trt:SetOSDResponse complex type: */
class SOAP_CMAC _trt__SetOSDResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetOSDResponse (1225)
	virtual int soap_type(void) const { return 1225; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetOSDResponse, default initialized and not managed by a soap context
	virtual _trt__SetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetOSDResponse); }
	         _trt__SetOSDResponse() { _trt__SetOSDResponse::soap_default(NULL); }
	virtual ~_trt__SetOSDResponse() { }
	friend _trt__SetOSDResponse *soap_instantiate__trt__SetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3399 */
#ifndef SOAP_TYPE__trt__GetOSDOptions
#define SOAP_TYPE__trt__GetOSDOptions (1226)
/* trt:GetOSDOptions complex type: */
class SOAP_CMAC _trt__GetOSDOptions
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDOptions (1226)
	virtual int soap_type(void) const { return 1226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDOptions, default initialized and not managed by a soap context
	virtual _trt__GetOSDOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDOptions); }
	         _trt__GetOSDOptions() { _trt__GetOSDOptions::soap_default(NULL); }
	virtual ~_trt__GetOSDOptions() { }
	friend _trt__GetOSDOptions *soap_instantiate__trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3402 */
#ifndef SOAP_TYPE__trt__GetOSDOptionsResponse
#define SOAP_TYPE__trt__GetOSDOptionsResponse (1227)
/* trt:GetOSDOptionsResponse complex type: */
class SOAP_CMAC _trt__GetOSDOptionsResponse
{
public:
	tt__OSDConfigurationOptions *OSDOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:OSDConfigurationOptions */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetOSDOptionsResponse (1227)
	virtual int soap_type(void) const { return 1227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetOSDOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetOSDOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetOSDOptionsResponse); }
	         _trt__GetOSDOptionsResponse() { _trt__GetOSDOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetOSDOptionsResponse() { }
	friend _trt__GetOSDOptionsResponse *soap_instantiate__trt__GetOSDOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3405 */
#ifndef SOAP_TYPE__trt__CreateOSD
#define SOAP_TYPE__trt__CreateOSD (1228)
/* trt:CreateOSD complex type: */
class SOAP_CMAC _trt__CreateOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of XSD type tt:OSDConfiguration */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateOSD (1228)
	virtual int soap_type(void) const { return 1228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateOSD, default initialized and not managed by a soap context
	virtual _trt__CreateOSD *soap_alloc(void) const { return SOAP_NEW(_trt__CreateOSD); }
	         _trt__CreateOSD() { _trt__CreateOSD::soap_default(NULL); }
	virtual ~_trt__CreateOSD() { }
	friend _trt__CreateOSD *soap_instantiate__trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3408 */
#ifndef SOAP_TYPE__trt__CreateOSDResponse
#define SOAP_TYPE__trt__CreateOSDResponse (1229)
/* trt:CreateOSDResponse complex type: */
class SOAP_CMAC _trt__CreateOSDResponse
{
public:
	std::string OSDToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateOSDResponse (1229)
	virtual int soap_type(void) const { return 1229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateOSDResponse, default initialized and not managed by a soap context
	virtual _trt__CreateOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__CreateOSDResponse); }
	         _trt__CreateOSDResponse() { _trt__CreateOSDResponse::soap_default(NULL); }
	virtual ~_trt__CreateOSDResponse() { }
	friend _trt__CreateOSDResponse *soap_instantiate__trt__CreateOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3411 */
#ifndef SOAP_TYPE__trt__DeleteOSD
#define SOAP_TYPE__trt__DeleteOSD (1230)
/* trt:DeleteOSD complex type: */
class SOAP_CMAC _trt__DeleteOSD
{
public:
	std::string OSDToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteOSD (1230)
	virtual int soap_type(void) const { return 1230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteOSD, default initialized and not managed by a soap context
	virtual _trt__DeleteOSD *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteOSD); }
	         _trt__DeleteOSD() { _trt__DeleteOSD::soap_default(NULL); }
	virtual ~_trt__DeleteOSD() { }
	friend _trt__DeleteOSD *soap_instantiate__trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3414 */
#ifndef SOAP_TYPE__trt__DeleteOSDResponse
#define SOAP_TYPE__trt__DeleteOSDResponse (1231)
/* trt:DeleteOSDResponse complex type: */
class SOAP_CMAC _trt__DeleteOSDResponse
{
public:
	std::vector<char *> __any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteOSDResponse (1231)
	virtual int soap_type(void) const { return 1231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteOSDResponse, default initialized and not managed by a soap context
	virtual _trt__DeleteOSDResponse *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteOSDResponse); }
	         _trt__DeleteOSDResponse() { _trt__DeleteOSDResponse::soap_default(NULL); }
	virtual ~_trt__DeleteOSDResponse() { }
	friend _trt__DeleteOSDResponse *soap_instantiate__trt__DeleteOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3417 */
#ifndef SOAP_TYPE_tptz__Capabilities
#define SOAP_TYPE_tptz__Capabilities (1232)
/* Type tptz__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tptz:Capabilities complex type: */
class SOAP_CMAC tptz__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *EFlip;	/* optional attribute of XSD type xsd:boolean */
	bool *Reverse;	/* optional attribute of XSD type xsd:boolean */
	bool *GetCompatibleConfigurations;	/* optional attribute of XSD type xsd:boolean */
	bool *MoveStatus;	/* optional attribute of XSD type xsd:boolean */
	bool *StatusPosition;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tptz__Capabilities (1232)
	virtual int soap_type(void) const { return 1232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tptz__Capabilities, default initialized and not managed by a soap context
	virtual tptz__Capabilities *soap_alloc(void) const { return SOAP_NEW(tptz__Capabilities); }
	         tptz__Capabilities() { tptz__Capabilities::soap_default(NULL); }
	virtual ~tptz__Capabilities() { }
	friend tptz__Capabilities *soap_instantiate_tptz__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3420 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilities
#define SOAP_TYPE__tptz__GetServiceCapabilities (1233)
/* tptz:GetServiceCapabilities complex type: */
class SOAP_CMAC _tptz__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetServiceCapabilities (1233)
	virtual int soap_type(void) const { return 1233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tptz__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tptz__GetServiceCapabilities); }
	         _tptz__GetServiceCapabilities() { _tptz__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilities() { }
	friend _tptz__GetServiceCapabilities *soap_instantiate__tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3423 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (1234)
/* tptz:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tptz__GetServiceCapabilitiesResponse
{
public:
	tptz__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tptz:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (1234)
	virtual int soap_type(void) const { return 1234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tptz__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetServiceCapabilitiesResponse); }
	         _tptz__GetServiceCapabilitiesResponse() { _tptz__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilitiesResponse() { }
	friend _tptz__GetServiceCapabilitiesResponse *soap_instantiate__tptz__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3426 */
#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (1235)
/* tptz:GetNodes complex type: */
class SOAP_CMAC _tptz__GetNodes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodes (1235)
	virtual int soap_type(void) const { return 1235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodes, default initialized and not managed by a soap context
	virtual _tptz__GetNodes *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodes); }
	         _tptz__GetNodes() { _tptz__GetNodes::soap_default(NULL); }
	virtual ~_tptz__GetNodes() { }
	friend _tptz__GetNodes *soap_instantiate__tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3429 */
#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (1236)
/* tptz:GetNodesResponse complex type: */
class SOAP_CMAC _tptz__GetNodesResponse
{
public:
	std::vector<tt__PTZNode *> PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:PTZNode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodesResponse (1236)
	virtual int soap_type(void) const { return 1236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodesResponse, default initialized and not managed by a soap context
	virtual _tptz__GetNodesResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodesResponse); }
	         _tptz__GetNodesResponse() { _tptz__GetNodesResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodesResponse() { }
	friend _tptz__GetNodesResponse *soap_instantiate__tptz__GetNodesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3432 */
#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (1237)
/* tptz:GetNode complex type: */
class SOAP_CMAC _tptz__GetNode
{
public:
	std::string NodeToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNode (1237)
	virtual int soap_type(void) const { return 1237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNode, default initialized and not managed by a soap context
	virtual _tptz__GetNode *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNode); }
	         _tptz__GetNode() { _tptz__GetNode::soap_default(NULL); }
	virtual ~_tptz__GetNode() { }
	friend _tptz__GetNode *soap_instantiate__tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3435 */
#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (1238)
/* tptz:GetNodeResponse complex type: */
class SOAP_CMAC _tptz__GetNodeResponse
{
public:
	tt__PTZNode *PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZNode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodeResponse (1238)
	virtual int soap_type(void) const { return 1238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodeResponse, default initialized and not managed by a soap context
	virtual _tptz__GetNodeResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodeResponse); }
	         _tptz__GetNodeResponse() { _tptz__GetNodeResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodeResponse() { }
	friend _tptz__GetNodeResponse *soap_instantiate__tptz__GetNodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3438 */
#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (1239)
/* tptz:GetConfigurations complex type: */
class SOAP_CMAC _tptz__GetConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurations (1239)
	virtual int soap_type(void) const { return 1239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurations, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurations *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurations); }
	         _tptz__GetConfigurations() { _tptz__GetConfigurations::soap_default(NULL); }
	virtual ~_tptz__GetConfigurations() { }
	friend _tptz__GetConfigurations *soap_instantiate__tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3441 */
#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (1240)
/* tptz:GetConfigurationsResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationsResponse
{
public:
	std::vector<tt__PTZConfiguration *> PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:PTZConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationsResponse (1240)
	virtual int soap_type(void) const { return 1240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationsResponse); }
	         _tptz__GetConfigurationsResponse() { _tptz__GetConfigurationsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationsResponse() { }
	friend _tptz__GetConfigurationsResponse *soap_instantiate__tptz__GetConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3444 */
#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (1241)
/* tptz:GetConfiguration complex type: */
class SOAP_CMAC _tptz__GetConfiguration
{
public:
	std::string PTZConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfiguration (1241)
	virtual int soap_type(void) const { return 1241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfiguration, default initialized and not managed by a soap context
	virtual _tptz__GetConfiguration *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfiguration); }
	         _tptz__GetConfiguration() { _tptz__GetConfiguration::soap_default(NULL); }
	virtual ~_tptz__GetConfiguration() { }
	friend _tptz__GetConfiguration *soap_instantiate__tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3447 */
#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (1242)
/* tptz:GetConfigurationResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationResponse
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationResponse (1242)
	virtual int soap_type(void) const { return 1242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationResponse); }
	         _tptz__GetConfigurationResponse() { _tptz__GetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationResponse() { }
	friend _tptz__GetConfigurationResponse *soap_instantiate__tptz__GetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3450 */
#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (1243)
/* tptz:SetConfiguration complex type: */
class SOAP_CMAC _tptz__SetConfiguration
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* required element of XSD type tt:PTZConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetConfiguration (1243)
	virtual int soap_type(void) const { return 1243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetConfiguration, default initialized and not managed by a soap context
	virtual _tptz__SetConfiguration *soap_alloc(void) const { return SOAP_NEW(_tptz__SetConfiguration); }
	         _tptz__SetConfiguration() { _tptz__SetConfiguration::soap_default(NULL); }
	virtual ~_tptz__SetConfiguration() { }
	friend _tptz__SetConfiguration *soap_instantiate__tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34217 */
#ifndef SOAP_TYPE___tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE___tptz__SetConfigurationResponse_sequence (2241)
/* Operation wrapper: */
class SOAP_CMAC __tptz__SetConfigurationResponse_sequence
{
public:
	/// Return the unique type ID value SOAP_TYPE___tptz__SetConfigurationResponse_sequence (2241)
	virtual int soap_type(void) const { return 2241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tptz__SetConfigurationResponse_sequence, default initialized and not managed by a soap context
	virtual __tptz__SetConfigurationResponse_sequence *soap_alloc(void) const { return SOAP_NEW(__tptz__SetConfigurationResponse_sequence); }
	         __tptz__SetConfigurationResponse_sequence() { __tptz__SetConfigurationResponse_sequence::soap_default(NULL); }
	virtual ~__tptz__SetConfigurationResponse_sequence() { }
	friend __tptz__SetConfigurationResponse_sequence *soap_instantiate___tptz__SetConfigurationResponse_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3453 */
#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (1244)
/* tptz:SetConfigurationResponse complex type: */
class SOAP_CMAC _tptz__SetConfigurationResponse
{
public:
	__tptz__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetConfigurationResponse (1244)
	virtual int soap_type(void) const { return 1244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetConfigurationResponse, default initialized and not managed by a soap context
	virtual _tptz__SetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetConfigurationResponse); }
	         _tptz__SetConfigurationResponse() { _tptz__SetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__SetConfigurationResponse() { }
	friend _tptz__SetConfigurationResponse *soap_instantiate__tptz__SetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3456 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (1245)
/* tptz:GetConfigurationOptions complex type: */
class SOAP_CMAC _tptz__GetConfigurationOptions
{
public:
	std::string ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationOptions (1245)
	virtual int soap_type(void) const { return 1245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationOptions, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationOptions); }
	         _tptz__GetConfigurationOptions() { _tptz__GetConfigurationOptions::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptions() { }
	friend _tptz__GetConfigurationOptions *soap_instantiate__tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3459 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (1246)
/* tptz:GetConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationOptionsResponse
{
public:
	tt__PTZConfigurationOptions *PTZConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationOptionsResponse (1246)
	virtual int soap_type(void) const { return 1246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationOptionsResponse); }
	         _tptz__GetConfigurationOptionsResponse() { _tptz__GetConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptionsResponse() { }
	friend _tptz__GetConfigurationOptionsResponse *soap_instantiate__tptz__GetConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3462 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (1247)
/* tptz:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tptz__SendAuxiliaryCommand
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string AuxiliaryData;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SendAuxiliaryCommand (1247)
	virtual int soap_type(void) const { return 1247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tptz__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tptz__SendAuxiliaryCommand); }
	         _tptz__SendAuxiliaryCommand() { _tptz__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommand() { }
	friend _tptz__SendAuxiliaryCommand *soap_instantiate__tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3465 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (1248)
/* tptz:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tptz__SendAuxiliaryCommandResponse
{
public:
	std::string AuxiliaryResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (1248)
	virtual int soap_type(void) const { return 1248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tptz__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SendAuxiliaryCommandResponse); }
	         _tptz__SendAuxiliaryCommandResponse() { _tptz__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommandResponse() { }
	friend _tptz__SendAuxiliaryCommandResponse *soap_instantiate__tptz__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3468 */
#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (1249)
/* tptz:GetPresets complex type: */
class SOAP_CMAC _tptz__GetPresets
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresets (1249)
	virtual int soap_type(void) const { return 1249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresets, default initialized and not managed by a soap context
	virtual _tptz__GetPresets *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresets); }
	         _tptz__GetPresets() { _tptz__GetPresets::soap_default(NULL); }
	virtual ~_tptz__GetPresets() { }
	friend _tptz__GetPresets *soap_instantiate__tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3471 */
#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (1250)
/* tptz:GetPresetsResponse complex type: */
class SOAP_CMAC _tptz__GetPresetsResponse
{
public:
	std::vector<tt__PTZPreset *> Preset;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:PTZPreset */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetsResponse (1250)
	virtual int soap_type(void) const { return 1250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetsResponse); }
	         _tptz__GetPresetsResponse() { _tptz__GetPresetsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetsResponse() { }
	friend _tptz__GetPresetsResponse *soap_instantiate__tptz__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3474 */
#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (1251)
/* tptz:SetPreset complex type: */
class SOAP_CMAC _tptz__SetPreset
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *PresetName;	/* optional element of XSD type xsd:string */
	std::string *PresetToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetPreset (1251)
	virtual int soap_type(void) const { return 1251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetPreset, default initialized and not managed by a soap context
	virtual _tptz__SetPreset *soap_alloc(void) const { return SOAP_NEW(_tptz__SetPreset); }
	         _tptz__SetPreset() { _tptz__SetPreset::soap_default(NULL); }
	virtual ~_tptz__SetPreset() { }
	friend _tptz__SetPreset *soap_instantiate__tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3477 */
#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (1252)
/* tptz:SetPresetResponse complex type: */
class SOAP_CMAC _tptz__SetPresetResponse
{
public:
	std::string PresetToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetPresetResponse (1252)
	virtual int soap_type(void) const { return 1252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetPresetResponse, default initialized and not managed by a soap context
	virtual _tptz__SetPresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetPresetResponse); }
	         _tptz__SetPresetResponse() { _tptz__SetPresetResponse::soap_default(NULL); }
	virtual ~_tptz__SetPresetResponse() { }
	friend _tptz__SetPresetResponse *soap_instantiate__tptz__SetPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3480 */
#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (1253)
/* tptz:RemovePreset complex type: */
class SOAP_CMAC _tptz__RemovePreset
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string PresetToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePreset (1253)
	virtual int soap_type(void) const { return 1253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePreset, default initialized and not managed by a soap context
	virtual _tptz__RemovePreset *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePreset); }
	         _tptz__RemovePreset() { _tptz__RemovePreset::soap_default(NULL); }
	virtual ~_tptz__RemovePreset() { }
	friend _tptz__RemovePreset *soap_instantiate__tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3483 */
#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (1254)
/* tptz:RemovePresetResponse complex type: */
class SOAP_CMAC _tptz__RemovePresetResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetResponse (1254)
	virtual int soap_type(void) const { return 1254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetResponse, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetResponse); }
	         _tptz__RemovePresetResponse() { _tptz__RemovePresetResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetResponse() { }
	friend _tptz__RemovePresetResponse *soap_instantiate__tptz__RemovePresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3486 */
#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (1255)
/* tptz:GotoPreset complex type: */
class SOAP_CMAC _tptz__GotoPreset
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string PresetToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoPreset (1255)
	virtual int soap_type(void) const { return 1255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoPreset, default initialized and not managed by a soap context
	virtual _tptz__GotoPreset *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoPreset); }
	         _tptz__GotoPreset() { _tptz__GotoPreset::soap_default(NULL); }
	virtual ~_tptz__GotoPreset() { }
	friend _tptz__GotoPreset *soap_instantiate__tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3489 */
#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (1256)
/* tptz:GotoPresetResponse complex type: */
class SOAP_CMAC _tptz__GotoPresetResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoPresetResponse (1256)
	virtual int soap_type(void) const { return 1256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoPresetResponse, default initialized and not managed by a soap context
	virtual _tptz__GotoPresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoPresetResponse); }
	         _tptz__GotoPresetResponse() { _tptz__GotoPresetResponse::soap_default(NULL); }
	virtual ~_tptz__GotoPresetResponse() { }
	friend _tptz__GotoPresetResponse *soap_instantiate__tptz__GotoPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3492 */
#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (1257)
/* tptz:GetStatus complex type: */
class SOAP_CMAC _tptz__GetStatus
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetStatus (1257)
	virtual int soap_type(void) const { return 1257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetStatus, default initialized and not managed by a soap context
	virtual _tptz__GetStatus *soap_alloc(void) const { return SOAP_NEW(_tptz__GetStatus); }
	         _tptz__GetStatus() { _tptz__GetStatus::soap_default(NULL); }
	virtual ~_tptz__GetStatus() { }
	friend _tptz__GetStatus *soap_instantiate__tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3495 */
#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (1258)
/* tptz:GetStatusResponse complex type: */
class SOAP_CMAC _tptz__GetStatusResponse
{
public:
	tt__PTZStatus *PTZStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetStatusResponse (1258)
	virtual int soap_type(void) const { return 1258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetStatusResponse, default initialized and not managed by a soap context
	virtual _tptz__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetStatusResponse); }
	         _tptz__GetStatusResponse() { _tptz__GetStatusResponse::soap_default(NULL); }
	virtual ~_tptz__GetStatusResponse() { }
	friend _tptz__GetStatusResponse *soap_instantiate__tptz__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3498 */
#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (1259)
/* tptz:GotoHomePosition complex type: */
class SOAP_CMAC _tptz__GotoHomePosition
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoHomePosition (1259)
	virtual int soap_type(void) const { return 1259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoHomePosition, default initialized and not managed by a soap context
	virtual _tptz__GotoHomePosition *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoHomePosition); }
	         _tptz__GotoHomePosition() { _tptz__GotoHomePosition::soap_default(NULL); }
	virtual ~_tptz__GotoHomePosition() { }
	friend _tptz__GotoHomePosition *soap_instantiate__tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3501 */
#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (1260)
/* tptz:GotoHomePositionResponse complex type: */
class SOAP_CMAC _tptz__GotoHomePositionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoHomePositionResponse (1260)
	virtual int soap_type(void) const { return 1260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoHomePositionResponse, default initialized and not managed by a soap context
	virtual _tptz__GotoHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoHomePositionResponse); }
	         _tptz__GotoHomePositionResponse() { _tptz__GotoHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__GotoHomePositionResponse() { }
	friend _tptz__GotoHomePositionResponse *soap_instantiate__tptz__GotoHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3504 */
#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (1261)
/* tptz:SetHomePosition complex type: */
class SOAP_CMAC _tptz__SetHomePosition
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetHomePosition (1261)
	virtual int soap_type(void) const { return 1261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetHomePosition, default initialized and not managed by a soap context
	virtual _tptz__SetHomePosition *soap_alloc(void) const { return SOAP_NEW(_tptz__SetHomePosition); }
	         _tptz__SetHomePosition() { _tptz__SetHomePosition::soap_default(NULL); }
	virtual ~_tptz__SetHomePosition() { }
	friend _tptz__SetHomePosition *soap_instantiate__tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3507 */
#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (1262)
/* tptz:SetHomePositionResponse complex type: */
class SOAP_CMAC _tptz__SetHomePositionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetHomePositionResponse (1262)
	virtual int soap_type(void) const { return 1262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetHomePositionResponse, default initialized and not managed by a soap context
	virtual _tptz__SetHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetHomePositionResponse); }
	         _tptz__SetHomePositionResponse() { _tptz__SetHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__SetHomePositionResponse() { }
	friend _tptz__SetHomePositionResponse *soap_instantiate__tptz__SetHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3510 */
#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (1263)
/* tptz:ContinuousMove complex type: */
class SOAP_CMAC _tptz__ContinuousMove
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Velocity;	/* required element of XSD type tt:PTZSpeed */
	tt__PTZVector *Position;
	LONG64 *Timeout;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ContinuousMove (1263)
	virtual int soap_type(void) const { return 1263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ContinuousMove, default initialized and not managed by a soap context
	virtual _tptz__ContinuousMove *soap_alloc(void) const { return SOAP_NEW(_tptz__ContinuousMove); }
	         _tptz__ContinuousMove() { _tptz__ContinuousMove::soap_default(NULL); }
	virtual ~_tptz__ContinuousMove() { }
	friend _tptz__ContinuousMove *soap_instantiate__tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3513 */
#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (1264)
/* tptz:ContinuousMoveResponse complex type: */
class SOAP_CMAC _tptz__ContinuousMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ContinuousMoveResponse (1264)
	virtual int soap_type(void) const { return 1264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ContinuousMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__ContinuousMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__ContinuousMoveResponse); }
	         _tptz__ContinuousMoveResponse() { _tptz__ContinuousMoveResponse::soap_default(NULL); }
	virtual ~_tptz__ContinuousMoveResponse() { }
	friend _tptz__ContinuousMoveResponse *soap_instantiate__tptz__ContinuousMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3516 */
#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (1265)
/* tptz:RelativeMove complex type: */
class SOAP_CMAC _tptz__RelativeMove
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZVector *Translation;	/* required element of XSD type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RelativeMove (1265)
	virtual int soap_type(void) const { return 1265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RelativeMove, default initialized and not managed by a soap context
	virtual _tptz__RelativeMove *soap_alloc(void) const { return SOAP_NEW(_tptz__RelativeMove); }
	         _tptz__RelativeMove() { _tptz__RelativeMove::soap_default(NULL); }
	virtual ~_tptz__RelativeMove() { }
	friend _tptz__RelativeMove *soap_instantiate__tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3519 */
#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (1266)
/* tptz:RelativeMoveResponse complex type: */
class SOAP_CMAC _tptz__RelativeMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RelativeMoveResponse (1266)
	virtual int soap_type(void) const { return 1266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RelativeMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__RelativeMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RelativeMoveResponse); }
	         _tptz__RelativeMoveResponse() { _tptz__RelativeMoveResponse::soap_default(NULL); }
	virtual ~_tptz__RelativeMoveResponse() { }
	friend _tptz__RelativeMoveResponse *soap_instantiate__tptz__RelativeMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3522 */
#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (1267)
/* tptz:AbsoluteMove complex type: */
class SOAP_CMAC _tptz__AbsoluteMove
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__AbsoluteMove (1267)
	virtual int soap_type(void) const { return 1267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__AbsoluteMove, default initialized and not managed by a soap context
	virtual _tptz__AbsoluteMove *soap_alloc(void) const { return SOAP_NEW(_tptz__AbsoluteMove); }
	         _tptz__AbsoluteMove() { _tptz__AbsoluteMove::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMove() { }
	friend _tptz__AbsoluteMove *soap_instantiate__tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3525 */
#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (1268)
/* tptz:AbsoluteMoveResponse complex type: */
class SOAP_CMAC _tptz__AbsoluteMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__AbsoluteMoveResponse (1268)
	virtual int soap_type(void) const { return 1268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__AbsoluteMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__AbsoluteMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__AbsoluteMoveResponse); }
	         _tptz__AbsoluteMoveResponse() { _tptz__AbsoluteMoveResponse::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMoveResponse() { }
	friend _tptz__AbsoluteMoveResponse *soap_instantiate__tptz__AbsoluteMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3528 */
#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (1269)
/* tptz:Stop complex type: */
class SOAP_CMAC _tptz__Stop
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	bool *PanTilt;	/* optional element of XSD type xsd:boolean */
	bool *Zoom;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__Stop (1269)
	virtual int soap_type(void) const { return 1269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__Stop, default initialized and not managed by a soap context
	virtual _tptz__Stop *soap_alloc(void) const { return SOAP_NEW(_tptz__Stop); }
	         _tptz__Stop() { _tptz__Stop::soap_default(NULL); }
	virtual ~_tptz__Stop() { }
	friend _tptz__Stop *soap_instantiate__tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3531 */
#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (1270)
/* tptz:StopResponse complex type: */
class SOAP_CMAC _tptz__StopResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__StopResponse (1270)
	virtual int soap_type(void) const { return 1270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__StopResponse, default initialized and not managed by a soap context
	virtual _tptz__StopResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__StopResponse); }
	         _tptz__StopResponse() { _tptz__StopResponse::soap_default(NULL); }
	virtual ~_tptz__StopResponse() { }
	friend _tptz__StopResponse *soap_instantiate__tptz__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3534 */
#ifndef SOAP_TYPE__tptz__GetPresetTours
#define SOAP_TYPE__tptz__GetPresetTours (1271)
/* tptz:GetPresetTours complex type: */
class SOAP_CMAC _tptz__GetPresetTours
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTours (1271)
	virtual int soap_type(void) const { return 1271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTours, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTours *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTours); }
	         _tptz__GetPresetTours() { _tptz__GetPresetTours::soap_default(NULL); }
	virtual ~_tptz__GetPresetTours() { }
	friend _tptz__GetPresetTours *soap_instantiate__tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3537 */
#ifndef SOAP_TYPE__tptz__GetPresetToursResponse
#define SOAP_TYPE__tptz__GetPresetToursResponse (1272)
/* tptz:GetPresetToursResponse complex type: */
class SOAP_CMAC _tptz__GetPresetToursResponse
{
public:
	std::vector<tt__PresetTour *> PresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:PresetTour */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetToursResponse (1272)
	virtual int soap_type(void) const { return 1272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetToursResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetToursResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetToursResponse); }
	         _tptz__GetPresetToursResponse() { _tptz__GetPresetToursResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetToursResponse() { }
	friend _tptz__GetPresetToursResponse *soap_instantiate__tptz__GetPresetToursResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3540 */
#ifndef SOAP_TYPE__tptz__GetPresetTour
#define SOAP_TYPE__tptz__GetPresetTour (1273)
/* tptz:GetPresetTour complex type: */
class SOAP_CMAC _tptz__GetPresetTour
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTour (1273)
	virtual int soap_type(void) const { return 1273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTour, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTour); }
	         _tptz__GetPresetTour() { _tptz__GetPresetTour::soap_default(NULL); }
	virtual ~_tptz__GetPresetTour() { }
	friend _tptz__GetPresetTour *soap_instantiate__tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3543 */
#ifndef SOAP_TYPE__tptz__GetPresetTourResponse
#define SOAP_TYPE__tptz__GetPresetTourResponse (1274)
/* tptz:GetPresetTourResponse complex type: */
class SOAP_CMAC _tptz__GetPresetTourResponse
{
public:
	tt__PresetTour *PresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PresetTour */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourResponse (1274)
	virtual int soap_type(void) const { return 1274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourResponse); }
	         _tptz__GetPresetTourResponse() { _tptz__GetPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourResponse() { }
	friend _tptz__GetPresetTourResponse *soap_instantiate__tptz__GetPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3546 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptions
#define SOAP_TYPE__tptz__GetPresetTourOptions (1275)
/* tptz:GetPresetTourOptions complex type: */
class SOAP_CMAC _tptz__GetPresetTourOptions
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *PresetTourToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourOptions (1275)
	virtual int soap_type(void) const { return 1275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourOptions, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourOptions); }
	         _tptz__GetPresetTourOptions() { _tptz__GetPresetTourOptions::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptions() { }
	friend _tptz__GetPresetTourOptions *soap_instantiate__tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3549 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptionsResponse
#define SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1276)
/* tptz:GetPresetTourOptionsResponse complex type: */
class SOAP_CMAC _tptz__GetPresetTourOptionsResponse
{
public:
	tt__PTZPresetTourOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZPresetTourOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1276)
	virtual int soap_type(void) const { return 1276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourOptionsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourOptionsResponse); }
	         _tptz__GetPresetTourOptionsResponse() { _tptz__GetPresetTourOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptionsResponse() { }
	friend _tptz__GetPresetTourOptionsResponse *soap_instantiate__tptz__GetPresetTourOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3552 */
#ifndef SOAP_TYPE__tptz__CreatePresetTour
#define SOAP_TYPE__tptz__CreatePresetTour (1277)
/* tptz:CreatePresetTour complex type: */
class SOAP_CMAC _tptz__CreatePresetTour
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__CreatePresetTour (1277)
	virtual int soap_type(void) const { return 1277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__CreatePresetTour, default initialized and not managed by a soap context
	virtual _tptz__CreatePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__CreatePresetTour); }
	         _tptz__CreatePresetTour() { _tptz__CreatePresetTour::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTour() { }
	friend _tptz__CreatePresetTour *soap_instantiate__tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3555 */
#ifndef SOAP_TYPE__tptz__CreatePresetTourResponse
#define SOAP_TYPE__tptz__CreatePresetTourResponse (1278)
/* tptz:CreatePresetTourResponse complex type: */
class SOAP_CMAC _tptz__CreatePresetTourResponse
{
public:
	std::string PresetTourToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__CreatePresetTourResponse (1278)
	virtual int soap_type(void) const { return 1278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__CreatePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__CreatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__CreatePresetTourResponse); }
	         _tptz__CreatePresetTourResponse() { _tptz__CreatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTourResponse() { }
	friend _tptz__CreatePresetTourResponse *soap_instantiate__tptz__CreatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3558 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTour
#define SOAP_TYPE__tptz__ModifyPresetTour (1279)
/* tptz:ModifyPresetTour complex type: */
class SOAP_CMAC _tptz__ModifyPresetTour
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PresetTour *PresetTour;	/* required element of XSD type tt:PresetTour */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ModifyPresetTour (1279)
	virtual int soap_type(void) const { return 1279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ModifyPresetTour, default initialized and not managed by a soap context
	virtual _tptz__ModifyPresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__ModifyPresetTour); }
	         _tptz__ModifyPresetTour() { _tptz__ModifyPresetTour::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTour() { }
	friend _tptz__ModifyPresetTour *soap_instantiate__tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3561 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTourResponse
#define SOAP_TYPE__tptz__ModifyPresetTourResponse (1280)
/* tptz:ModifyPresetTourResponse complex type: */
class SOAP_CMAC _tptz__ModifyPresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ModifyPresetTourResponse (1280)
	virtual int soap_type(void) const { return 1280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ModifyPresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__ModifyPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__ModifyPresetTourResponse); }
	         _tptz__ModifyPresetTourResponse() { _tptz__ModifyPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTourResponse() { }
	friend _tptz__ModifyPresetTourResponse *soap_instantiate__tptz__ModifyPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3564 */
#ifndef SOAP_TYPE__tptz__OperatePresetTour
#define SOAP_TYPE__tptz__OperatePresetTour (1281)
/* tptz:OperatePresetTour complex type: */
class SOAP_CMAC _tptz__OperatePresetTour
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__PTZPresetTourOperation Operation;	/* required element of XSD type tt:PTZPresetTourOperation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__OperatePresetTour (1281)
	virtual int soap_type(void) const { return 1281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__OperatePresetTour, default initialized and not managed by a soap context
	virtual _tptz__OperatePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__OperatePresetTour); }
	         _tptz__OperatePresetTour() { _tptz__OperatePresetTour::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTour() { }
	friend _tptz__OperatePresetTour *soap_instantiate__tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3567 */
#ifndef SOAP_TYPE__tptz__OperatePresetTourResponse
#define SOAP_TYPE__tptz__OperatePresetTourResponse (1282)
/* tptz:OperatePresetTourResponse complex type: */
class SOAP_CMAC _tptz__OperatePresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__OperatePresetTourResponse (1282)
	virtual int soap_type(void) const { return 1282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__OperatePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__OperatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__OperatePresetTourResponse); }
	         _tptz__OperatePresetTourResponse() { _tptz__OperatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTourResponse() { }
	friend _tptz__OperatePresetTourResponse *soap_instantiate__tptz__OperatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3570 */
#ifndef SOAP_TYPE__tptz__RemovePresetTour
#define SOAP_TYPE__tptz__RemovePresetTour (1283)
/* tptz:RemovePresetTour complex type: */
class SOAP_CMAC _tptz__RemovePresetTour
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	std::string PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetTour (1283)
	virtual int soap_type(void) const { return 1283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetTour, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetTour); }
	         _tptz__RemovePresetTour() { _tptz__RemovePresetTour::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTour() { }
	friend _tptz__RemovePresetTour *soap_instantiate__tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3573 */
#ifndef SOAP_TYPE__tptz__RemovePresetTourResponse
#define SOAP_TYPE__tptz__RemovePresetTourResponse (1284)
/* tptz:RemovePresetTourResponse complex type: */
class SOAP_CMAC _tptz__RemovePresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetTourResponse (1284)
	virtual int soap_type(void) const { return 1284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetTourResponse); }
	         _tptz__RemovePresetTourResponse() { _tptz__RemovePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTourResponse() { }
	friend _tptz__RemovePresetTourResponse *soap_instantiate__tptz__RemovePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3576 */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurations
#define SOAP_TYPE__tptz__GetCompatibleConfigurations (1285)
/* tptz:GetCompatibleConfigurations complex type: */
class SOAP_CMAC _tptz__GetCompatibleConfigurations
{
public:
	std::string ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetCompatibleConfigurations (1285)
	virtual int soap_type(void) const { return 1285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetCompatibleConfigurations, default initialized and not managed by a soap context
	virtual _tptz__GetCompatibleConfigurations *soap_alloc(void) const { return SOAP_NEW(_tptz__GetCompatibleConfigurations); }
	         _tptz__GetCompatibleConfigurations() { _tptz__GetCompatibleConfigurations::soap_default(NULL); }
	virtual ~_tptz__GetCompatibleConfigurations() { }
	friend _tptz__GetCompatibleConfigurations *soap_instantiate__tptz__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3579 */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse
#define SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse (1286)
/* tptz:GetCompatibleConfigurationsResponse complex type: */
class SOAP_CMAC _tptz__GetCompatibleConfigurationsResponse
{
public:
	std::vector<tt__PTZConfiguration *> PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:PTZConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse (1286)
	virtual int soap_type(void) const { return 1286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetCompatibleConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetCompatibleConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetCompatibleConfigurationsResponse); }
	         _tptz__GetCompatibleConfigurationsResponse() { _tptz__GetCompatibleConfigurationsResponse::soap_default(NULL); }
	virtual ~_tptz__GetCompatibleConfigurationsResponse() { }
	friend _tptz__GetCompatibleConfigurationsResponse *soap_instantiate__tptz__GetCompatibleConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3582 */
#ifndef SOAP_TYPE_trv__Capabilities
#define SOAP_TYPE_trv__Capabilities (1287)
/* Type trv__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trv:Capabilities complex type: */
class SOAP_CMAC trv__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *RTP_USCOREMulticast;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	int SupportedReceivers;	/* required attribute of XSD type xsd:int */
	int *MaximumRTSPURILength;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trv__Capabilities (1287)
	virtual int soap_type(void) const { return 1287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trv__Capabilities, default initialized and not managed by a soap context
	virtual trv__Capabilities *soap_alloc(void) const { return SOAP_NEW(trv__Capabilities); }
	         trv__Capabilities() { trv__Capabilities::soap_default(NULL); }
	virtual ~trv__Capabilities() { }
	friend trv__Capabilities *soap_instantiate_trv__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3585 */
#ifndef SOAP_TYPE__trv__GetServiceCapabilities
#define SOAP_TYPE__trv__GetServiceCapabilities (1288)
/* trv:GetServiceCapabilities complex type: */
class SOAP_CMAC _trv__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetServiceCapabilities (1288)
	virtual int soap_type(void) const { return 1288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trv__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trv__GetServiceCapabilities); }
	         _trv__GetServiceCapabilities() { _trv__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trv__GetServiceCapabilities() { }
	friend _trv__GetServiceCapabilities *soap_instantiate__trv__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3588 */
#ifndef SOAP_TYPE__trv__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trv__GetServiceCapabilitiesResponse (1289)
/* trv:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trv__GetServiceCapabilitiesResponse
{
public:
	trv__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trv:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetServiceCapabilitiesResponse (1289)
	virtual int soap_type(void) const { return 1289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trv__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetServiceCapabilitiesResponse); }
	         _trv__GetServiceCapabilitiesResponse() { _trv__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trv__GetServiceCapabilitiesResponse() { }
	friend _trv__GetServiceCapabilitiesResponse *soap_instantiate__trv__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3591 */
#ifndef SOAP_TYPE__trv__GetReceivers
#define SOAP_TYPE__trv__GetReceivers (1290)
/* trv:GetReceivers complex type: */
class SOAP_CMAC _trv__GetReceivers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceivers (1290)
	virtual int soap_type(void) const { return 1290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceivers, default initialized and not managed by a soap context
	virtual _trv__GetReceivers *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceivers); }
	         _trv__GetReceivers() { _trv__GetReceivers::soap_default(NULL); }
	virtual ~_trv__GetReceivers() { }
	friend _trv__GetReceivers *soap_instantiate__trv__GetReceivers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3594 */
#ifndef SOAP_TYPE__trv__GetReceiversResponse
#define SOAP_TYPE__trv__GetReceiversResponse (1291)
/* trv:GetReceiversResponse complex type: */
class SOAP_CMAC _trv__GetReceiversResponse
{
public:
	std::vector<tt__Receiver *> Receivers;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Receiver */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiversResponse (1291)
	virtual int soap_type(void) const { return 1291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiversResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiversResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiversResponse); }
	         _trv__GetReceiversResponse() { _trv__GetReceiversResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiversResponse() { }
	friend _trv__GetReceiversResponse *soap_instantiate__trv__GetReceiversResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3597 */
#ifndef SOAP_TYPE__trv__GetReceiver
#define SOAP_TYPE__trv__GetReceiver (1292)
/* trv:GetReceiver complex type: */
class SOAP_CMAC _trv__GetReceiver
{
public:
	std::string ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiver (1292)
	virtual int soap_type(void) const { return 1292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiver, default initialized and not managed by a soap context
	virtual _trv__GetReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiver); }
	         _trv__GetReceiver() { _trv__GetReceiver::soap_default(NULL); }
	virtual ~_trv__GetReceiver() { }
	friend _trv__GetReceiver *soap_instantiate__trv__GetReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3600 */
#ifndef SOAP_TYPE__trv__GetReceiverResponse
#define SOAP_TYPE__trv__GetReceiverResponse (1293)
/* trv:GetReceiverResponse complex type: */
class SOAP_CMAC _trv__GetReceiverResponse
{
public:
	tt__Receiver *Receiver;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Receiver */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverResponse (1293)
	virtual int soap_type(void) const { return 1293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverResponse); }
	         _trv__GetReceiverResponse() { _trv__GetReceiverResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiverResponse() { }
	friend _trv__GetReceiverResponse *soap_instantiate__trv__GetReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3603 */
#ifndef SOAP_TYPE__trv__CreateReceiver
#define SOAP_TYPE__trv__CreateReceiver (1294)
/* trv:CreateReceiver complex type: */
class SOAP_CMAC _trv__CreateReceiver
{
public:
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__CreateReceiver (1294)
	virtual int soap_type(void) const { return 1294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__CreateReceiver, default initialized and not managed by a soap context
	virtual _trv__CreateReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__CreateReceiver); }
	         _trv__CreateReceiver() { _trv__CreateReceiver::soap_default(NULL); }
	virtual ~_trv__CreateReceiver() { }
	friend _trv__CreateReceiver *soap_instantiate__trv__CreateReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3606 */
#ifndef SOAP_TYPE__trv__CreateReceiverResponse
#define SOAP_TYPE__trv__CreateReceiverResponse (1295)
/* trv:CreateReceiverResponse complex type: */
class SOAP_CMAC _trv__CreateReceiverResponse
{
public:
	tt__Receiver *Receiver;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Receiver */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__CreateReceiverResponse (1295)
	virtual int soap_type(void) const { return 1295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__CreateReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__CreateReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__CreateReceiverResponse); }
	         _trv__CreateReceiverResponse() { _trv__CreateReceiverResponse::soap_default(NULL); }
	virtual ~_trv__CreateReceiverResponse() { }
	friend _trv__CreateReceiverResponse *soap_instantiate__trv__CreateReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3609 */
#ifndef SOAP_TYPE__trv__DeleteReceiver
#define SOAP_TYPE__trv__DeleteReceiver (1296)
/* trv:DeleteReceiver complex type: */
class SOAP_CMAC _trv__DeleteReceiver
{
public:
	std::string ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__DeleteReceiver (1296)
	virtual int soap_type(void) const { return 1296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__DeleteReceiver, default initialized and not managed by a soap context
	virtual _trv__DeleteReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__DeleteReceiver); }
	         _trv__DeleteReceiver() { _trv__DeleteReceiver::soap_default(NULL); }
	virtual ~_trv__DeleteReceiver() { }
	friend _trv__DeleteReceiver *soap_instantiate__trv__DeleteReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3612 */
#ifndef SOAP_TYPE__trv__DeleteReceiverResponse
#define SOAP_TYPE__trv__DeleteReceiverResponse (1297)
/* trv:DeleteReceiverResponse complex type: */
class SOAP_CMAC _trv__DeleteReceiverResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__DeleteReceiverResponse (1297)
	virtual int soap_type(void) const { return 1297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__DeleteReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__DeleteReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__DeleteReceiverResponse); }
	         _trv__DeleteReceiverResponse() { _trv__DeleteReceiverResponse::soap_default(NULL); }
	virtual ~_trv__DeleteReceiverResponse() { }
	friend _trv__DeleteReceiverResponse *soap_instantiate__trv__DeleteReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3615 */
#ifndef SOAP_TYPE__trv__ConfigureReceiver
#define SOAP_TYPE__trv__ConfigureReceiver (1298)
/* trv:ConfigureReceiver complex type: */
class SOAP_CMAC _trv__ConfigureReceiver
{
public:
	std::string ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__ConfigureReceiver (1298)
	virtual int soap_type(void) const { return 1298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__ConfigureReceiver, default initialized and not managed by a soap context
	virtual _trv__ConfigureReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__ConfigureReceiver); }
	         _trv__ConfigureReceiver() { _trv__ConfigureReceiver::soap_default(NULL); }
	virtual ~_trv__ConfigureReceiver() { }
	friend _trv__ConfigureReceiver *soap_instantiate__trv__ConfigureReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3618 */
#ifndef SOAP_TYPE__trv__ConfigureReceiverResponse
#define SOAP_TYPE__trv__ConfigureReceiverResponse (1299)
/* trv:ConfigureReceiverResponse complex type: */
class SOAP_CMAC _trv__ConfigureReceiverResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__ConfigureReceiverResponse (1299)
	virtual int soap_type(void) const { return 1299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__ConfigureReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__ConfigureReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__ConfigureReceiverResponse); }
	         _trv__ConfigureReceiverResponse() { _trv__ConfigureReceiverResponse::soap_default(NULL); }
	virtual ~_trv__ConfigureReceiverResponse() { }
	friend _trv__ConfigureReceiverResponse *soap_instantiate__trv__ConfigureReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3621 */
#ifndef SOAP_TYPE__trv__SetReceiverMode
#define SOAP_TYPE__trv__SetReceiverMode (1300)
/* trv:SetReceiverMode complex type: */
class SOAP_CMAC _trv__SetReceiverMode
{
public:
	std::string ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__SetReceiverMode (1300)
	virtual int soap_type(void) const { return 1300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__SetReceiverMode, default initialized and not managed by a soap context
	virtual _trv__SetReceiverMode *soap_alloc(void) const { return SOAP_NEW(_trv__SetReceiverMode); }
	         _trv__SetReceiverMode() { _trv__SetReceiverMode::soap_default(NULL); }
	virtual ~_trv__SetReceiverMode() { }
	friend _trv__SetReceiverMode *soap_instantiate__trv__SetReceiverMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3624 */
#ifndef SOAP_TYPE__trv__SetReceiverModeResponse
#define SOAP_TYPE__trv__SetReceiverModeResponse (1301)
/* trv:SetReceiverModeResponse complex type: */
class SOAP_CMAC _trv__SetReceiverModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__SetReceiverModeResponse (1301)
	virtual int soap_type(void) const { return 1301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__SetReceiverModeResponse, default initialized and not managed by a soap context
	virtual _trv__SetReceiverModeResponse *soap_alloc(void) const { return SOAP_NEW(_trv__SetReceiverModeResponse); }
	         _trv__SetReceiverModeResponse() { _trv__SetReceiverModeResponse::soap_default(NULL); }
	virtual ~_trv__SetReceiverModeResponse() { }
	friend _trv__SetReceiverModeResponse *soap_instantiate__trv__SetReceiverModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3627 */
#ifndef SOAP_TYPE__trv__GetReceiverState
#define SOAP_TYPE__trv__GetReceiverState (1302)
/* trv:GetReceiverState complex type: */
class SOAP_CMAC _trv__GetReceiverState
{
public:
	std::string ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverState (1302)
	virtual int soap_type(void) const { return 1302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverState, default initialized and not managed by a soap context
	virtual _trv__GetReceiverState *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverState); }
	         _trv__GetReceiverState() { _trv__GetReceiverState::soap_default(NULL); }
	virtual ~_trv__GetReceiverState() { }
	friend _trv__GetReceiverState *soap_instantiate__trv__GetReceiverState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3630 */
#ifndef SOAP_TYPE__trv__GetReceiverStateResponse
#define SOAP_TYPE__trv__GetReceiverStateResponse (1303)
/* trv:GetReceiverStateResponse complex type: */
class SOAP_CMAC _trv__GetReceiverStateResponse
{
public:
	tt__ReceiverStateInformation *ReceiverState;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReceiverStateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverStateResponse (1303)
	virtual int soap_type(void) const { return 1303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverStateResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiverStateResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverStateResponse); }
	         _trv__GetReceiverStateResponse() { _trv__GetReceiverStateResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiverStateResponse() { }
	friend _trv__GetReceiverStateResponse *soap_instantiate__trv__GetReceiverStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3633 */
#ifndef SOAP_TYPE_trc__Capabilities
#define SOAP_TYPE_trc__Capabilities (1304)
/* Type trc__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:Capabilities complex type: */
class SOAP_CMAC trc__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *DynamicRecordings;	/* optional attribute of XSD type xsd:boolean */
	bool *DynamicTracks;	/* optional attribute of XSD type xsd:boolean */
	std::string *Encoding;	/* optional attribute of XSD type trc:EncodingTypes */
	float *MaxRate;	/* optional attribute of XSD type xsd:float */
	float *MaxTotalRate;	/* optional attribute of XSD type xsd:float */
	float *MaxRecordings;	/* optional attribute of XSD type xsd:float */
	int *MaxRecordingJobs;	/* optional attribute of XSD type xsd:int */
	bool *Options;	/* optional attribute of XSD type xsd:boolean */
	bool *MetadataRecording;	/* optional attribute of XSD type xsd:boolean */
	std::string *SupportedExportFileFormats;	/* optional attribute of XSD type tt:StringAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__Capabilities (1304)
	virtual int soap_type(void) const { return 1304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__Capabilities, default initialized and not managed by a soap context
	virtual trc__Capabilities *soap_alloc(void) const { return SOAP_NEW(trc__Capabilities); }
	         trc__Capabilities() { trc__Capabilities::soap_default(NULL); }
	virtual ~trc__Capabilities() { }
	friend trc__Capabilities *soap_instantiate_trc__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3636 */
#ifndef SOAP_TYPE_trc__RecordingOptions
#define SOAP_TYPE_trc__RecordingOptions (1305)
/* Type trc__RecordingOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:RecordingOptions complex type: */
class SOAP_CMAC trc__RecordingOptions : public xsd__anyType
{
public:
	trc__JobOptions *Job;	/* required element of XSD type trc:JobOptions */
	trc__TrackOptions *Track;	/* required element of XSD type trc:TrackOptions */
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_trc__RecordingOptions (1305)
	virtual int soap_type(void) const { return 1305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__RecordingOptions, default initialized and not managed by a soap context
	virtual trc__RecordingOptions *soap_alloc(void) const { return SOAP_NEW(trc__RecordingOptions); }
	         trc__RecordingOptions() { trc__RecordingOptions::soap_default(NULL); }
	virtual ~trc__RecordingOptions() { }
	friend trc__RecordingOptions *soap_instantiate_trc__RecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3639 */
#ifndef SOAP_TYPE_trc__JobOptions
#define SOAP_TYPE_trc__JobOptions (1306)
/* Type trc__JobOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:JobOptions simple type: */
class SOAP_CMAC trc__JobOptions : public xsd__anyType
{
public:
	int *Spare;	/* optional attribute of XSD type xsd:int */
	std::string *CompatibleSources;	/* optional attribute of XSD type tt:StringAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__JobOptions (1306)
	virtual int soap_type(void) const { return 1306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__JobOptions, default initialized and not managed by a soap context
	virtual trc__JobOptions *soap_alloc(void) const { return SOAP_NEW(trc__JobOptions); }
	         trc__JobOptions() { trc__JobOptions::soap_default(NULL); }
	virtual ~trc__JobOptions() { }
	friend trc__JobOptions *soap_instantiate_trc__JobOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3642 */
#ifndef SOAP_TYPE_trc__TrackOptions
#define SOAP_TYPE_trc__TrackOptions (1307)
/* Type trc__TrackOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:TrackOptions simple type: */
class SOAP_CMAC trc__TrackOptions : public xsd__anyType
{
public:
	int *SpareTotal;	/* optional attribute of XSD type xsd:int */
	int *SpareVideo;	/* optional attribute of XSD type xsd:int */
	int *SpareAudio;	/* optional attribute of XSD type xsd:int */
	int *SpareMetadata;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__TrackOptions (1307)
	virtual int soap_type(void) const { return 1307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__TrackOptions, default initialized and not managed by a soap context
	virtual trc__TrackOptions *soap_alloc(void) const { return SOAP_NEW(trc__TrackOptions); }
	         trc__TrackOptions() { trc__TrackOptions::soap_default(NULL); }
	virtual ~trc__TrackOptions() { }
	friend trc__TrackOptions *soap_instantiate_trc__TrackOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3645 */
#ifndef SOAP_TYPE__trc__GetServiceCapabilities
#define SOAP_TYPE__trc__GetServiceCapabilities (1308)
/* trc:GetServiceCapabilities complex type: */
class SOAP_CMAC _trc__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetServiceCapabilities (1308)
	virtual int soap_type(void) const { return 1308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trc__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trc__GetServiceCapabilities); }
	         _trc__GetServiceCapabilities() { _trc__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trc__GetServiceCapabilities() { }
	friend _trc__GetServiceCapabilities *soap_instantiate__trc__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3648 */
#ifndef SOAP_TYPE__trc__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trc__GetServiceCapabilitiesResponse (1309)
/* trc:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trc__GetServiceCapabilitiesResponse
{
public:
	trc__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trc:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetServiceCapabilitiesResponse (1309)
	virtual int soap_type(void) const { return 1309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trc__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetServiceCapabilitiesResponse); }
	         _trc__GetServiceCapabilitiesResponse() { _trc__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trc__GetServiceCapabilitiesResponse() { }
	friend _trc__GetServiceCapabilitiesResponse *soap_instantiate__trc__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3651 */
#ifndef SOAP_TYPE__trc__CreateRecording
#define SOAP_TYPE__trc__CreateRecording (1310)
/* trc:CreateRecording complex type: */
class SOAP_CMAC _trc__CreateRecording
{
public:
	tt__RecordingConfiguration *RecordingConfiguration;	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecording (1310)
	virtual int soap_type(void) const { return 1310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecording, default initialized and not managed by a soap context
	virtual _trc__CreateRecording *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecording); }
	         _trc__CreateRecording() { _trc__CreateRecording::soap_default(NULL); }
	virtual ~_trc__CreateRecording() { }
	friend _trc__CreateRecording *soap_instantiate__trc__CreateRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3654 */
#ifndef SOAP_TYPE__trc__CreateRecordingResponse
#define SOAP_TYPE__trc__CreateRecordingResponse (1311)
/* trc:CreateRecordingResponse complex type: */
class SOAP_CMAC _trc__CreateRecordingResponse
{
public:
	std::string RecordingToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingResponse (1311)
	virtual int soap_type(void) const { return 1311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingResponse, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingResponse); }
	         _trc__CreateRecordingResponse() { _trc__CreateRecordingResponse::soap_default(NULL); }
	virtual ~_trc__CreateRecordingResponse() { }
	friend _trc__CreateRecordingResponse *soap_instantiate__trc__CreateRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3657 */
#ifndef SOAP_TYPE__trc__DeleteRecording
#define SOAP_TYPE__trc__DeleteRecording (1312)
/* trc:DeleteRecording complex type: */
class SOAP_CMAC _trc__DeleteRecording
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecording (1312)
	virtual int soap_type(void) const { return 1312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecording, default initialized and not managed by a soap context
	virtual _trc__DeleteRecording *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecording); }
	         _trc__DeleteRecording() { _trc__DeleteRecording::soap_default(NULL); }
	virtual ~_trc__DeleteRecording() { }
	friend _trc__DeleteRecording *soap_instantiate__trc__DeleteRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3660 */
#ifndef SOAP_TYPE__trc__DeleteRecordingResponse
#define SOAP_TYPE__trc__DeleteRecordingResponse (1313)
/* trc:DeleteRecordingResponse complex type: */
class SOAP_CMAC _trc__DeleteRecordingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingResponse (1313)
	virtual int soap_type(void) const { return 1313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingResponse); }
	         _trc__DeleteRecordingResponse() { _trc__DeleteRecordingResponse::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingResponse() { }
	friend _trc__DeleteRecordingResponse *soap_instantiate__trc__DeleteRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3663 */
#ifndef SOAP_TYPE__trc__GetRecordings
#define SOAP_TYPE__trc__GetRecordings (1314)
/* trc:GetRecordings complex type: */
class SOAP_CMAC _trc__GetRecordings
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordings (1314)
	virtual int soap_type(void) const { return 1314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordings, default initialized and not managed by a soap context
	virtual _trc__GetRecordings *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordings); }
	         _trc__GetRecordings() { _trc__GetRecordings::soap_default(NULL); }
	virtual ~_trc__GetRecordings() { }
	friend _trc__GetRecordings *soap_instantiate__trc__GetRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3666 */
#ifndef SOAP_TYPE__trc__GetRecordingsResponse
#define SOAP_TYPE__trc__GetRecordingsResponse (1315)
/* trc:GetRecordingsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingsResponse
{
public:
	std::vector<tt__GetRecordingsResponseItem *> RecordingItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:GetRecordingsResponseItem */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingsResponse (1315)
	virtual int soap_type(void) const { return 1315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingsResponse); }
	         _trc__GetRecordingsResponse() { _trc__GetRecordingsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingsResponse() { }
	friend _trc__GetRecordingsResponse *soap_instantiate__trc__GetRecordingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3669 */
#ifndef SOAP_TYPE__trc__SetRecordingConfiguration
#define SOAP_TYPE__trc__SetRecordingConfiguration (1316)
/* trc:SetRecordingConfiguration complex type: */
class SOAP_CMAC _trc__SetRecordingConfiguration
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *RecordingConfiguration;	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingConfiguration (1316)
	virtual int soap_type(void) const { return 1316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetRecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingConfiguration); }
	         _trc__SetRecordingConfiguration() { _trc__SetRecordingConfiguration::soap_default(NULL); }
	virtual ~_trc__SetRecordingConfiguration() { }
	friend _trc__SetRecordingConfiguration *soap_instantiate__trc__SetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3672 */
#ifndef SOAP_TYPE__trc__SetRecordingConfigurationResponse
#define SOAP_TYPE__trc__SetRecordingConfigurationResponse (1317)
/* trc:SetRecordingConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetRecordingConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingConfigurationResponse (1317)
	virtual int soap_type(void) const { return 1317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingConfigurationResponse); }
	         _trc__SetRecordingConfigurationResponse() { _trc__SetRecordingConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingConfigurationResponse() { }
	friend _trc__SetRecordingConfigurationResponse *soap_instantiate__trc__SetRecordingConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3675 */
#ifndef SOAP_TYPE__trc__GetRecordingConfiguration
#define SOAP_TYPE__trc__GetRecordingConfiguration (1318)
/* trc:GetRecordingConfiguration complex type: */
class SOAP_CMAC _trc__GetRecordingConfiguration
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingConfiguration (1318)
	virtual int soap_type(void) const { return 1318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetRecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingConfiguration); }
	         _trc__GetRecordingConfiguration() { _trc__GetRecordingConfiguration::soap_default(NULL); }
	virtual ~_trc__GetRecordingConfiguration() { }
	friend _trc__GetRecordingConfiguration *soap_instantiate__trc__GetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3678 */
#ifndef SOAP_TYPE__trc__GetRecordingConfigurationResponse
#define SOAP_TYPE__trc__GetRecordingConfigurationResponse (1319)
/* trc:GetRecordingConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetRecordingConfigurationResponse
{
public:
	tt__RecordingConfiguration *RecordingConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingConfigurationResponse (1319)
	virtual int soap_type(void) const { return 1319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingConfigurationResponse); }
	         _trc__GetRecordingConfigurationResponse() { _trc__GetRecordingConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingConfigurationResponse() { }
	friend _trc__GetRecordingConfigurationResponse *soap_instantiate__trc__GetRecordingConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3681 */
#ifndef SOAP_TYPE__trc__CreateTrack
#define SOAP_TYPE__trc__CreateTrack (1320)
/* trc:CreateTrack complex type: */
class SOAP_CMAC _trc__CreateTrack
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__TrackConfiguration *TrackConfiguration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateTrack (1320)
	virtual int soap_type(void) const { return 1320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateTrack, default initialized and not managed by a soap context
	virtual _trc__CreateTrack *soap_alloc(void) const { return SOAP_NEW(_trc__CreateTrack); }
	         _trc__CreateTrack() { _trc__CreateTrack::soap_default(NULL); }
	virtual ~_trc__CreateTrack() { }
	friend _trc__CreateTrack *soap_instantiate__trc__CreateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3684 */
#ifndef SOAP_TYPE__trc__CreateTrackResponse
#define SOAP_TYPE__trc__CreateTrackResponse (1321)
/* trc:CreateTrackResponse complex type: */
class SOAP_CMAC _trc__CreateTrackResponse
{
public:
	std::string TrackToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateTrackResponse (1321)
	virtual int soap_type(void) const { return 1321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateTrackResponse, default initialized and not managed by a soap context
	virtual _trc__CreateTrackResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateTrackResponse); }
	         _trc__CreateTrackResponse() { _trc__CreateTrackResponse::soap_default(NULL); }
	virtual ~_trc__CreateTrackResponse() { }
	friend _trc__CreateTrackResponse *soap_instantiate__trc__CreateTrackResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3687 */
#ifndef SOAP_TYPE__trc__DeleteTrack
#define SOAP_TYPE__trc__DeleteTrack (1322)
/* trc:DeleteTrack complex type: */
class SOAP_CMAC _trc__DeleteTrack
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteTrack (1322)
	virtual int soap_type(void) const { return 1322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteTrack, default initialized and not managed by a soap context
	virtual _trc__DeleteTrack *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteTrack); }
	         _trc__DeleteTrack() { _trc__DeleteTrack::soap_default(NULL); }
	virtual ~_trc__DeleteTrack() { }
	friend _trc__DeleteTrack *soap_instantiate__trc__DeleteTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3690 */
#ifndef SOAP_TYPE__trc__DeleteTrackResponse
#define SOAP_TYPE__trc__DeleteTrackResponse (1323)
/* trc:DeleteTrackResponse complex type: */
class SOAP_CMAC _trc__DeleteTrackResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteTrackResponse (1323)
	virtual int soap_type(void) const { return 1323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteTrackResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteTrackResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteTrackResponse); }
	         _trc__DeleteTrackResponse() { _trc__DeleteTrackResponse::soap_default(NULL); }
	virtual ~_trc__DeleteTrackResponse() { }
	friend _trc__DeleteTrackResponse *soap_instantiate__trc__DeleteTrackResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3693 */
#ifndef SOAP_TYPE__trc__GetTrackConfiguration
#define SOAP_TYPE__trc__GetTrackConfiguration (1324)
/* trc:GetTrackConfiguration complex type: */
class SOAP_CMAC _trc__GetTrackConfiguration
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetTrackConfiguration (1324)
	virtual int soap_type(void) const { return 1324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetTrackConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetTrackConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetTrackConfiguration); }
	         _trc__GetTrackConfiguration() { _trc__GetTrackConfiguration::soap_default(NULL); }
	virtual ~_trc__GetTrackConfiguration() { }
	friend _trc__GetTrackConfiguration *soap_instantiate__trc__GetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3696 */
#ifndef SOAP_TYPE__trc__GetTrackConfigurationResponse
#define SOAP_TYPE__trc__GetTrackConfigurationResponse (1325)
/* trc:GetTrackConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetTrackConfigurationResponse
{
public:
	tt__TrackConfiguration *TrackConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetTrackConfigurationResponse (1325)
	virtual int soap_type(void) const { return 1325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetTrackConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetTrackConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetTrackConfigurationResponse); }
	         _trc__GetTrackConfigurationResponse() { _trc__GetTrackConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetTrackConfigurationResponse() { }
	friend _trc__GetTrackConfigurationResponse *soap_instantiate__trc__GetTrackConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3699 */
#ifndef SOAP_TYPE__trc__SetTrackConfiguration
#define SOAP_TYPE__trc__SetTrackConfiguration (1326)
/* trc:SetTrackConfiguration complex type: */
class SOAP_CMAC _trc__SetTrackConfiguration
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *TrackConfiguration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetTrackConfiguration (1326)
	virtual int soap_type(void) const { return 1326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetTrackConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetTrackConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetTrackConfiguration); }
	         _trc__SetTrackConfiguration() { _trc__SetTrackConfiguration::soap_default(NULL); }
	virtual ~_trc__SetTrackConfiguration() { }
	friend _trc__SetTrackConfiguration *soap_instantiate__trc__SetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3702 */
#ifndef SOAP_TYPE__trc__SetTrackConfigurationResponse
#define SOAP_TYPE__trc__SetTrackConfigurationResponse (1327)
/* trc:SetTrackConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetTrackConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetTrackConfigurationResponse (1327)
	virtual int soap_type(void) const { return 1327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetTrackConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetTrackConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetTrackConfigurationResponse); }
	         _trc__SetTrackConfigurationResponse() { _trc__SetTrackConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetTrackConfigurationResponse() { }
	friend _trc__SetTrackConfigurationResponse *soap_instantiate__trc__SetTrackConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3705 */
#ifndef SOAP_TYPE__trc__CreateRecordingJob
#define SOAP_TYPE__trc__CreateRecordingJob (1328)
/* trc:CreateRecordingJob complex type: */
class SOAP_CMAC _trc__CreateRecordingJob
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingJob (1328)
	virtual int soap_type(void) const { return 1328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingJob, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingJob *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingJob); }
	         _trc__CreateRecordingJob() { _trc__CreateRecordingJob::soap_default(NULL); }
	virtual ~_trc__CreateRecordingJob() { }
	friend _trc__CreateRecordingJob *soap_instantiate__trc__CreateRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3708 */
#ifndef SOAP_TYPE__trc__CreateRecordingJobResponse
#define SOAP_TYPE__trc__CreateRecordingJobResponse (1329)
/* trc:CreateRecordingJobResponse complex type: */
class SOAP_CMAC _trc__CreateRecordingJobResponse
{
public:
	std::string JobToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingJobResponse (1329)
	virtual int soap_type(void) const { return 1329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingJobResponse, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingJobResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingJobResponse); }
	         _trc__CreateRecordingJobResponse() { _trc__CreateRecordingJobResponse::soap_default(NULL); }
	virtual ~_trc__CreateRecordingJobResponse() { }
	friend _trc__CreateRecordingJobResponse *soap_instantiate__trc__CreateRecordingJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3711 */
#ifndef SOAP_TYPE__trc__DeleteRecordingJob
#define SOAP_TYPE__trc__DeleteRecordingJob (1330)
/* trc:DeleteRecordingJob complex type: */
class SOAP_CMAC _trc__DeleteRecordingJob
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingJob (1330)
	virtual int soap_type(void) const { return 1330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingJob, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingJob *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingJob); }
	         _trc__DeleteRecordingJob() { _trc__DeleteRecordingJob::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingJob() { }
	friend _trc__DeleteRecordingJob *soap_instantiate__trc__DeleteRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3714 */
#ifndef SOAP_TYPE__trc__DeleteRecordingJobResponse
#define SOAP_TYPE__trc__DeleteRecordingJobResponse (1331)
/* trc:DeleteRecordingJobResponse complex type: */
class SOAP_CMAC _trc__DeleteRecordingJobResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingJobResponse (1331)
	virtual int soap_type(void) const { return 1331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingJobResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingJobResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingJobResponse); }
	         _trc__DeleteRecordingJobResponse() { _trc__DeleteRecordingJobResponse::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingJobResponse() { }
	friend _trc__DeleteRecordingJobResponse *soap_instantiate__trc__DeleteRecordingJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3717 */
#ifndef SOAP_TYPE__trc__GetRecordingJobs
#define SOAP_TYPE__trc__GetRecordingJobs (1332)
/* trc:GetRecordingJobs complex type: */
class SOAP_CMAC _trc__GetRecordingJobs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobs (1332)
	virtual int soap_type(void) const { return 1332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobs, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobs *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobs); }
	         _trc__GetRecordingJobs() { _trc__GetRecordingJobs::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobs() { }
	friend _trc__GetRecordingJobs *soap_instantiate__trc__GetRecordingJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3720 */
#ifndef SOAP_TYPE__trc__GetRecordingJobsResponse
#define SOAP_TYPE__trc__GetRecordingJobsResponse (1333)
/* trc:GetRecordingJobsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobsResponse
{
public:
	std::vector<tt__GetRecordingJobsResponseItem *> JobItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:GetRecordingJobsResponseItem */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobsResponse (1333)
	virtual int soap_type(void) const { return 1333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobsResponse); }
	         _trc__GetRecordingJobsResponse() { _trc__GetRecordingJobsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobsResponse() { }
	friend _trc__GetRecordingJobsResponse *soap_instantiate__trc__GetRecordingJobsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3723 */
#ifndef SOAP_TYPE__trc__SetRecordingJobConfiguration
#define SOAP_TYPE__trc__SetRecordingJobConfiguration (1334)
/* trc:SetRecordingJobConfiguration complex type: */
class SOAP_CMAC _trc__SetRecordingJobConfiguration
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobConfiguration (1334)
	virtual int soap_type(void) const { return 1334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobConfiguration); }
	         _trc__SetRecordingJobConfiguration() { _trc__SetRecordingJobConfiguration::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobConfiguration() { }
	friend _trc__SetRecordingJobConfiguration *soap_instantiate__trc__SetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3726 */
#ifndef SOAP_TYPE__trc__SetRecordingJobConfigurationResponse
#define SOAP_TYPE__trc__SetRecordingJobConfigurationResponse (1335)
/* trc:SetRecordingJobConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetRecordingJobConfigurationResponse
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobConfigurationResponse (1335)
	virtual int soap_type(void) const { return 1335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobConfigurationResponse); }
	         _trc__SetRecordingJobConfigurationResponse() { _trc__SetRecordingJobConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobConfigurationResponse() { }
	friend _trc__SetRecordingJobConfigurationResponse *soap_instantiate__trc__SetRecordingJobConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3729 */
#ifndef SOAP_TYPE__trc__GetRecordingJobConfiguration
#define SOAP_TYPE__trc__GetRecordingJobConfiguration (1336)
/* trc:GetRecordingJobConfiguration complex type: */
class SOAP_CMAC _trc__GetRecordingJobConfiguration
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobConfiguration (1336)
	virtual int soap_type(void) const { return 1336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobConfiguration); }
	         _trc__GetRecordingJobConfiguration() { _trc__GetRecordingJobConfiguration::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobConfiguration() { }
	friend _trc__GetRecordingJobConfiguration *soap_instantiate__trc__GetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3732 */
#ifndef SOAP_TYPE__trc__GetRecordingJobConfigurationResponse
#define SOAP_TYPE__trc__GetRecordingJobConfigurationResponse (1337)
/* trc:GetRecordingJobConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobConfigurationResponse
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobConfigurationResponse (1337)
	virtual int soap_type(void) const { return 1337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobConfigurationResponse); }
	         _trc__GetRecordingJobConfigurationResponse() { _trc__GetRecordingJobConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobConfigurationResponse() { }
	friend _trc__GetRecordingJobConfigurationResponse *soap_instantiate__trc__GetRecordingJobConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3735 */
#ifndef SOAP_TYPE__trc__SetRecordingJobMode
#define SOAP_TYPE__trc__SetRecordingJobMode (1338)
/* trc:SetRecordingJobMode complex type: */
class SOAP_CMAC _trc__SetRecordingJobMode
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	std::string Mode;	/* required element of XSD type tt:RecordingJobMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobMode (1338)
	virtual int soap_type(void) const { return 1338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobMode, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobMode *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobMode); }
	         _trc__SetRecordingJobMode() { _trc__SetRecordingJobMode::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobMode() { }
	friend _trc__SetRecordingJobMode *soap_instantiate__trc__SetRecordingJobMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3738 */
#ifndef SOAP_TYPE__trc__SetRecordingJobModeResponse
#define SOAP_TYPE__trc__SetRecordingJobModeResponse (1339)
/* trc:SetRecordingJobModeResponse complex type: */
class SOAP_CMAC _trc__SetRecordingJobModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobModeResponse (1339)
	virtual int soap_type(void) const { return 1339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobModeResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobModeResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobModeResponse); }
	         _trc__SetRecordingJobModeResponse() { _trc__SetRecordingJobModeResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobModeResponse() { }
	friend _trc__SetRecordingJobModeResponse *soap_instantiate__trc__SetRecordingJobModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3741 */
#ifndef SOAP_TYPE__trc__GetRecordingJobState
#define SOAP_TYPE__trc__GetRecordingJobState (1340)
/* trc:GetRecordingJobState complex type: */
class SOAP_CMAC _trc__GetRecordingJobState
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobState (1340)
	virtual int soap_type(void) const { return 1340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobState, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobState *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobState); }
	         _trc__GetRecordingJobState() { _trc__GetRecordingJobState::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobState() { }
	friend _trc__GetRecordingJobState *soap_instantiate__trc__GetRecordingJobState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3744 */
#ifndef SOAP_TYPE__trc__GetRecordingJobStateResponse
#define SOAP_TYPE__trc__GetRecordingJobStateResponse (1341)
/* trc:GetRecordingJobStateResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobStateResponse
{
public:
	tt__RecordingJobStateInformation *State;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobStateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobStateResponse (1341)
	virtual int soap_type(void) const { return 1341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobStateResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobStateResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobStateResponse); }
	         _trc__GetRecordingJobStateResponse() { _trc__GetRecordingJobStateResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobStateResponse() { }
	friend _trc__GetRecordingJobStateResponse *soap_instantiate__trc__GetRecordingJobStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3747 */
#ifndef SOAP_TYPE__trc__GetRecordingOptions
#define SOAP_TYPE__trc__GetRecordingOptions (1342)
/* trc:GetRecordingOptions complex type: */
class SOAP_CMAC _trc__GetRecordingOptions
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingOptions (1342)
	virtual int soap_type(void) const { return 1342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingOptions, default initialized and not managed by a soap context
	virtual _trc__GetRecordingOptions *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingOptions); }
	         _trc__GetRecordingOptions() { _trc__GetRecordingOptions::soap_default(NULL); }
	virtual ~_trc__GetRecordingOptions() { }
	friend _trc__GetRecordingOptions *soap_instantiate__trc__GetRecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3750 */
#ifndef SOAP_TYPE__trc__GetRecordingOptionsResponse
#define SOAP_TYPE__trc__GetRecordingOptionsResponse (1343)
/* trc:GetRecordingOptionsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingOptionsResponse
{
public:
	trc__RecordingOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trc:RecordingOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingOptionsResponse (1343)
	virtual int soap_type(void) const { return 1343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingOptionsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingOptionsResponse); }
	         _trc__GetRecordingOptionsResponse() { _trc__GetRecordingOptionsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingOptionsResponse() { }
	friend _trc__GetRecordingOptionsResponse *soap_instantiate__trc__GetRecordingOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3753 */
#ifndef SOAP_TYPE__trc__ExportRecordedData
#define SOAP_TYPE__trc__ExportRecordedData (1344)
/* trc:ExportRecordedData complex type: */
class SOAP_CMAC _trc__ExportRecordedData
{
public:
	tt__SearchScope *SearchScope;	/* required element of XSD type tt:SearchScope */
	std::string FileFormat;	/* required element of XSD type xsd:string */
	tt__StorageReferencePath *StorageDestination;	/* required element of XSD type tt:StorageReferencePath */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__ExportRecordedData (1344)
	virtual int soap_type(void) const { return 1344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__ExportRecordedData, default initialized and not managed by a soap context
	virtual _trc__ExportRecordedData *soap_alloc(void) const { return SOAP_NEW(_trc__ExportRecordedData); }
	         _trc__ExportRecordedData() { _trc__ExportRecordedData::soap_default(NULL); }
	virtual ~_trc__ExportRecordedData() { }
	friend _trc__ExportRecordedData *soap_instantiate__trc__ExportRecordedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36790 */
#ifndef SOAP_TYPE__trc__ExportRecordedDataResponse_Extension
#define SOAP_TYPE__trc__ExportRecordedDataResponse_Extension (2265)
/* trc:ExportRecordedDataResponse-Extension complex type: */
class SOAP_CMAC _trc__ExportRecordedDataResponse_Extension
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__trc__ExportRecordedDataResponse_Extension (2265)
	virtual int soap_type(void) const { return 2265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__ExportRecordedDataResponse_Extension, default initialized and not managed by a soap context
	virtual _trc__ExportRecordedDataResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_trc__ExportRecordedDataResponse_Extension); }
	         _trc__ExportRecordedDataResponse_Extension() { _trc__ExportRecordedDataResponse_Extension::soap_default(NULL); }
	virtual ~_trc__ExportRecordedDataResponse_Extension() { }
	friend _trc__ExportRecordedDataResponse_Extension *soap_instantiate__trc__ExportRecordedDataResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3756 */
#ifndef SOAP_TYPE__trc__ExportRecordedDataResponse
#define SOAP_TYPE__trc__ExportRecordedDataResponse (1345)
/* trc:ExportRecordedDataResponse complex type: */
class SOAP_CMAC _trc__ExportRecordedDataResponse
{
public:
	std::string OperationToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> FileNames;	/* optional element of XSD type xsd:string */
	_trc__ExportRecordedDataResponse_Extension *Extension;	/* optional element of XSD type trc:ExportRecordedDataResponse-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__ExportRecordedDataResponse (1345)
	virtual int soap_type(void) const { return 1345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__ExportRecordedDataResponse, default initialized and not managed by a soap context
	virtual _trc__ExportRecordedDataResponse *soap_alloc(void) const { return SOAP_NEW(_trc__ExportRecordedDataResponse); }
	         _trc__ExportRecordedDataResponse() { _trc__ExportRecordedDataResponse::soap_default(NULL); }
	virtual ~_trc__ExportRecordedDataResponse() { }
	friend _trc__ExportRecordedDataResponse *soap_instantiate__trc__ExportRecordedDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3759 */
#ifndef SOAP_TYPE__trc__StopExportRecordedData
#define SOAP_TYPE__trc__StopExportRecordedData (1346)
/* trc:StopExportRecordedData complex type: */
class SOAP_CMAC _trc__StopExportRecordedData
{
public:
	std::string OperationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__StopExportRecordedData (1346)
	virtual int soap_type(void) const { return 1346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__StopExportRecordedData, default initialized and not managed by a soap context
	virtual _trc__StopExportRecordedData *soap_alloc(void) const { return SOAP_NEW(_trc__StopExportRecordedData); }
	         _trc__StopExportRecordedData() { _trc__StopExportRecordedData::soap_default(NULL); }
	virtual ~_trc__StopExportRecordedData() { }
	friend _trc__StopExportRecordedData *soap_instantiate__trc__StopExportRecordedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3762 */
#ifndef SOAP_TYPE__trc__StopExportRecordedDataResponse
#define SOAP_TYPE__trc__StopExportRecordedDataResponse (1347)
/* trc:StopExportRecordedDataResponse complex type: */
class SOAP_CMAC _trc__StopExportRecordedDataResponse
{
public:
	float Progress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:float */
	tt__ArrayOfFileProgress *FileProgressStatus;	/* required element of XSD type tt:ArrayOfFileProgress */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__StopExportRecordedDataResponse (1347)
	virtual int soap_type(void) const { return 1347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__StopExportRecordedDataResponse, default initialized and not managed by a soap context
	virtual _trc__StopExportRecordedDataResponse *soap_alloc(void) const { return SOAP_NEW(_trc__StopExportRecordedDataResponse); }
	         _trc__StopExportRecordedDataResponse() { _trc__StopExportRecordedDataResponse::soap_default(NULL); }
	virtual ~_trc__StopExportRecordedDataResponse() { }
	friend _trc__StopExportRecordedDataResponse *soap_instantiate__trc__StopExportRecordedDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3765 */
#ifndef SOAP_TYPE__trc__GetExportRecordedDataState
#define SOAP_TYPE__trc__GetExportRecordedDataState (1348)
/* trc:GetExportRecordedDataState complex type: */
class SOAP_CMAC _trc__GetExportRecordedDataState
{
public:
	std::string OperationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetExportRecordedDataState (1348)
	virtual int soap_type(void) const { return 1348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetExportRecordedDataState, default initialized and not managed by a soap context
	virtual _trc__GetExportRecordedDataState *soap_alloc(void) const { return SOAP_NEW(_trc__GetExportRecordedDataState); }
	         _trc__GetExportRecordedDataState() { _trc__GetExportRecordedDataState::soap_default(NULL); }
	virtual ~_trc__GetExportRecordedDataState() { }
	friend _trc__GetExportRecordedDataState *soap_instantiate__trc__GetExportRecordedDataState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3768 */
#ifndef SOAP_TYPE__trc__GetExportRecordedDataStateResponse
#define SOAP_TYPE__trc__GetExportRecordedDataStateResponse (1349)
/* trc:GetExportRecordedDataStateResponse complex type: */
class SOAP_CMAC _trc__GetExportRecordedDataStateResponse
{
public:
	float Progress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:float */
	tt__ArrayOfFileProgress *FileProgressStatus;	/* required element of XSD type tt:ArrayOfFileProgress */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetExportRecordedDataStateResponse (1349)
	virtual int soap_type(void) const { return 1349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetExportRecordedDataStateResponse, default initialized and not managed by a soap context
	virtual _trc__GetExportRecordedDataStateResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetExportRecordedDataStateResponse); }
	         _trc__GetExportRecordedDataStateResponse() { _trc__GetExportRecordedDataStateResponse::soap_default(NULL); }
	virtual ~_trc__GetExportRecordedDataStateResponse() { }
	friend _trc__GetExportRecordedDataStateResponse *soap_instantiate__trc__GetExportRecordedDataStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3771 */
#ifndef SOAP_TYPE_tse__Capabilities
#define SOAP_TYPE_tse__Capabilities (1350)
/* Type tse__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tse:Capabilities complex type: */
class SOAP_CMAC tse__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool *MetadataSearch;	/* optional attribute of XSD type xsd:boolean */
	bool *GeneralStartEvents;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tse__Capabilities (1350)
	virtual int soap_type(void) const { return 1350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tse__Capabilities, default initialized and not managed by a soap context
	virtual tse__Capabilities *soap_alloc(void) const { return SOAP_NEW(tse__Capabilities); }
	         tse__Capabilities() { tse__Capabilities::soap_default(NULL); }
	virtual ~tse__Capabilities() { }
	friend tse__Capabilities *soap_instantiate_tse__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3774 */
#ifndef SOAP_TYPE__tse__GetServiceCapabilities
#define SOAP_TYPE__tse__GetServiceCapabilities (1351)
/* tse:GetServiceCapabilities complex type: */
class SOAP_CMAC _tse__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetServiceCapabilities (1351)
	virtual int soap_type(void) const { return 1351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tse__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tse__GetServiceCapabilities); }
	         _tse__GetServiceCapabilities() { _tse__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tse__GetServiceCapabilities() { }
	friend _tse__GetServiceCapabilities *soap_instantiate__tse__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3777 */
#ifndef SOAP_TYPE__tse__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tse__GetServiceCapabilitiesResponse (1352)
/* tse:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tse__GetServiceCapabilitiesResponse
{
public:
	tse__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tse:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetServiceCapabilitiesResponse (1352)
	virtual int soap_type(void) const { return 1352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tse__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetServiceCapabilitiesResponse); }
	         _tse__GetServiceCapabilitiesResponse() { _tse__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tse__GetServiceCapabilitiesResponse() { }
	friend _tse__GetServiceCapabilitiesResponse *soap_instantiate__tse__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3780 */
#ifndef SOAP_TYPE__tse__GetRecordingSummary
#define SOAP_TYPE__tse__GetRecordingSummary (1353)
/* tse:GetRecordingSummary complex type: */
class SOAP_CMAC _tse__GetRecordingSummary
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSummary (1353)
	virtual int soap_type(void) const { return 1353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSummary, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSummary *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSummary); }
	         _tse__GetRecordingSummary() { _tse__GetRecordingSummary::soap_default(NULL); }
	virtual ~_tse__GetRecordingSummary() { }
	friend _tse__GetRecordingSummary *soap_instantiate__tse__GetRecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3783 */
#ifndef SOAP_TYPE__tse__GetRecordingSummaryResponse
#define SOAP_TYPE__tse__GetRecordingSummaryResponse (1354)
/* tse:GetRecordingSummaryResponse complex type: */
class SOAP_CMAC _tse__GetRecordingSummaryResponse
{
public:
	tt__RecordingSummary *Summary;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingSummary */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSummaryResponse (1354)
	virtual int soap_type(void) const { return 1354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSummaryResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSummaryResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSummaryResponse); }
	         _tse__GetRecordingSummaryResponse() { _tse__GetRecordingSummaryResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingSummaryResponse() { }
	friend _tse__GetRecordingSummaryResponse *soap_instantiate__tse__GetRecordingSummaryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3786 */
#ifndef SOAP_TYPE__tse__GetRecordingInformation
#define SOAP_TYPE__tse__GetRecordingInformation (1355)
/* tse:GetRecordingInformation complex type: */
class SOAP_CMAC _tse__GetRecordingInformation
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingInformation (1355)
	virtual int soap_type(void) const { return 1355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingInformation, default initialized and not managed by a soap context
	virtual _tse__GetRecordingInformation *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingInformation); }
	         _tse__GetRecordingInformation() { _tse__GetRecordingInformation::soap_default(NULL); }
	virtual ~_tse__GetRecordingInformation() { }
	friend _tse__GetRecordingInformation *soap_instantiate__tse__GetRecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3789 */
#ifndef SOAP_TYPE__tse__GetRecordingInformationResponse
#define SOAP_TYPE__tse__GetRecordingInformationResponse (1356)
/* tse:GetRecordingInformationResponse complex type: */
class SOAP_CMAC _tse__GetRecordingInformationResponse
{
public:
	tt__RecordingInformation *RecordingInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingInformationResponse (1356)
	virtual int soap_type(void) const { return 1356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingInformationResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingInformationResponse); }
	         _tse__GetRecordingInformationResponse() { _tse__GetRecordingInformationResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingInformationResponse() { }
	friend _tse__GetRecordingInformationResponse *soap_instantiate__tse__GetRecordingInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3792 */
#ifndef SOAP_TYPE__tse__GetMediaAttributes
#define SOAP_TYPE__tse__GetMediaAttributes (1357)
/* tse:GetMediaAttributes complex type: */
class SOAP_CMAC _tse__GetMediaAttributes
{
public:
	std::vector<std::string> RecordingTokens;	/* optional element of XSD type tt:RecordingReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMediaAttributes (1357)
	virtual int soap_type(void) const { return 1357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMediaAttributes, default initialized and not managed by a soap context
	virtual _tse__GetMediaAttributes *soap_alloc(void) const { return SOAP_NEW(_tse__GetMediaAttributes); }
	         _tse__GetMediaAttributes() { _tse__GetMediaAttributes::soap_default(NULL); }
	virtual ~_tse__GetMediaAttributes() { }
	friend _tse__GetMediaAttributes *soap_instantiate__tse__GetMediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3795 */
#ifndef SOAP_TYPE__tse__GetMediaAttributesResponse
#define SOAP_TYPE__tse__GetMediaAttributesResponse (1358)
/* tse:GetMediaAttributesResponse complex type: */
class SOAP_CMAC _tse__GetMediaAttributesResponse
{
public:
	std::vector<tt__MediaAttributes *> MediaAttributes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:MediaAttributes */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMediaAttributesResponse (1358)
	virtual int soap_type(void) const { return 1358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMediaAttributesResponse, default initialized and not managed by a soap context
	virtual _tse__GetMediaAttributesResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetMediaAttributesResponse); }
	         _tse__GetMediaAttributesResponse() { _tse__GetMediaAttributesResponse::soap_default(NULL); }
	virtual ~_tse__GetMediaAttributesResponse() { }
	friend _tse__GetMediaAttributesResponse *soap_instantiate__tse__GetMediaAttributesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3798 */
#ifndef SOAP_TYPE__tse__FindRecordings
#define SOAP_TYPE__tse__FindRecordings (1359)
/* tse:FindRecordings complex type: */
class SOAP_CMAC _tse__FindRecordings
{
public:
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindRecordings (1359)
	virtual int soap_type(void) const { return 1359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindRecordings, default initialized and not managed by a soap context
	virtual _tse__FindRecordings *soap_alloc(void) const { return SOAP_NEW(_tse__FindRecordings); }
	         _tse__FindRecordings() { _tse__FindRecordings::soap_default(NULL); }
	virtual ~_tse__FindRecordings() { }
	friend _tse__FindRecordings *soap_instantiate__tse__FindRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3801 */
#ifndef SOAP_TYPE__tse__FindRecordingsResponse
#define SOAP_TYPE__tse__FindRecordingsResponse (1360)
/* tse:FindRecordingsResponse complex type: */
class SOAP_CMAC _tse__FindRecordingsResponse
{
public:
	std::string SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindRecordingsResponse (1360)
	virtual int soap_type(void) const { return 1360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindRecordingsResponse, default initialized and not managed by a soap context
	virtual _tse__FindRecordingsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindRecordingsResponse); }
	         _tse__FindRecordingsResponse() { _tse__FindRecordingsResponse::soap_default(NULL); }
	virtual ~_tse__FindRecordingsResponse() { }
	friend _tse__FindRecordingsResponse *soap_instantiate__tse__FindRecordingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3804 */
#ifndef SOAP_TYPE__tse__GetRecordingSearchResults
#define SOAP_TYPE__tse__GetRecordingSearchResults (1361)
/* tse:GetRecordingSearchResults complex type: */
class SOAP_CMAC _tse__GetRecordingSearchResults
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSearchResults (1361)
	virtual int soap_type(void) const { return 1361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSearchResults); }
	         _tse__GetRecordingSearchResults() { _tse__GetRecordingSearchResults::soap_default(NULL); }
	virtual ~_tse__GetRecordingSearchResults() { }
	friend _tse__GetRecordingSearchResults *soap_instantiate__tse__GetRecordingSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3807 */
#ifndef SOAP_TYPE__tse__GetRecordingSearchResultsResponse
#define SOAP_TYPE__tse__GetRecordingSearchResultsResponse (1362)
/* tse:GetRecordingSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetRecordingSearchResultsResponse
{
public:
	tt__FindRecordingResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindRecordingResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSearchResultsResponse (1362)
	virtual int soap_type(void) const { return 1362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSearchResultsResponse); }
	         _tse__GetRecordingSearchResultsResponse() { _tse__GetRecordingSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingSearchResultsResponse() { }
	friend _tse__GetRecordingSearchResultsResponse *soap_instantiate__tse__GetRecordingSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3810 */
#ifndef SOAP_TYPE__tse__FindEvents
#define SOAP_TYPE__tse__FindEvents (1363)
/* tse:FindEvents complex type: */
class SOAP_CMAC _tse__FindEvents
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__EventFilter *SearchFilter;	/* required element of XSD type tt:EventFilter */
	bool IncludeStartState;	/* required element of XSD type xsd:boolean */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindEvents (1363)
	virtual int soap_type(void) const { return 1363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindEvents, default initialized and not managed by a soap context
	virtual _tse__FindEvents *soap_alloc(void) const { return SOAP_NEW(_tse__FindEvents); }
	         _tse__FindEvents() { _tse__FindEvents::soap_default(NULL); }
	virtual ~_tse__FindEvents() { }
	friend _tse__FindEvents *soap_instantiate__tse__FindEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3813 */
#ifndef SOAP_TYPE__tse__FindEventsResponse
#define SOAP_TYPE__tse__FindEventsResponse (1364)
/* tse:FindEventsResponse complex type: */
class SOAP_CMAC _tse__FindEventsResponse
{
public:
	std::string SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindEventsResponse (1364)
	virtual int soap_type(void) const { return 1364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindEventsResponse, default initialized and not managed by a soap context
	virtual _tse__FindEventsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindEventsResponse); }
	         _tse__FindEventsResponse() { _tse__FindEventsResponse::soap_default(NULL); }
	virtual ~_tse__FindEventsResponse() { }
	friend _tse__FindEventsResponse *soap_instantiate__tse__FindEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3816 */
#ifndef SOAP_TYPE__tse__GetEventSearchResults
#define SOAP_TYPE__tse__GetEventSearchResults (1365)
/* tse:GetEventSearchResults complex type: */
class SOAP_CMAC _tse__GetEventSearchResults
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetEventSearchResults (1365)
	virtual int soap_type(void) const { return 1365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetEventSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetEventSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetEventSearchResults); }
	         _tse__GetEventSearchResults() { _tse__GetEventSearchResults::soap_default(NULL); }
	virtual ~_tse__GetEventSearchResults() { }
	friend _tse__GetEventSearchResults *soap_instantiate__tse__GetEventSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3819 */
#ifndef SOAP_TYPE__tse__GetEventSearchResultsResponse
#define SOAP_TYPE__tse__GetEventSearchResultsResponse (1366)
/* tse:GetEventSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetEventSearchResultsResponse
{
public:
	tt__FindEventResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindEventResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetEventSearchResultsResponse (1366)
	virtual int soap_type(void) const { return 1366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetEventSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetEventSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetEventSearchResultsResponse); }
	         _tse__GetEventSearchResultsResponse() { _tse__GetEventSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetEventSearchResultsResponse() { }
	friend _tse__GetEventSearchResultsResponse *soap_instantiate__tse__GetEventSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3822 */
#ifndef SOAP_TYPE__tse__FindPTZPosition
#define SOAP_TYPE__tse__FindPTZPosition (1367)
/* tse:FindPTZPosition complex type: */
class SOAP_CMAC _tse__FindPTZPosition
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__PTZPositionFilter *SearchFilter;	/* required element of XSD type tt:PTZPositionFilter */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindPTZPosition (1367)
	virtual int soap_type(void) const { return 1367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindPTZPosition, default initialized and not managed by a soap context
	virtual _tse__FindPTZPosition *soap_alloc(void) const { return SOAP_NEW(_tse__FindPTZPosition); }
	         _tse__FindPTZPosition() { _tse__FindPTZPosition::soap_default(NULL); }
	virtual ~_tse__FindPTZPosition() { }
	friend _tse__FindPTZPosition *soap_instantiate__tse__FindPTZPosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3825 */
#ifndef SOAP_TYPE__tse__FindPTZPositionResponse
#define SOAP_TYPE__tse__FindPTZPositionResponse (1368)
/* tse:FindPTZPositionResponse complex type: */
class SOAP_CMAC _tse__FindPTZPositionResponse
{
public:
	std::string SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindPTZPositionResponse (1368)
	virtual int soap_type(void) const { return 1368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindPTZPositionResponse, default initialized and not managed by a soap context
	virtual _tse__FindPTZPositionResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindPTZPositionResponse); }
	         _tse__FindPTZPositionResponse() { _tse__FindPTZPositionResponse::soap_default(NULL); }
	virtual ~_tse__FindPTZPositionResponse() { }
	friend _tse__FindPTZPositionResponse *soap_instantiate__tse__FindPTZPositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3828 */
#ifndef SOAP_TYPE__tse__GetPTZPositionSearchResults
#define SOAP_TYPE__tse__GetPTZPositionSearchResults (1369)
/* tse:GetPTZPositionSearchResults complex type: */
class SOAP_CMAC _tse__GetPTZPositionSearchResults
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetPTZPositionSearchResults (1369)
	virtual int soap_type(void) const { return 1369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetPTZPositionSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetPTZPositionSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetPTZPositionSearchResults); }
	         _tse__GetPTZPositionSearchResults() { _tse__GetPTZPositionSearchResults::soap_default(NULL); }
	virtual ~_tse__GetPTZPositionSearchResults() { }
	friend _tse__GetPTZPositionSearchResults *soap_instantiate__tse__GetPTZPositionSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3831 */
#ifndef SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse
#define SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse (1370)
/* tse:GetPTZPositionSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetPTZPositionSearchResultsResponse
{
public:
	tt__FindPTZPositionResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindPTZPositionResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse (1370)
	virtual int soap_type(void) const { return 1370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetPTZPositionSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetPTZPositionSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetPTZPositionSearchResultsResponse); }
	         _tse__GetPTZPositionSearchResultsResponse() { _tse__GetPTZPositionSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetPTZPositionSearchResultsResponse() { }
	friend _tse__GetPTZPositionSearchResultsResponse *soap_instantiate__tse__GetPTZPositionSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3834 */
#ifndef SOAP_TYPE__tse__FindMetadata
#define SOAP_TYPE__tse__FindMetadata (1371)
/* tse:FindMetadata complex type: */
class SOAP_CMAC _tse__FindMetadata
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__MetadataFilter *MetadataFilter;	/* required element of XSD type tt:MetadataFilter */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindMetadata (1371)
	virtual int soap_type(void) const { return 1371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindMetadata, default initialized and not managed by a soap context
	virtual _tse__FindMetadata *soap_alloc(void) const { return SOAP_NEW(_tse__FindMetadata); }
	         _tse__FindMetadata() { _tse__FindMetadata::soap_default(NULL); }
	virtual ~_tse__FindMetadata() { }
	friend _tse__FindMetadata *soap_instantiate__tse__FindMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3837 */
#ifndef SOAP_TYPE__tse__FindMetadataResponse
#define SOAP_TYPE__tse__FindMetadataResponse (1372)
/* tse:FindMetadataResponse complex type: */
class SOAP_CMAC _tse__FindMetadataResponse
{
public:
	std::string SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindMetadataResponse (1372)
	virtual int soap_type(void) const { return 1372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindMetadataResponse, default initialized and not managed by a soap context
	virtual _tse__FindMetadataResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindMetadataResponse); }
	         _tse__FindMetadataResponse() { _tse__FindMetadataResponse::soap_default(NULL); }
	virtual ~_tse__FindMetadataResponse() { }
	friend _tse__FindMetadataResponse *soap_instantiate__tse__FindMetadataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3840 */
#ifndef SOAP_TYPE__tse__GetMetadataSearchResults
#define SOAP_TYPE__tse__GetMetadataSearchResults (1373)
/* tse:GetMetadataSearchResults complex type: */
class SOAP_CMAC _tse__GetMetadataSearchResults
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMetadataSearchResults (1373)
	virtual int soap_type(void) const { return 1373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMetadataSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetMetadataSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetMetadataSearchResults); }
	         _tse__GetMetadataSearchResults() { _tse__GetMetadataSearchResults::soap_default(NULL); }
	virtual ~_tse__GetMetadataSearchResults() { }
	friend _tse__GetMetadataSearchResults *soap_instantiate__tse__GetMetadataSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3843 */
#ifndef SOAP_TYPE__tse__GetMetadataSearchResultsResponse
#define SOAP_TYPE__tse__GetMetadataSearchResultsResponse (1374)
/* tse:GetMetadataSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetMetadataSearchResultsResponse
{
public:
	tt__FindMetadataResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindMetadataResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMetadataSearchResultsResponse (1374)
	virtual int soap_type(void) const { return 1374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMetadataSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetMetadataSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetMetadataSearchResultsResponse); }
	         _tse__GetMetadataSearchResultsResponse() { _tse__GetMetadataSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetMetadataSearchResultsResponse() { }
	friend _tse__GetMetadataSearchResultsResponse *soap_instantiate__tse__GetMetadataSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3846 */
#ifndef SOAP_TYPE__tse__GetSearchState
#define SOAP_TYPE__tse__GetSearchState (1375)
/* tse:GetSearchState complex type: */
class SOAP_CMAC _tse__GetSearchState
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetSearchState (1375)
	virtual int soap_type(void) const { return 1375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetSearchState, default initialized and not managed by a soap context
	virtual _tse__GetSearchState *soap_alloc(void) const { return SOAP_NEW(_tse__GetSearchState); }
	         _tse__GetSearchState() { _tse__GetSearchState::soap_default(NULL); }
	virtual ~_tse__GetSearchState() { }
	friend _tse__GetSearchState *soap_instantiate__tse__GetSearchState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3849 */
#ifndef SOAP_TYPE__tse__GetSearchStateResponse
#define SOAP_TYPE__tse__GetSearchStateResponse (1376)
/* tse:GetSearchStateResponse complex type: */
class SOAP_CMAC _tse__GetSearchStateResponse
{
public:
	enum tt__SearchState State;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SearchState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetSearchStateResponse (1376)
	virtual int soap_type(void) const { return 1376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetSearchStateResponse, default initialized and not managed by a soap context
	virtual _tse__GetSearchStateResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetSearchStateResponse); }
	         _tse__GetSearchStateResponse() { _tse__GetSearchStateResponse::soap_default(NULL); }
	virtual ~_tse__GetSearchStateResponse() { }
	friend _tse__GetSearchStateResponse *soap_instantiate__tse__GetSearchStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3852 */
#ifndef SOAP_TYPE__tse__EndSearch
#define SOAP_TYPE__tse__EndSearch (1377)
/* tse:EndSearch complex type: */
class SOAP_CMAC _tse__EndSearch
{
public:
	std::string SearchToken;	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__EndSearch (1377)
	virtual int soap_type(void) const { return 1377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__EndSearch, default initialized and not managed by a soap context
	virtual _tse__EndSearch *soap_alloc(void) const { return SOAP_NEW(_tse__EndSearch); }
	         _tse__EndSearch() { _tse__EndSearch::soap_default(NULL); }
	virtual ~_tse__EndSearch() { }
	friend _tse__EndSearch *soap_instantiate__tse__EndSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3855 */
#ifndef SOAP_TYPE__tse__EndSearchResponse
#define SOAP_TYPE__tse__EndSearchResponse (1378)
/* tse:EndSearchResponse complex type: */
class SOAP_CMAC _tse__EndSearchResponse
{
public:
	time_t Endpoint;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__EndSearchResponse (1378)
	virtual int soap_type(void) const { return 1378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__EndSearchResponse, default initialized and not managed by a soap context
	virtual _tse__EndSearchResponse *soap_alloc(void) const { return SOAP_NEW(_tse__EndSearchResponse); }
	         _tse__EndSearchResponse() { _tse__EndSearchResponse::soap_default(NULL); }
	virtual ~_tse__EndSearchResponse() { }
	friend _tse__EndSearchResponse *soap_instantiate__tse__EndSearchResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3858 */
#ifndef SOAP_TYPE_trp__Capabilities
#define SOAP_TYPE_trp__Capabilities (1379)
/* Type trp__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trp:Capabilities complex type: */
class SOAP_CMAC trp__Capabilities : public xsd__anyType
{
public:
	std::vector<char *> __any;
	bool ReversePlayback;	/* optional attribute of XSD type xsd:boolean */
	std::string *SessionTimeoutRange;	/* optional attribute of XSD type tt:FloatAttrList */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trp__Capabilities (1379)
	virtual int soap_type(void) const { return 1379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trp__Capabilities, default initialized and not managed by a soap context
	virtual trp__Capabilities *soap_alloc(void) const { return SOAP_NEW(trp__Capabilities); }
	         trp__Capabilities() { trp__Capabilities::soap_default(NULL); }
	virtual ~trp__Capabilities() { }
	friend trp__Capabilities *soap_instantiate_trp__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3861 */
#ifndef SOAP_TYPE__trp__GetServiceCapabilities
#define SOAP_TYPE__trp__GetServiceCapabilities (1380)
/* trp:GetServiceCapabilities complex type: */
class SOAP_CMAC _trp__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetServiceCapabilities (1380)
	virtual int soap_type(void) const { return 1380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trp__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trp__GetServiceCapabilities); }
	         _trp__GetServiceCapabilities() { _trp__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trp__GetServiceCapabilities() { }
	friend _trp__GetServiceCapabilities *soap_instantiate__trp__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3864 */
#ifndef SOAP_TYPE__trp__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trp__GetServiceCapabilitiesResponse (1381)
/* trp:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trp__GetServiceCapabilitiesResponse
{
public:
	trp__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trp:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetServiceCapabilitiesResponse (1381)
	virtual int soap_type(void) const { return 1381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trp__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetServiceCapabilitiesResponse); }
	         _trp__GetServiceCapabilitiesResponse() { _trp__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trp__GetServiceCapabilitiesResponse() { }
	friend _trp__GetServiceCapabilitiesResponse *soap_instantiate__trp__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3867 */
#ifndef SOAP_TYPE__trp__GetReplayUri
#define SOAP_TYPE__trp__GetReplayUri (1382)
/* trp:GetReplayUri complex type: */
class SOAP_CMAC _trp__GetReplayUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	std::string RecordingToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayUri (1382)
	virtual int soap_type(void) const { return 1382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayUri, default initialized and not managed by a soap context
	virtual _trp__GetReplayUri *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayUri); }
	         _trp__GetReplayUri() { _trp__GetReplayUri::soap_default(NULL); }
	virtual ~_trp__GetReplayUri() { }
	friend _trp__GetReplayUri *soap_instantiate__trp__GetReplayUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3870 */
#ifndef SOAP_TYPE__trp__GetReplayUriResponse
#define SOAP_TYPE__trp__GetReplayUriResponse (1383)
/* trp:GetReplayUriResponse complex type: */
class SOAP_CMAC _trp__GetReplayUriResponse
{
public:
	std::string Uri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayUriResponse (1383)
	virtual int soap_type(void) const { return 1383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayUriResponse, default initialized and not managed by a soap context
	virtual _trp__GetReplayUriResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayUriResponse); }
	         _trp__GetReplayUriResponse() { _trp__GetReplayUriResponse::soap_default(NULL); }
	virtual ~_trp__GetReplayUriResponse() { }
	friend _trp__GetReplayUriResponse *soap_instantiate__trp__GetReplayUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3873 */
#ifndef SOAP_TYPE__trp__SetReplayConfiguration
#define SOAP_TYPE__trp__SetReplayConfiguration (1384)
/* trp:SetReplayConfiguration complex type: */
class SOAP_CMAC _trp__SetReplayConfiguration
{
public:
	tt__ReplayConfiguration *Configuration;	/* required element of XSD type tt:ReplayConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__SetReplayConfiguration (1384)
	virtual int soap_type(void) const { return 1384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__SetReplayConfiguration, default initialized and not managed by a soap context
	virtual _trp__SetReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(_trp__SetReplayConfiguration); }
	         _trp__SetReplayConfiguration() { _trp__SetReplayConfiguration::soap_default(NULL); }
	virtual ~_trp__SetReplayConfiguration() { }
	friend _trp__SetReplayConfiguration *soap_instantiate__trp__SetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3876 */
#ifndef SOAP_TYPE__trp__SetReplayConfigurationResponse
#define SOAP_TYPE__trp__SetReplayConfigurationResponse (1385)
/* trp:SetReplayConfigurationResponse complex type: */
class SOAP_CMAC _trp__SetReplayConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__SetReplayConfigurationResponse (1385)
	virtual int soap_type(void) const { return 1385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__SetReplayConfigurationResponse, default initialized and not managed by a soap context
	virtual _trp__SetReplayConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trp__SetReplayConfigurationResponse); }
	         _trp__SetReplayConfigurationResponse() { _trp__SetReplayConfigurationResponse::soap_default(NULL); }
	virtual ~_trp__SetReplayConfigurationResponse() { }
	friend _trp__SetReplayConfigurationResponse *soap_instantiate__trp__SetReplayConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3879 */
#ifndef SOAP_TYPE__trp__GetReplayConfiguration
#define SOAP_TYPE__trp__GetReplayConfiguration (1386)
/* trp:GetReplayConfiguration complex type: */
class SOAP_CMAC _trp__GetReplayConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayConfiguration (1386)
	virtual int soap_type(void) const { return 1386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayConfiguration, default initialized and not managed by a soap context
	virtual _trp__GetReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayConfiguration); }
	         _trp__GetReplayConfiguration() { _trp__GetReplayConfiguration::soap_default(NULL); }
	virtual ~_trp__GetReplayConfiguration() { }
	friend _trp__GetReplayConfiguration *soap_instantiate__trp__GetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3882 */
#ifndef SOAP_TYPE__trp__GetReplayConfigurationResponse
#define SOAP_TYPE__trp__GetReplayConfigurationResponse (1387)
/* trp:GetReplayConfigurationResponse complex type: */
class SOAP_CMAC _trp__GetReplayConfigurationResponse
{
public:
	tt__ReplayConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReplayConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayConfigurationResponse (1387)
	virtual int soap_type(void) const { return 1387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayConfigurationResponse, default initialized and not managed by a soap context
	virtual _trp__GetReplayConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayConfigurationResponse); }
	         _trp__GetReplayConfigurationResponse() { _trp__GetReplayConfigurationResponse::soap_default(NULL); }
	virtual ~_trp__GetReplayConfigurationResponse() { }
	friend _trp__GetReplayConfigurationResponse *soap_instantiate__trp__GetReplayConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:429 */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (236)
/* Type tds__StorageConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:StorageConfiguration complex type: */
class SOAP_CMAC tds__StorageConfiguration : public tt__DeviceEntity
{
public:
	tds__StorageConfigurationData *Data;	/* required element of XSD type tds:StorageConfigurationData */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfiguration (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfiguration, default initialized and not managed by a soap context
	virtual tds__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfiguration); }
	         tds__StorageConfiguration() { tds__StorageConfiguration::soap_default(NULL); }
	virtual ~tds__StorageConfiguration() { }
	friend tds__StorageConfiguration *soap_instantiate_tds__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:981 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (420)
/* Type tt__VideoSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSource complex type: */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of XSD type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of XSD type tt:VideoSourceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSource (420)
	virtual int soap_type(void) const { return 420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
	virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW(tt__VideoSource); }
	         tt__VideoSource() { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
	friend tt__VideoSource *soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:990 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (423)
/* Type tt__AudioSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSource complex type: */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSource (423)
	virtual int soap_type(void) const { return 423; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
	virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW(tt__AudioSource); }
	         tt__AudioSource() { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
	friend tt__AudioSource *soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1005 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (428)
/* Type tt__VideoSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfiguration complex type: */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of XSD type tt:IntRectangle */
	std::vector<char *> __any;
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfiguration (428)
	virtual int soap_type(void) const { return 428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfiguration); }
	         tt__VideoSourceConfiguration() { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
	friend tt__VideoSourceConfiguration *soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1044 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (441)
/* Type tt__VideoEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfiguration complex type: */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	float Quality;	/* required element of XSD type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of XSD type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of XSD type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of XSD type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfiguration (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfiguration); }
	         tt__VideoEncoderConfiguration() { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
	friend tt__VideoEncoderConfiguration *soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1071 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (450)
/* Type tt__JpegOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions2 complex type: */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions2 (450)
	virtual int soap_type(void) const { return 450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
	virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions2); }
	         tt__JpegOptions2() { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
	friend tt__JpegOptions2 *soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1077 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (452)
/* Type tt__Mpeg4Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options2 complex type: */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options2 (452)
	virtual int soap_type(void) const { return 452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options2); }
	         tt__Mpeg4Options2() { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
	friend tt__Mpeg4Options2 *soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1083 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (454)
/* Type tt__H264Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options2 complex type: */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options2 (454)
	virtual int soap_type(void) const { return 454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
	virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW(tt__H264Options2); }
	         tt__H264Options2() { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
	friend tt__H264Options2 *soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1086 */
#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (455)
/* Type tt__VideoEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoder2Configuration complex type: */
class SOAP_CMAC tt__VideoEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__VideoResolution2 *Resolution;	/* required element of XSD type tt:VideoResolution2 */
	tt__VideoRateControl2 *RateControl;	/* optional element of XSD type tt:VideoRateControl2 */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	float Quality;	/* required element of XSD type xsd:float */
	std::vector<char *> __any;
	int *GovLength;	/* optional attribute of XSD type xsd:int */
	std::string *Profile;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2Configuration (455)
	virtual int soap_type(void) const { return 455; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2Configuration); }
	         tt__VideoEncoder2Configuration() { tt__VideoEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__VideoEncoder2Configuration() { }
	friend tt__VideoEncoder2Configuration *soap_instantiate_tt__VideoEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1098 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (459)
/* Type tt__AudioSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfiguration complex type: */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfiguration (459)
	virtual int soap_type(void) const { return 459; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfiguration); }
	         tt__AudioSourceConfiguration() { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
	friend tt__AudioSourceConfiguration *soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1107 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (462)
/* Type tt__AudioEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfiguration complex type: */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfiguration (462)
	virtual int soap_type(void) const { return 462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfiguration); }
	         tt__AudioEncoderConfiguration() { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
	friend tt__AudioEncoderConfiguration *soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1116 */
#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (465)
/* Type tt__AudioEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoder2Configuration complex type: */
class SOAP_CMAC tt__AudioEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2Configuration (465)
	virtual int soap_type(void) const { return 465; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2Configuration); }
	         tt__AudioEncoder2Configuration() { tt__AudioEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__AudioEncoder2Configuration() { }
	friend tt__AudioEncoder2Configuration *soap_instantiate_tt__AudioEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1122 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (467)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsConfiguration complex type: */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of XSD type tt:RuleEngineConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsConfiguration (467)
	virtual int soap_type(void) const { return 467; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsConfiguration); }
	         tt__VideoAnalyticsConfiguration() { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
	friend tt__VideoAnalyticsConfiguration *soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1125 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (468)
/* Type tt__MetadataConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfiguration complex type: */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of XSD type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of XSD type tt:EventSubscription */
	bool *Analytics;	/* optional element of XSD type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	std::vector<char *> __any;
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of XSD type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationExtension */
	std::string *CompressionType;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfiguration (468)
	virtual int soap_type(void) const { return 468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
	virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfiguration); }
	         tt__MetadataConfiguration() { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
	friend tt__MetadataConfiguration *soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1152 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (477)
/* Type tt__VideoOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutput complex type: */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of XSD type tt:VideoResolution */
	float *RefreshRate;	/* optional element of XSD type xsd:float */
	float *AspectRatio;	/* optional element of XSD type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of XSD type tt:VideoOutputExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutput (477)
	virtual int soap_type(void) const { return 477; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
	virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutput); }
	         tt__VideoOutput() { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
	friend tt__VideoOutput *soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1158 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (479)
/* Type tt__VideoOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfiguration complex type: */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfiguration (479)
	virtual int soap_type(void) const { return 479; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfiguration); }
	         tt__VideoOutputConfiguration() { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
	friend tt__VideoOutputConfiguration *soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1179 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (486)
/* Type tt__AudioOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutput complex type: */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutput (486)
	virtual int soap_type(void) const { return 486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
	virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutput); }
	         tt__AudioOutput() { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
	friend tt__AudioOutput *soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1182 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (487)
/* Type tt__AudioOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfiguration complex type: */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *SendPrimacy;	/* optional element of XSD type xsd:anyURI */
	int OutputLevel;	/* required element of XSD type xsd:int */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfiguration (487)
	virtual int soap_type(void) const { return 487; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfiguration); }
	         tt__AudioOutputConfiguration() { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
	friend tt__AudioOutputConfiguration *soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1188 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (489)
/* Type tt__AudioDecoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfiguration complex type: */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfiguration (489)
	virtual int soap_type(void) const { return 489; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfiguration); }
	         tt__AudioDecoderConfiguration() { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
	friend tt__AudioDecoderConfiguration *soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1221 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (500)
/* Type tt__NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterface complex type: */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of XSD type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of XSD type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterface (500)
	virtual int soap_type(void) const { return 500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
	virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterface); }
	         tt__NetworkInterface() { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
	friend tt__NetworkInterface *soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1533 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (604)
/* Type tt__CertificateUsage is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateUsage simple type: */
class SOAP_CMAC tt__CertificateUsage : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
	bool Critical;	/* required attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateUsage (604)
	virtual int soap_type(void) const { return 604; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
	virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW(tt__CertificateUsage); }
	         tt__CertificateUsage() { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
	friend tt__CertificateUsage *soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1560 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (613)
/* Type tt__RelayOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutput complex type: */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutput (613)
	virtual int soap_type(void) const { return 613; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
	virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutput); }
	         tt__RelayOutput() { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
	friend tt__RelayOutput *soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1563 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (614)
/* Type tt__DigitalInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DigitalInput complex type: */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	std::vector<char *> __any;
	enum tt__DigitalIdleState *IdleState;	/* optional attribute of XSD type tt:DigitalIdleState */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DigitalInput (614)
	virtual int soap_type(void) const { return 614; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
	virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW(tt__DigitalInput); }
	         tt__DigitalInput() { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
	friend tt__DigitalInput *soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1566 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (615)
/* Type tt__PTZNode is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNode complex type: */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of XSD type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of XSD type xsd:int */
	bool HomeSupported;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> AuxiliaryCommands;	/* optional element of XSD type tt:AuxiliaryData */
	tt__PTZNodeExtension *Extension;	/* optional element of XSD type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNode (615)
	virtual int soap_type(void) const { return 615; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
	virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW(tt__PTZNode); }
	         tt__PTZNode() { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
	friend tt__PTZNode *soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1581 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (620)
/* Type tt__PTZConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfiguration complex type: */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	std::string NodeToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *DefaultAbsolutePantTiltPositionSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultAbsoluteZoomPositionSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultRelativePanTiltTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultRelativeZoomTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultContinuousPanTiltVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultContinuousZoomVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of XSD type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of XSD type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of XSD type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension */
	int *MoveRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetTourRamp;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfiguration (620)
	virtual int soap_type(void) const { return 620; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
	virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfiguration); }
	         tt__PTZConfiguration() { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
	friend tt__PTZConfiguration *soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1989 */
#ifndef SOAP_TYPE_tt__Object
#define SOAP_TYPE_tt__Object (756)
/* Type tt__Object is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Object complex type: */
class SOAP_CMAC tt__Object : public tt__ObjectId
{
public:
	tt__Appearance *Appearance;	/* optional element of XSD type tt:Appearance */
	tt__Behaviour *Behaviour;	/* optional element of XSD type tt:Behaviour */
	tt__ObjectExtension *Extension;	/* optional element of XSD type tt:ObjectExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Object (756)
	virtual int soap_type(void) const { return 756; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Object, default initialized and not managed by a soap context
	virtual tt__Object *soap_alloc(void) const { return SOAP_NEW(tt__Object); }
	         tt__Object() { tt__Object::soap_default(NULL); }
	virtual ~tt__Object() { }
	friend tt__Object *soap_instantiate_tt__Object(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2178 */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (819)
/* Type tt__EventFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventFilter complex type: */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventFilter (819)
	virtual int soap_type(void) const { return 819; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventFilter, default initialized and not managed by a soap context
	virtual tt__EventFilter *soap_alloc(void) const { return SOAP_NEW(tt__EventFilter); }
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
	friend tt__EventFilter *soap_instantiate_tt__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2286 */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (855)
/* Type tt__AnalyticsEngine is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngine complex type: */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsDeviceEngineConfiguration */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngine (855)
	virtual int soap_type(void) const { return 855; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngine, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngine); }
	         tt__AnalyticsEngine() { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
	friend tt__AnalyticsEngine *soap_instantiate_tt__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2304 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (861)
/* Type tt__AnalyticsEngineInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInput complex type: */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of XSD type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of XSD type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of XSD type tt:MetadataInput */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInput (861)
	virtual int soap_type(void) const { return 861; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInput, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInput); }
	         tt__AnalyticsEngineInput() { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
	friend tt__AnalyticsEngineInput *soap_instantiate_tt__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2319 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (866)
/* Type tt__AnalyticsEngineControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineControl complex type: */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	std::string EngineToken;	/* required element of XSD type tt:ReferenceToken */
	std::string EngineConfigToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> InputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of XSD type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of XSD type tt:ModeOfOperation */
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineControl (866)
	virtual int soap_type(void) const { return 866; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineControl, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineControl); }
	         tt__AnalyticsEngineControl() { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
	friend tt__AnalyticsEngineControl *soap_instantiate_tt__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2391 */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (890)
/* Type tt__OSDConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfiguration complex type: */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity
{
public:
	tt__OSDReference *VideoSourceConfigurationToken;	/* required element of XSD type tt:OSDReference */
	enum tt__OSDType Type;	/* required element of XSD type tt:OSDType */
	tt__OSDPosConfiguration *Position;	/* required element of XSD type tt:OSDPosConfiguration */
	tt__OSDTextConfiguration *TextString;	/* optional element of XSD type tt:OSDTextConfiguration */
	tt__OSDImgConfiguration *Image;	/* optional element of XSD type tt:OSDImgConfiguration */
	tt__OSDConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfiguration (890)
	virtual int soap_type(void) const { return 890; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfiguration); }
	         tt__OSDConfiguration() { tt__OSDConfiguration::soap_default(NULL); }
	virtual ~tt__OSDConfiguration() { }
	friend tt__OSDConfiguration *soap_instantiate_tt__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2439 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (906)
/* Type wsnt__SubscribeCreationFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscribeCreationFailedFaultType complex type: */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (906)
	virtual int soap_type(void) const { return 906; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscribeCreationFailedFaultType); }
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
	friend wsnt__SubscribeCreationFailedFaultType *soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2442 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (907)
/* Type wsnt__InvalidFilterFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidFilterFaultType complex type: */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnknownFilter;	/* required element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidFilterFaultType (907)
	virtual int soap_type(void) const { return 907; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidFilterFaultType); }
	         wsnt__InvalidFilterFaultType() { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
	friend wsnt__InvalidFilterFaultType *soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2445 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (908)
/* Type wsnt__TopicExpressionDialectUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionDialectUnknownFaultType complex type: */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (908)
	virtual int soap_type(void) const { return 908; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionDialectUnknownFaultType); }
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
	friend wsnt__TopicExpressionDialectUnknownFaultType *soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2448 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (909)
/* Type wsnt__InvalidTopicExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidTopicExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (909)
	virtual int soap_type(void) const { return 909; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidTopicExpressionFaultType); }
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
	friend wsnt__InvalidTopicExpressionFaultType *soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2451 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (910)
/* Type wsnt__TopicNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicNotSupportedFaultType (910)
	virtual int soap_type(void) const { return 910; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicNotSupportedFaultType); }
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
	friend wsnt__TopicNotSupportedFaultType *soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2454 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (911)
/* Type wsnt__MultipleTopicsSpecifiedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:MultipleTopicsSpecifiedFaultType complex type: */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (911)
	virtual int soap_type(void) const { return 911; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
	virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__MultipleTopicsSpecifiedFaultType); }
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
	friend wsnt__MultipleTopicsSpecifiedFaultType *soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2457 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (912)
/* Type wsnt__InvalidProducerPropertiesExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidProducerPropertiesExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (912)
	virtual int soap_type(void) const { return 912; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidProducerPropertiesExpressionFaultType); }
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
	friend wsnt__InvalidProducerPropertiesExpressionFaultType *soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2460 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (913)
/* Type wsnt__InvalidMessageContentExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidMessageContentExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (913)
	virtual int soap_type(void) const { return 913; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidMessageContentExpressionFaultType); }
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
	friend wsnt__InvalidMessageContentExpressionFaultType *soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2463 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (914)
/* Type wsnt__UnrecognizedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnrecognizedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnrecognizedPolicy;	/* optional element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (914)
	virtual int soap_type(void) const { return 914; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnrecognizedPolicyRequestFaultType); }
	         wsnt__UnrecognizedPolicyRequestFaultType() { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
	friend wsnt__UnrecognizedPolicyRequestFaultType *soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2466 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (915)
/* Type wsnt__UnsupportedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnsupportedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnsupportedPolicy;	/* optional element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (915)
	virtual int soap_type(void) const { return 915; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnsupportedPolicyRequestFaultType); }
	         wsnt__UnsupportedPolicyRequestFaultType() { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
	friend wsnt__UnsupportedPolicyRequestFaultType *soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2469 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (916)
/* Type wsnt__NotifyMessageNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotifyMessageNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (916)
	virtual int soap_type(void) const { return 916; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotifyMessageNotSupportedFaultType); }
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
	friend wsnt__NotifyMessageNotSupportedFaultType *soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2472 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (917)
/* Type wsnt__UnacceptableInitialTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableInitialTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (917)
	virtual int soap_type(void) const { return 917; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableInitialTerminationTimeFaultType); }
	         wsnt__UnacceptableInitialTerminationTimeFaultType() { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
	friend wsnt__UnacceptableInitialTerminationTimeFaultType *soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2475 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (918)
/* Type wsnt__NoCurrentMessageOnTopicFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NoCurrentMessageOnTopicFaultType complex type: */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (918)
	virtual int soap_type(void) const { return 918; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
	virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NoCurrentMessageOnTopicFaultType); }
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
	friend wsnt__NoCurrentMessageOnTopicFaultType *soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2478 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (919)
/* Type wsnt__UnableToGetMessagesFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToGetMessagesFaultType complex type: */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (919)
	virtual int soap_type(void) const { return 919; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToGetMessagesFaultType); }
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
	friend wsnt__UnableToGetMessagesFaultType *soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2481 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (920)
/* Type wsnt__UnableToDestroyPullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroyPullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (920)
	virtual int soap_type(void) const { return 920; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroyPullPointFaultType); }
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
	friend wsnt__UnableToDestroyPullPointFaultType *soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2484 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (921)
/* Type wsnt__UnableToCreatePullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToCreatePullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (921)
	virtual int soap_type(void) const { return 921; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToCreatePullPointFaultType); }
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
	friend wsnt__UnableToCreatePullPointFaultType *soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2487 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (922)
/* Type wsnt__UnacceptableTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (922)
	virtual int soap_type(void) const { return 922; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableTerminationTimeFaultType); }
	         wsnt__UnacceptableTerminationTimeFaultType() { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
	friend wsnt__UnacceptableTerminationTimeFaultType *soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2490 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (923)
/* Type wsnt__UnableToDestroySubscriptionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroySubscriptionFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (923)
	virtual int soap_type(void) const { return 923; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroySubscriptionFaultType); }
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
	friend wsnt__UnableToDestroySubscriptionFaultType *soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2493 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (924)
/* Type wsnt__PauseFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:PauseFailedFaultType complex type: */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__PauseFailedFaultType (924)
	virtual int soap_type(void) const { return 924; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__PauseFailedFaultType); }
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
	friend wsnt__PauseFailedFaultType *soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2496 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (925)
/* Type wsnt__ResumeFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:ResumeFailedFaultType complex type: */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__ResumeFailedFaultType (925)
	virtual int soap_type(void) const { return 925; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__ResumeFailedFaultType); }
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
	friend wsnt__ResumeFailedFaultType *soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41611 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (2318)
/* wstop:TopicNamespaceType-Topic complex type: */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	std::vector<wstop__TopicType *> Topic;	/* optional element of XSD type wstop:TopicType */
	std::vector<char *> __any;
	std::string name;	/* required attribute of XSD type xsd:NCName */
	std::string *messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
	std::string *parent;	/* optional attribute of XSD type wstop:ConcreteTopicExpression */
public:
	/// Return the unique type ID value SOAP_TYPE__wstop__TopicNamespaceType_Topic (2318)
	virtual int soap_type(void) const { return 2318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
	virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_wstop__TopicNamespaceType_Topic); }
	         _wstop__TopicNamespaceType_Topic() { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
	friend _wstop__TopicNamespaceType_Topic *soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2577 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (952)
/* Type wstop__TopicNamespaceType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicNamespaceType complex type: */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	std::vector<_wstop__TopicNamespaceType_Topic> *Topic;	/* optional element of XSD type wstop:TopicNamespaceType-Topic */
	std::vector<char *> __any;
	std::string *name;	/* optional attribute of XSD type xsd:NCName */
	std::string targetNamespace;	/* required attribute of XSD type xsd:anyURI */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicNamespaceType (952)
	virtual int soap_type(void) const { return 952; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
	virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicNamespaceType); }
	         wstop__TopicNamespaceType() { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
	friend wstop__TopicNamespaceType *soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2580 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (953)
/* Type wstop__TopicType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicType complex type: */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	std::vector<wstop__TopicType *> Topic;	/* optional element of XSD type wstop:TopicType */
	std::vector<char *> __any;
	std::string name;	/* required attribute of XSD type xsd:NCName */
	std::string *messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicType (953)
	virtual int soap_type(void) const { return 953; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
	virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicType); }
	         wstop__TopicType() { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
	friend wstop__TopicType *soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2583 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (954)
/* Type wstop__TopicSetType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicSetType complex type: */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	std::vector<char *> __any;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicSetType (954)
	virtual int soap_type(void) const { return 954; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
	virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicSetType); }
	         wstop__TopicSetType() { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
	friend wstop__TopicSetType *soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2631 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (970)
/* Type wsrfr__ResourceUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfr:ResourceUnknownFaultType complex type: */
class SOAP_CMAC wsrfr__ResourceUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfr__ResourceUnknownFaultType (970)
	virtual int soap_type(void) const { return 970; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfr__ResourceUnknownFaultType, default initialized and not managed by a soap context
	virtual wsrfr__ResourceUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfr__ResourceUnknownFaultType); }
	         wsrfr__ResourceUnknownFaultType() { wsrfr__ResourceUnknownFaultType::soap_default(NULL); }
	virtual ~wsrfr__ResourceUnknownFaultType() { }
	friend wsrfr__ResourceUnknownFaultType *soap_instantiate_wsrfr__ResourceUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2634 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (971)
/* Type wsrfr__ResourceUnavailableFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfr:ResourceUnavailableFaultType complex type: */
class SOAP_CMAC wsrfr__ResourceUnavailableFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (971)
	virtual int soap_type(void) const { return 971; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfr__ResourceUnavailableFaultType, default initialized and not managed by a soap context
	virtual wsrfr__ResourceUnavailableFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfr__ResourceUnavailableFaultType); }
	         wsrfr__ResourceUnavailableFaultType() { wsrfr__ResourceUnavailableFaultType::soap_default(NULL); }
	virtual ~wsrfr__ResourceUnavailableFaultType() { }
	friend wsrfr__ResourceUnavailableFaultType *soap_instantiate_wsrfr__ResourceUnavailableFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2721 */
#ifndef SOAP_TYPE_tmd__SerialPort
#define SOAP_TYPE_tmd__SerialPort (1000)
/* Type tmd__SerialPort is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPort complex type: */
class SOAP_CMAC tmd__SerialPort : public tt__DeviceEntity
{
public:
	std::vector<char *> __any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPort (1000)
	virtual int soap_type(void) const { return 1000; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPort, default initialized and not managed by a soap context
	virtual tmd__SerialPort *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPort); }
	         tmd__SerialPort() { tmd__SerialPort::soap_default(NULL); }
	virtual ~tmd__SerialPort() { }
	friend tmd__SerialPort *soap_instantiate_tmd__SerialPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2343 */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (874)
/* Type tt__OSDReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDReference simple type: */
class SOAP_CMAC tt__OSDReference : public xsd__anyType
{
public:
	std::string __item;	/* mixed XML content */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDReference (874)
	virtual int soap_type(void) const { return 874; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDReference, default initialized and not managed by a soap context
	virtual tt__OSDReference *soap_alloc(void) const { return SOAP_NEW(tt__OSDReference); }
	         tt__OSDReference() { tt__OSDReference::soap_default(NULL); }
	virtual ~tt__OSDReference() { }
	friend tt__OSDReference *soap_instantiate_tt__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:281 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (138)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	wsnt__InvalidFilterFaultType *wsnt__InvalidFilterFault;	/* optional element of XSD type wsnt:InvalidFilterFaultType */
	wsnt__InvalidMessageContentExpressionFaultType *wsnt__InvalidMessageContentExpressionFault;	/* optional element of XSD type wsnt:InvalidMessageContentExpressionFaultType */
	wsnt__InvalidProducerPropertiesExpressionFaultType *wsnt__InvalidProducerPropertiesExpressionFault;	/* optional element of XSD type wsnt:InvalidProducerPropertiesExpressionFaultType */
	wsnt__InvalidTopicExpressionFaultType *wsnt__InvalidTopicExpressionFault;	/* optional element of XSD type wsnt:InvalidTopicExpressionFaultType */
	wsnt__MultipleTopicsSpecifiedFaultType *wsnt__MultipleTopicsSpecifiedFault;	/* optional element of XSD type wsnt:MultipleTopicsSpecifiedFaultType */
	wsnt__NoCurrentMessageOnTopicFaultType *wsnt__NoCurrentMessageOnTopicFault;	/* optional element of XSD type wsnt:NoCurrentMessageOnTopicFaultType */
	wsnt__NotifyMessageNotSupportedFaultType *wsnt__NotifyMessageNotSupportedFault;	/* optional element of XSD type wsnt:NotifyMessageNotSupportedFaultType */
	wsnt__PauseFailedFaultType *wsnt__PauseFailedFault;	/* optional element of XSD type wsnt:PauseFailedFaultType */
	_tev__PullMessagesFaultResponse *tev__PullMessagesFaultResponse;	/* optional element of XSD type tev:PullMessagesFaultResponse */
	wsrfr__ResourceUnknownFaultType *wsrfr__ResourceUnknownFault;	/* optional element of XSD type wsrfr:ResourceUnknownFaultType */
	wsnt__ResumeFailedFaultType *wsnt__ResumeFailedFault;	/* optional element of XSD type wsnt:ResumeFailedFaultType */
	wsnt__SubscribeCreationFailedFaultType *wsnt__SubscribeCreationFailedFault;	/* optional element of XSD type wsnt:SubscribeCreationFailedFaultType */
	wsnt__TopicExpressionDialectUnknownFaultType *wsnt__TopicExpressionDialectUnknownFault;	/* optional element of XSD type wsnt:TopicExpressionDialectUnknownFaultType */
	wsnt__TopicNotSupportedFaultType *wsnt__TopicNotSupportedFault;	/* optional element of XSD type wsnt:TopicNotSupportedFaultType */
	wsnt__UnableToCreatePullPointFaultType *wsnt__UnableToCreatePullPointFault;	/* optional element of XSD type wsnt:UnableToCreatePullPointFaultType */
	wsnt__UnableToDestroyPullPointFaultType *wsnt__UnableToDestroyPullPointFault;	/* optional element of XSD type wsnt:UnableToDestroyPullPointFaultType */
	wsnt__UnableToDestroySubscriptionFaultType *wsnt__UnableToDestroySubscriptionFault;	/* optional element of XSD type wsnt:UnableToDestroySubscriptionFaultType */
	wsnt__UnableToGetMessagesFaultType *wsnt__UnableToGetMessagesFault;	/* optional element of XSD type wsnt:UnableToGetMessagesFaultType */
	wsnt__UnacceptableInitialTerminationTimeFaultType *wsnt__UnacceptableInitialTerminationTimeFault;	/* optional element of XSD type wsnt:UnacceptableInitialTerminationTimeFaultType */
	wsnt__UnacceptableTerminationTimeFaultType *wsnt__UnacceptableTerminationTimeFault;	/* optional element of XSD type wsnt:UnacceptableTerminationTimeFaultType */
	wsnt__UnrecognizedPolicyRequestFaultType *wsnt__UnrecognizedPolicyRequestFault;	/* optional element of XSD type wsnt:UnrecognizedPolicyRequestFaultType */
	wsnt__UnsupportedPolicyRequestFaultType *wsnt__UnsupportedPolicyRequestFault;	/* optional element of XSD type wsnt:UnsupportedPolicyRequestFaultType */
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
	char *__any;
public:
	int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
	friend SOAP_ENV__Detail *soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvif.h:43718 */
#ifndef SOAP_TYPE___tdn__Hello
#define SOAP_TYPE___tdn__Hello (2352)
/* Operation wrapper: */
struct __tdn__Hello
{
public:
	struct wsdd__HelloType tdn__Hello;	/* required element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 2352; } /* = unique type id SOAP_TYPE___tdn__Hello */
	         __tdn__Hello();
	virtual ~__tdn__Hello() { }
	friend __tdn__Hello *soap_instantiate___tdn__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43784 */
#ifndef SOAP_TYPE___tdn__Bye
#define SOAP_TYPE___tdn__Bye (2354)
/* Operation wrapper: */
struct __tdn__Bye
{
public:
	struct wsdd__ByeType tdn__Bye;	/* required element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 2354; } /* = unique type id SOAP_TYPE___tdn__Bye */
	         __tdn__Bye();
	virtual ~__tdn__Bye() { }
	friend __tdn__Bye *soap_instantiate___tdn__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43850 */
#ifndef SOAP_TYPE___tdn__Probe
#define SOAP_TYPE___tdn__Probe (2357)
/* Operation wrapper: */
struct __tdn__Probe
{
public:
	struct wsdd__ProbeType tdn__Probe;	/* required element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 2357; } /* = unique type id SOAP_TYPE___tdn__Probe */
	         __tdn__Probe();
	virtual ~__tdn__Probe() { }
	friend __tdn__Probe *soap_instantiate___tdn__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43935 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (2361)
/* Operation wrapper: */
struct __tds__GetServices
{
public:
	_tds__GetServices *tds__GetServices;	/* optional element of XSD type tds:GetServices */
public:
	int soap_type() const { return 2361; } /* = unique type id SOAP_TYPE___tds__GetServices */
	         __tds__GetServices();
	virtual ~__tds__GetServices() { }
	friend __tds__GetServices *soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44003 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (2365)
/* Operation wrapper: */
struct __tds__GetServiceCapabilities
{
public:
	_tds__GetServiceCapabilities *tds__GetServiceCapabilities;	/* optional element of XSD type tds:GetServiceCapabilities */
public:
	int soap_type() const { return 2365; } /* = unique type id SOAP_TYPE___tds__GetServiceCapabilities */
	         __tds__GetServiceCapabilities();
	virtual ~__tds__GetServiceCapabilities() { }
	friend __tds__GetServiceCapabilities *soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44070 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (2369)
/* Operation wrapper: */
struct __tds__GetDeviceInformation
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of XSD type tds:GetDeviceInformation */
public:
	int soap_type() const { return 2369; } /* = unique type id SOAP_TYPE___tds__GetDeviceInformation */
	         __tds__GetDeviceInformation();
	virtual ~__tds__GetDeviceInformation() { }
	friend __tds__GetDeviceInformation *soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44151 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (2373)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of XSD type tds:SetSystemDateAndTime */
public:
	int soap_type() const { return 2373; } /* = unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
	         __tds__SetSystemDateAndTime();
	virtual ~__tds__SetSystemDateAndTime() { }
	friend __tds__SetSystemDateAndTime *soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44224 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (2377)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of XSD type tds:GetSystemDateAndTime */
public:
	int soap_type() const { return 2377; } /* = unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
	         __tds__GetSystemDateAndTime();
	virtual ~__tds__GetSystemDateAndTime() { }
	friend __tds__GetSystemDateAndTime *soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44291 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (2381)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of XSD type tds:SetSystemFactoryDefault */
public:
	int soap_type() const { return 2381; } /* = unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
	         __tds__SetSystemFactoryDefault();
	virtual ~__tds__SetSystemFactoryDefault() { }
	friend __tds__SetSystemFactoryDefault *soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44364 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (2385)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of XSD type tds:UpgradeSystemFirmware */
public:
	int soap_type() const { return 2385; } /* = unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
	         __tds__UpgradeSystemFirmware();
	virtual ~__tds__UpgradeSystemFirmware() { }
	friend __tds__UpgradeSystemFirmware *soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44431 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (2389)
/* Operation wrapper: */
struct __tds__SystemReboot
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of XSD type tds:SystemReboot */
public:
	int soap_type() const { return 2389; } /* = unique type id SOAP_TYPE___tds__SystemReboot */
	         __tds__SystemReboot();
	virtual ~__tds__SystemReboot() { }
	friend __tds__SystemReboot *soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44506 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (2393)
/* Operation wrapper: */
struct __tds__RestoreSystem
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of XSD type tds:RestoreSystem */
public:
	int soap_type() const { return 2393; } /* = unique type id SOAP_TYPE___tds__RestoreSystem */
	         __tds__RestoreSystem();
	virtual ~__tds__RestoreSystem() { }
	friend __tds__RestoreSystem *soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44580 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (2397)
/* Operation wrapper: */
struct __tds__GetSystemBackup
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of XSD type tds:GetSystemBackup */
public:
	int soap_type() const { return 2397; } /* = unique type id SOAP_TYPE___tds__GetSystemBackup */
	         __tds__GetSystemBackup();
	virtual ~__tds__GetSystemBackup() { }
	friend __tds__GetSystemBackup *soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44648 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (2401)
/* Operation wrapper: */
struct __tds__GetSystemLog
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of XSD type tds:GetSystemLog */
public:
	int soap_type() const { return 2401; } /* = unique type id SOAP_TYPE___tds__GetSystemLog */
	         __tds__GetSystemLog();
	virtual ~__tds__GetSystemLog() { }
	friend __tds__GetSystemLog *soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44715 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (2405)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of XSD type tds:GetSystemSupportInformation */
public:
	int soap_type() const { return 2405; } /* = unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
	         __tds__GetSystemSupportInformation();
	virtual ~__tds__GetSystemSupportInformation() { }
	friend __tds__GetSystemSupportInformation *soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44797 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (2409)
/* Operation wrapper: */
struct __tds__GetScopes
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of XSD type tds:GetScopes */
public:
	int soap_type() const { return 2409; } /* = unique type id SOAP_TYPE___tds__GetScopes */
	         __tds__GetScopes();
	virtual ~__tds__GetScopes() { }
	friend __tds__GetScopes *soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44872 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (2413)
/* Operation wrapper: */
struct __tds__SetScopes
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of XSD type tds:SetScopes */
public:
	int soap_type() const { return 2413; } /* = unique type id SOAP_TYPE___tds__SetScopes */
	         __tds__SetScopes();
	virtual ~__tds__SetScopes() { }
	friend __tds__SetScopes *soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44943 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (2417)
/* Operation wrapper: */
struct __tds__AddScopes
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of XSD type tds:AddScopes */
public:
	int soap_type() const { return 2417; } /* = unique type id SOAP_TYPE___tds__AddScopes */
	         __tds__AddScopes();
	virtual ~__tds__AddScopes() { }
	friend __tds__AddScopes *soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45016 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (2421)
/* Operation wrapper: */
struct __tds__RemoveScopes
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of XSD type tds:RemoveScopes */
public:
	int soap_type() const { return 2421; } /* = unique type id SOAP_TYPE___tds__RemoveScopes */
	         __tds__RemoveScopes();
	virtual ~__tds__RemoveScopes() { }
	friend __tds__RemoveScopes *soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45087 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (2425)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of XSD type tds:GetDiscoveryMode */
public:
	int soap_type() const { return 2425; } /* = unique type id SOAP_TYPE___tds__GetDiscoveryMode */
	         __tds__GetDiscoveryMode();
	virtual ~__tds__GetDiscoveryMode() { }
	friend __tds__GetDiscoveryMode *soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45159 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (2429)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of XSD type tds:SetDiscoveryMode */
public:
	int soap_type() const { return 2429; } /* = unique type id SOAP_TYPE___tds__SetDiscoveryMode */
	         __tds__SetDiscoveryMode();
	virtual ~__tds__SetDiscoveryMode() { }
	friend __tds__SetDiscoveryMode *soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45232 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (2433)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of XSD type tds:GetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2433; } /* = unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
	         __tds__GetRemoteDiscoveryMode();
	virtual ~__tds__GetRemoteDiscoveryMode() { }
	friend __tds__GetRemoteDiscoveryMode *soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45305 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (2437)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of XSD type tds:SetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2437; } /* = unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
	         __tds__SetRemoteDiscoveryMode();
	virtual ~__tds__SetRemoteDiscoveryMode() { }
	friend __tds__SetRemoteDiscoveryMode *soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45376 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (2441)
/* Operation wrapper: */
struct __tds__GetDPAddresses
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of XSD type tds:GetDPAddresses */
public:
	int soap_type() const { return 2441; } /* = unique type id SOAP_TYPE___tds__GetDPAddresses */
	         __tds__GetDPAddresses();
	virtual ~__tds__GetDPAddresses() { }
	friend __tds__GetDPAddresses *soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45449 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (2445)
/* Operation wrapper: */
struct __tds__GetEndpointReference
{
public:
	_tds__GetEndpointReference *tds__GetEndpointReference;	/* optional element of XSD type tds:GetEndpointReference */
public:
	int soap_type() const { return 2445; } /* = unique type id SOAP_TYPE___tds__GetEndpointReference */
	         __tds__GetEndpointReference();
	virtual ~__tds__GetEndpointReference() { }
	friend __tds__GetEndpointReference *soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45522 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (2449)
/* Operation wrapper: */
struct __tds__GetRemoteUser
{
public:
	_tds__GetRemoteUser *tds__GetRemoteUser;	/* optional element of XSD type tds:GetRemoteUser */
public:
	int soap_type() const { return 2449; } /* = unique type id SOAP_TYPE___tds__GetRemoteUser */
	         __tds__GetRemoteUser();
	virtual ~__tds__GetRemoteUser() { }
	friend __tds__GetRemoteUser *soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45600 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (2453)
/* Operation wrapper: */
struct __tds__SetRemoteUser
{
public:
	_tds__SetRemoteUser *tds__SetRemoteUser;	/* optional element of XSD type tds:SetRemoteUser */
public:
	int soap_type() const { return 2453; } /* = unique type id SOAP_TYPE___tds__SetRemoteUser */
	         __tds__SetRemoteUser();
	virtual ~__tds__SetRemoteUser() { }
	friend __tds__SetRemoteUser *soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45671 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (2457)
/* Operation wrapper: */
struct __tds__GetUsers
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of XSD type tds:GetUsers */
public:
	int soap_type() const { return 2457; } /* = unique type id SOAP_TYPE___tds__GetUsers */
	         __tds__GetUsers();
	virtual ~__tds__GetUsers() { }
	friend __tds__GetUsers *soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45750 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (2461)
/* Operation wrapper: */
struct __tds__CreateUsers
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of XSD type tds:CreateUsers */
public:
	int soap_type() const { return 2461; } /* = unique type id SOAP_TYPE___tds__CreateUsers */
	         __tds__CreateUsers();
	virtual ~__tds__CreateUsers() { }
	friend __tds__CreateUsers *soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45824 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (2465)
/* Operation wrapper: */
struct __tds__DeleteUsers
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of XSD type tds:DeleteUsers */
public:
	int soap_type() const { return 2465; } /* = unique type id SOAP_TYPE___tds__DeleteUsers */
	         __tds__DeleteUsers();
	virtual ~__tds__DeleteUsers() { }
	friend __tds__DeleteUsers *soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45896 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (2469)
/* Operation wrapper: */
struct __tds__SetUser
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of XSD type tds:SetUser */
public:
	int soap_type() const { return 2469; } /* = unique type id SOAP_TYPE___tds__SetUser */
	         __tds__SetUser();
	virtual ~__tds__SetUser() { }
	friend __tds__SetUser *soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45970 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (2473)
/* Operation wrapper: */
struct __tds__GetWsdlUrl
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of XSD type tds:GetWsdlUrl */
public:
	int soap_type() const { return 2473; } /* = unique type id SOAP_TYPE___tds__GetWsdlUrl */
	         __tds__GetWsdlUrl();
	virtual ~__tds__GetWsdlUrl() { }
	friend __tds__GetWsdlUrl *soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46046 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (2477)
/* Operation wrapper: */
struct __tds__GetCapabilities
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of XSD type tds:GetCapabilities */
public:
	int soap_type() const { return 2477; } /* = unique type id SOAP_TYPE___tds__GetCapabilities */
	         __tds__GetCapabilities();
	virtual ~__tds__GetCapabilities() { }
	friend __tds__GetCapabilities *soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46118 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (2481)
/* Operation wrapper: */
struct __tds__SetDPAddresses
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of XSD type tds:SetDPAddresses */
public:
	int soap_type() const { return 2481; } /* = unique type id SOAP_TYPE___tds__SetDPAddresses */
	         __tds__SetDPAddresses();
	virtual ~__tds__SetDPAddresses() { }
	friend __tds__SetDPAddresses *soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46188 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (2485)
/* Operation wrapper: */
struct __tds__GetHostname
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of XSD type tds:GetHostname */
public:
	int soap_type() const { return 2485; } /* = unique type id SOAP_TYPE___tds__GetHostname */
	         __tds__GetHostname();
	virtual ~__tds__GetHostname() { }
	friend __tds__GetHostname *soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46262 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (2489)
/* Operation wrapper: */
struct __tds__SetHostname
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of XSD type tds:SetHostname */
public:
	int soap_type() const { return 2489; } /* = unique type id SOAP_TYPE___tds__SetHostname */
	         __tds__SetHostname();
	virtual ~__tds__SetHostname() { }
	friend __tds__SetHostname *soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46329 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (2493)
/* Operation wrapper: */
struct __tds__SetHostnameFromDHCP
{
public:
	_tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;	/* optional element of XSD type tds:SetHostnameFromDHCP */
public:
	int soap_type() const { return 2493; } /* = unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
	         __tds__SetHostnameFromDHCP();
	virtual ~__tds__SetHostnameFromDHCP() { }
	friend __tds__SetHostnameFromDHCP *soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46398 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (2497)
/* Operation wrapper: */
struct __tds__GetDNS
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of XSD type tds:GetDNS */
public:
	int soap_type() const { return 2497; } /* = unique type id SOAP_TYPE___tds__GetDNS */
	         __tds__GetDNS();
	virtual ~__tds__GetDNS() { }
	friend __tds__GetDNS *soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46467 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (2501)
/* Operation wrapper: */
struct __tds__SetDNS
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of XSD type tds:SetDNS */
public:
	int soap_type() const { return 2501; } /* = unique type id SOAP_TYPE___tds__SetDNS */
	         __tds__SetDNS();
	virtual ~__tds__SetDNS() { }
	friend __tds__SetDNS *soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46537 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (2505)
/* Operation wrapper: */
struct __tds__GetNTP
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of XSD type tds:GetNTP */
public:
	int soap_type() const { return 2505; } /* = unique type id SOAP_TYPE___tds__GetNTP */
	         __tds__GetNTP();
	virtual ~__tds__GetNTP() { }
	friend __tds__GetNTP *soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46614 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (2509)
/* Operation wrapper: */
struct __tds__SetNTP
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of XSD type tds:SetNTP */
public:
	int soap_type() const { return 2509; } /* = unique type id SOAP_TYPE___tds__SetNTP */
	         __tds__SetNTP();
	virtual ~__tds__SetNTP() { }
	friend __tds__SetNTP *soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46685 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (2513)
/* Operation wrapper: */
struct __tds__GetDynamicDNS
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of XSD type tds:GetDynamicDNS */
public:
	int soap_type() const { return 2513; } /* = unique type id SOAP_TYPE___tds__GetDynamicDNS */
	         __tds__GetDynamicDNS();
	virtual ~__tds__GetDynamicDNS() { }
	friend __tds__GetDynamicDNS *soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46756 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (2517)
/* Operation wrapper: */
struct __tds__SetDynamicDNS
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of XSD type tds:SetDynamicDNS */
public:
	int soap_type() const { return 2517; } /* = unique type id SOAP_TYPE___tds__SetDynamicDNS */
	         __tds__SetDynamicDNS();
	virtual ~__tds__SetDynamicDNS() { }
	friend __tds__SetDynamicDNS *soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46827 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (2521)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of XSD type tds:GetNetworkInterfaces */
public:
	int soap_type() const { return 2521; } /* = unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
	         __tds__GetNetworkInterfaces();
	virtual ~__tds__GetNetworkInterfaces() { }
	friend __tds__GetNetworkInterfaces *soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46903 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (2525)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of XSD type tds:SetNetworkInterfaces */
public:
	int soap_type() const { return 2525; } /* = unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
	         __tds__SetNetworkInterfaces();
	virtual ~__tds__SetNetworkInterfaces() { }
	friend __tds__SetNetworkInterfaces *soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46973 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (2529)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of XSD type tds:GetNetworkProtocols */
public:
	int soap_type() const { return 2529; } /* = unique type id SOAP_TYPE___tds__GetNetworkProtocols */
	         __tds__GetNetworkProtocols();
	virtual ~__tds__GetNetworkProtocols() { }
	friend __tds__GetNetworkProtocols *soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47043 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (2533)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of XSD type tds:SetNetworkProtocols */
public:
	int soap_type() const { return 2533; } /* = unique type id SOAP_TYPE___tds__SetNetworkProtocols */
	         __tds__SetNetworkProtocols();
	virtual ~__tds__SetNetworkProtocols() { }
	friend __tds__SetNetworkProtocols *soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47113 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (2537)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of XSD type tds:GetNetworkDefaultGateway */
public:
	int soap_type() const { return 2537; } /* = unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
	         __tds__GetNetworkDefaultGateway();
	virtual ~__tds__GetNetworkDefaultGateway() { }
	friend __tds__GetNetworkDefaultGateway *soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47182 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (2541)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of XSD type tds:SetNetworkDefaultGateway */
public:
	int soap_type() const { return 2541; } /* = unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
	         __tds__SetNetworkDefaultGateway();
	virtual ~__tds__SetNetworkDefaultGateway() { }
	friend __tds__SetNetworkDefaultGateway *soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47256 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (2545)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of XSD type tds:GetZeroConfiguration */
public:
	int soap_type() const { return 2545; } /* = unique type id SOAP_TYPE___tds__GetZeroConfiguration */
	         __tds__GetZeroConfiguration();
	virtual ~__tds__GetZeroConfiguration() { }
	friend __tds__GetZeroConfiguration *soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47324 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (2549)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of XSD type tds:SetZeroConfiguration */
public:
	int soap_type() const { return 2549; } /* = unique type id SOAP_TYPE___tds__SetZeroConfiguration */
	         __tds__SetZeroConfiguration();
	virtual ~__tds__SetZeroConfiguration() { }
	friend __tds__SetZeroConfiguration *soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47395 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (2553)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of XSD type tds:GetIPAddressFilter */
public:
	int soap_type() const { return 2553; } /* = unique type id SOAP_TYPE___tds__GetIPAddressFilter */
	         __tds__GetIPAddressFilter();
	virtual ~__tds__GetIPAddressFilter() { }
	friend __tds__GetIPAddressFilter *soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47468 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (2557)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of XSD type tds:SetIPAddressFilter */
public:
	int soap_type() const { return 2557; } /* = unique type id SOAP_TYPE___tds__SetIPAddressFilter */
	         __tds__SetIPAddressFilter();
	virtual ~__tds__SetIPAddressFilter() { }
	friend __tds__SetIPAddressFilter *soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47540 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (2561)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of XSD type tds:AddIPAddressFilter */
public:
	int soap_type() const { return 2561; } /* = unique type id SOAP_TYPE___tds__AddIPAddressFilter */
	         __tds__AddIPAddressFilter();
	virtual ~__tds__AddIPAddressFilter() { }
	friend __tds__AddIPAddressFilter *soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47612 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (2565)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of XSD type tds:RemoveIPAddressFilter */
public:
	int soap_type() const { return 2565; } /* = unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
	         __tds__RemoveIPAddressFilter();
	virtual ~__tds__RemoveIPAddressFilter() { }
	friend __tds__RemoveIPAddressFilter *soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47693 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (2569)
/* Operation wrapper: */
struct __tds__GetAccessPolicy
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of XSD type tds:GetAccessPolicy */
public:
	int soap_type() const { return 2569; } /* = unique type id SOAP_TYPE___tds__GetAccessPolicy */
	         __tds__GetAccessPolicy();
	virtual ~__tds__GetAccessPolicy() { }
	friend __tds__GetAccessPolicy *soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47765 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (2573)
/* Operation wrapper: */
struct __tds__SetAccessPolicy
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of XSD type tds:SetAccessPolicy */
public:
	int soap_type() const { return 2573; } /* = unique type id SOAP_TYPE___tds__SetAccessPolicy */
	         __tds__SetAccessPolicy();
	virtual ~__tds__SetAccessPolicy() { }
	friend __tds__SetAccessPolicy *soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47847 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (2577)
/* Operation wrapper: */
struct __tds__CreateCertificate
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of XSD type tds:CreateCertificate */
public:
	int soap_type() const { return 2577; } /* = unique type id SOAP_TYPE___tds__CreateCertificate */
	         __tds__CreateCertificate();
	virtual ~__tds__CreateCertificate() { }
	friend __tds__CreateCertificate *soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47926 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (2581)
/* Operation wrapper: */
struct __tds__GetCertificates
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of XSD type tds:GetCertificates */
public:
	int soap_type() const { return 2581; } /* = unique type id SOAP_TYPE___tds__GetCertificates */
	         __tds__GetCertificates();
	virtual ~__tds__GetCertificates() { }
	friend __tds__GetCertificates *soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47996 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (2585)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of XSD type tds:GetCertificatesStatus */
public:
	int soap_type() const { return 2585; } /* = unique type id SOAP_TYPE___tds__GetCertificatesStatus */
	         __tds__GetCertificatesStatus();
	virtual ~__tds__GetCertificatesStatus() { }
	friend __tds__GetCertificatesStatus *soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48068 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (2589)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of XSD type tds:SetCertificatesStatus */
public:
	int soap_type() const { return 2589; } /* = unique type id SOAP_TYPE___tds__SetCertificatesStatus */
	         __tds__SetCertificatesStatus();
	virtual ~__tds__SetCertificatesStatus() { }
	friend __tds__SetCertificatesStatus *soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48143 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (2593)
/* Operation wrapper: */
struct __tds__DeleteCertificates
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of XSD type tds:DeleteCertificates */
public:
	int soap_type() const { return 2593; } /* = unique type id SOAP_TYPE___tds__DeleteCertificates */
	         __tds__DeleteCertificates();
	virtual ~__tds__DeleteCertificates() { }
	friend __tds__DeleteCertificates *soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48223 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (2597)
/* Operation wrapper: */
struct __tds__GetPkcs10Request
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of XSD type tds:GetPkcs10Request */
public:
	int soap_type() const { return 2597; } /* = unique type id SOAP_TYPE___tds__GetPkcs10Request */
	         __tds__GetPkcs10Request();
	virtual ~__tds__GetPkcs10Request() { }
	friend __tds__GetPkcs10Request *soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48313 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (2601)
/* Operation wrapper: */
struct __tds__LoadCertificates
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of XSD type tds:LoadCertificates */
public:
	int soap_type() const { return 2601; } /* = unique type id SOAP_TYPE___tds__LoadCertificates */
	         __tds__LoadCertificates();
	virtual ~__tds__LoadCertificates() { }
	friend __tds__LoadCertificates *soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48383 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (2605)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of XSD type tds:GetClientCertificateMode */
public:
	int soap_type() const { return 2605; } /* = unique type id SOAP_TYPE___tds__GetClientCertificateMode */
	         __tds__GetClientCertificateMode();
	virtual ~__tds__GetClientCertificateMode() { }
	friend __tds__GetClientCertificateMode *soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48453 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (2609)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of XSD type tds:SetClientCertificateMode */
public:
	int soap_type() const { return 2609; } /* = unique type id SOAP_TYPE___tds__SetClientCertificateMode */
	         __tds__SetClientCertificateMode();
	virtual ~__tds__SetClientCertificateMode() { }
	friend __tds__SetClientCertificateMode *soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48522 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (2613)
/* Operation wrapper: */
struct __tds__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 2613; } /* = unique type id SOAP_TYPE___tds__GetRelayOutputs */
	         __tds__GetRelayOutputs();
	virtual ~__tds__GetRelayOutputs() { }
	friend __tds__GetRelayOutputs *soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48591 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (2617)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of XSD type tds:SetRelayOutputSettings */
public:
	int soap_type() const { return 2617; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
	         __tds__SetRelayOutputSettings();
	virtual ~__tds__SetRelayOutputSettings() { }
	friend __tds__SetRelayOutputSettings *soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48660 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (2621)
/* Operation wrapper: */
struct __tds__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 2621; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputState */
	         __tds__SetRelayOutputState();
	virtual ~__tds__SetRelayOutputState() { }
	friend __tds__SetRelayOutputState *soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48758 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (2625)
/* Operation wrapper: */
struct __tds__SendAuxiliaryCommand
{
public:
	_tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;	/* optional element of XSD type tds:SendAuxiliaryCommand */
public:
	int soap_type() const { return 2625; } /* = unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
	         __tds__SendAuxiliaryCommand();
	virtual ~__tds__SendAuxiliaryCommand() { }
	friend __tds__SendAuxiliaryCommand *soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48836 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (2629)
/* Operation wrapper: */
struct __tds__GetCACertificates
{
public:
	_tds__GetCACertificates *tds__GetCACertificates;	/* optional element of XSD type tds:GetCACertificates */
public:
	int soap_type() const { return 2629; } /* = unique type id SOAP_TYPE___tds__GetCACertificates */
	         __tds__GetCACertificates();
	virtual ~__tds__GetCACertificates() { }
	friend __tds__GetCACertificates *soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48926 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (2633)
/* Operation wrapper: */
struct __tds__LoadCertificateWithPrivateKey
{
public:
	_tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;	/* optional element of XSD type tds:LoadCertificateWithPrivateKey */
public:
	int soap_type() const { return 2633; } /* = unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
	         __tds__LoadCertificateWithPrivateKey();
	virtual ~__tds__LoadCertificateWithPrivateKey() { }
	friend __tds__LoadCertificateWithPrivateKey *soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49003 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (2637)
/* Operation wrapper: */
struct __tds__GetCertificateInformation
{
public:
	_tds__GetCertificateInformation *tds__GetCertificateInformation;	/* optional element of XSD type tds:GetCertificateInformation */
public:
	int soap_type() const { return 2637; } /* = unique type id SOAP_TYPE___tds__GetCertificateInformation */
	         __tds__GetCertificateInformation();
	virtual ~__tds__GetCertificateInformation() { }
	friend __tds__GetCertificateInformation *soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49087 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (2641)
/* Operation wrapper: */
struct __tds__LoadCACertificates
{
public:
	_tds__LoadCACertificates *tds__LoadCACertificates;	/* optional element of XSD type tds:LoadCACertificates */
public:
	int soap_type() const { return 2641; } /* = unique type id SOAP_TYPE___tds__LoadCACertificates */
	         __tds__LoadCACertificates();
	virtual ~__tds__LoadCACertificates() { }
	friend __tds__LoadCACertificates *soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49162 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (2645)
/* Operation wrapper: */
struct __tds__CreateDot1XConfiguration
{
public:
	_tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;	/* optional element of XSD type tds:CreateDot1XConfiguration */
public:
	int soap_type() const { return 2645; } /* = unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
	         __tds__CreateDot1XConfiguration();
	virtual ~__tds__CreateDot1XConfiguration() { }
	friend __tds__CreateDot1XConfiguration *soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49233 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (2649)
/* Operation wrapper: */
struct __tds__SetDot1XConfiguration
{
public:
	_tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;	/* optional element of XSD type tds:SetDot1XConfiguration */
public:
	int soap_type() const { return 2649; } /* = unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
	         __tds__SetDot1XConfiguration();
	virtual ~__tds__SetDot1XConfiguration() { }
	friend __tds__SetDot1XConfiguration *soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49308 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (2653)
/* Operation wrapper: */
struct __tds__GetDot1XConfiguration
{
public:
	_tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;	/* optional element of XSD type tds:GetDot1XConfiguration */
public:
	int soap_type() const { return 2653; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
	         __tds__GetDot1XConfiguration();
	virtual ~__tds__GetDot1XConfiguration() { }
	friend __tds__GetDot1XConfiguration *soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49386 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (2657)
/* Operation wrapper: */
struct __tds__GetDot1XConfigurations
{
public:
	_tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;	/* optional element of XSD type tds:GetDot1XConfigurations */
public:
	int soap_type() const { return 2657; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
	         __tds__GetDot1XConfigurations();
	virtual ~__tds__GetDot1XConfigurations() { }
	friend __tds__GetDot1XConfigurations *soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49458 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (2661)
/* Operation wrapper: */
struct __tds__DeleteDot1XConfiguration
{
public:
	_tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;	/* optional element of XSD type tds:DeleteDot1XConfiguration */
public:
	int soap_type() const { return 2661; } /* = unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
	         __tds__DeleteDot1XConfiguration();
	virtual ~__tds__DeleteDot1XConfiguration() { }
	friend __tds__DeleteDot1XConfiguration *soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49526 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (2665)
/* Operation wrapper: */
struct __tds__GetDot11Capabilities
{
public:
	_tds__GetDot11Capabilities *tds__GetDot11Capabilities;	/* optional element of XSD type tds:GetDot11Capabilities */
public:
	int soap_type() const { return 2665; } /* = unique type id SOAP_TYPE___tds__GetDot11Capabilities */
	         __tds__GetDot11Capabilities();
	virtual ~__tds__GetDot11Capabilities() { }
	friend __tds__GetDot11Capabilities *soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49595 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (2669)
/* Operation wrapper: */
struct __tds__GetDot11Status
{
public:
	_tds__GetDot11Status *tds__GetDot11Status;	/* optional element of XSD type tds:GetDot11Status */
public:
	int soap_type() const { return 2669; } /* = unique type id SOAP_TYPE___tds__GetDot11Status */
	         __tds__GetDot11Status();
	virtual ~__tds__GetDot11Status() { }
	friend __tds__GetDot11Status *soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49664 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (2673)
/* Operation wrapper: */
struct __tds__ScanAvailableDot11Networks
{
public:
	_tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;	/* optional element of XSD type tds:ScanAvailableDot11Networks */
public:
	int soap_type() const { return 2673; } /* = unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
	         __tds__ScanAvailableDot11Networks();
	virtual ~__tds__ScanAvailableDot11Networks() { }
	friend __tds__ScanAvailableDot11Networks *soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49750 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (2677)
/* Operation wrapper: */
struct __tds__GetSystemUris
{
public:
	_tds__GetSystemUris *tds__GetSystemUris;	/* optional element of XSD type tds:GetSystemUris */
public:
	int soap_type() const { return 2677; } /* = unique type id SOAP_TYPE___tds__GetSystemUris */
	         __tds__GetSystemUris();
	virtual ~__tds__GetSystemUris() { }
	friend __tds__GetSystemUris *soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49845 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (2681)
/* Operation wrapper: */
struct __tds__StartFirmwareUpgrade
{
public:
	_tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;	/* optional element of XSD type tds:StartFirmwareUpgrade */
public:
	int soap_type() const { return 2681; } /* = unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
	         __tds__StartFirmwareUpgrade();
	virtual ~__tds__StartFirmwareUpgrade() { }
	friend __tds__StartFirmwareUpgrade *soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49939 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (2685)
/* Operation wrapper: */
struct __tds__StartSystemRestore
{
public:
	_tds__StartSystemRestore *tds__StartSystemRestore;	/* optional element of XSD type tds:StartSystemRestore */
public:
	int soap_type() const { return 2685; } /* = unique type id SOAP_TYPE___tds__StartSystemRestore */
	         __tds__StartSystemRestore();
	virtual ~__tds__StartSystemRestore() { }
	friend __tds__StartSystemRestore *soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50009 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations
#define SOAP_TYPE___tds__GetStorageConfigurations (2689)
/* Operation wrapper: */
struct __tds__GetStorageConfigurations
{
public:
	_tds__GetStorageConfigurations *tds__GetStorageConfigurations;	/* optional element of XSD type tds:GetStorageConfigurations */
public:
	int soap_type() const { return 2689; } /* = unique type id SOAP_TYPE___tds__GetStorageConfigurations */
	         __tds__GetStorageConfigurations();
	virtual ~__tds__GetStorageConfigurations() { }
	friend __tds__GetStorageConfigurations *soap_instantiate___tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50080 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration
#define SOAP_TYPE___tds__CreateStorageConfiguration (2693)
/* Operation wrapper: */
struct __tds__CreateStorageConfiguration
{
public:
	_tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;	/* optional element of XSD type tds:CreateStorageConfiguration */
public:
	int soap_type() const { return 2693; } /* = unique type id SOAP_TYPE___tds__CreateStorageConfiguration */
	         __tds__CreateStorageConfiguration();
	virtual ~__tds__CreateStorageConfiguration() { }
	friend __tds__CreateStorageConfiguration *soap_instantiate___tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50150 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration
#define SOAP_TYPE___tds__GetStorageConfiguration (2697)
/* Operation wrapper: */
struct __tds__GetStorageConfiguration
{
public:
	_tds__GetStorageConfiguration *tds__GetStorageConfiguration;	/* optional element of XSD type tds:GetStorageConfiguration */
public:
	int soap_type() const { return 2697; } /* = unique type id SOAP_TYPE___tds__GetStorageConfiguration */
	         __tds__GetStorageConfiguration();
	virtual ~__tds__GetStorageConfiguration() { }
	friend __tds__GetStorageConfiguration *soap_instantiate___tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50219 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration
#define SOAP_TYPE___tds__SetStorageConfiguration (2701)
/* Operation wrapper: */
struct __tds__SetStorageConfiguration
{
public:
	_tds__SetStorageConfiguration *tds__SetStorageConfiguration;	/* optional element of XSD type tds:SetStorageConfiguration */
public:
	int soap_type() const { return 2701; } /* = unique type id SOAP_TYPE___tds__SetStorageConfiguration */
	         __tds__SetStorageConfiguration();
	virtual ~__tds__SetStorageConfiguration() { }
	friend __tds__SetStorageConfiguration *soap_instantiate___tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50289 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration
#define SOAP_TYPE___tds__DeleteStorageConfiguration (2705)
/* Operation wrapper: */
struct __tds__DeleteStorageConfiguration
{
public:
	_tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;	/* optional element of XSD type tds:DeleteStorageConfiguration */
public:
	int soap_type() const { return 2705; } /* = unique type id SOAP_TYPE___tds__DeleteStorageConfiguration */
	         __tds__DeleteStorageConfiguration();
	virtual ~__tds__DeleteStorageConfiguration() { }
	friend __tds__DeleteStorageConfiguration *soap_instantiate___tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50356 */
#ifndef SOAP_TYPE___tds__GetServices_
#define SOAP_TYPE___tds__GetServices_ (2707)
/* Operation wrapper: */
struct __tds__GetServices_
{
public:
	_tds__GetServices *tds__GetServices;	/* optional element of XSD type tds:GetServices */
public:
	int soap_type() const { return 2707; } /* = unique type id SOAP_TYPE___tds__GetServices_ */
	         __tds__GetServices_();
	virtual ~__tds__GetServices_() { }
	friend __tds__GetServices_ *soap_instantiate___tds__GetServices_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50424 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities_
#define SOAP_TYPE___tds__GetServiceCapabilities_ (2709)
/* Operation wrapper: */
struct __tds__GetServiceCapabilities_
{
public:
	_tds__GetServiceCapabilities *tds__GetServiceCapabilities;	/* optional element of XSD type tds:GetServiceCapabilities */
public:
	int soap_type() const { return 2709; } /* = unique type id SOAP_TYPE___tds__GetServiceCapabilities_ */
	         __tds__GetServiceCapabilities_();
	virtual ~__tds__GetServiceCapabilities_() { }
	friend __tds__GetServiceCapabilities_ *soap_instantiate___tds__GetServiceCapabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50491 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation_
#define SOAP_TYPE___tds__GetDeviceInformation_ (2711)
/* Operation wrapper: */
struct __tds__GetDeviceInformation_
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of XSD type tds:GetDeviceInformation */
public:
	int soap_type() const { return 2711; } /* = unique type id SOAP_TYPE___tds__GetDeviceInformation_ */
	         __tds__GetDeviceInformation_();
	virtual ~__tds__GetDeviceInformation_() { }
	friend __tds__GetDeviceInformation_ *soap_instantiate___tds__GetDeviceInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50572 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime_
#define SOAP_TYPE___tds__SetSystemDateAndTime_ (2713)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime_
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of XSD type tds:SetSystemDateAndTime */
public:
	int soap_type() const { return 2713; } /* = unique type id SOAP_TYPE___tds__SetSystemDateAndTime_ */
	         __tds__SetSystemDateAndTime_();
	virtual ~__tds__SetSystemDateAndTime_() { }
	friend __tds__SetSystemDateAndTime_ *soap_instantiate___tds__SetSystemDateAndTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50645 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime_
#define SOAP_TYPE___tds__GetSystemDateAndTime_ (2715)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime_
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of XSD type tds:GetSystemDateAndTime */
public:
	int soap_type() const { return 2715; } /* = unique type id SOAP_TYPE___tds__GetSystemDateAndTime_ */
	         __tds__GetSystemDateAndTime_();
	virtual ~__tds__GetSystemDateAndTime_() { }
	friend __tds__GetSystemDateAndTime_ *soap_instantiate___tds__GetSystemDateAndTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50712 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault_
#define SOAP_TYPE___tds__SetSystemFactoryDefault_ (2717)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault_
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of XSD type tds:SetSystemFactoryDefault */
public:
	int soap_type() const { return 2717; } /* = unique type id SOAP_TYPE___tds__SetSystemFactoryDefault_ */
	         __tds__SetSystemFactoryDefault_();
	virtual ~__tds__SetSystemFactoryDefault_() { }
	friend __tds__SetSystemFactoryDefault_ *soap_instantiate___tds__SetSystemFactoryDefault_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50785 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware_
#define SOAP_TYPE___tds__UpgradeSystemFirmware_ (2719)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware_
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of XSD type tds:UpgradeSystemFirmware */
public:
	int soap_type() const { return 2719; } /* = unique type id SOAP_TYPE___tds__UpgradeSystemFirmware_ */
	         __tds__UpgradeSystemFirmware_();
	virtual ~__tds__UpgradeSystemFirmware_() { }
	friend __tds__UpgradeSystemFirmware_ *soap_instantiate___tds__UpgradeSystemFirmware_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50852 */
#ifndef SOAP_TYPE___tds__SystemReboot_
#define SOAP_TYPE___tds__SystemReboot_ (2721)
/* Operation wrapper: */
struct __tds__SystemReboot_
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of XSD type tds:SystemReboot */
public:
	int soap_type() const { return 2721; } /* = unique type id SOAP_TYPE___tds__SystemReboot_ */
	         __tds__SystemReboot_();
	virtual ~__tds__SystemReboot_() { }
	friend __tds__SystemReboot_ *soap_instantiate___tds__SystemReboot_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50927 */
#ifndef SOAP_TYPE___tds__RestoreSystem_
#define SOAP_TYPE___tds__RestoreSystem_ (2723)
/* Operation wrapper: */
struct __tds__RestoreSystem_
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of XSD type tds:RestoreSystem */
public:
	int soap_type() const { return 2723; } /* = unique type id SOAP_TYPE___tds__RestoreSystem_ */
	         __tds__RestoreSystem_();
	virtual ~__tds__RestoreSystem_() { }
	friend __tds__RestoreSystem_ *soap_instantiate___tds__RestoreSystem_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51001 */
#ifndef SOAP_TYPE___tds__GetSystemBackup_
#define SOAP_TYPE___tds__GetSystemBackup_ (2725)
/* Operation wrapper: */
struct __tds__GetSystemBackup_
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of XSD type tds:GetSystemBackup */
public:
	int soap_type() const { return 2725; } /* = unique type id SOAP_TYPE___tds__GetSystemBackup_ */
	         __tds__GetSystemBackup_();
	virtual ~__tds__GetSystemBackup_() { }
	friend __tds__GetSystemBackup_ *soap_instantiate___tds__GetSystemBackup_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51069 */
#ifndef SOAP_TYPE___tds__GetSystemLog_
#define SOAP_TYPE___tds__GetSystemLog_ (2727)
/* Operation wrapper: */
struct __tds__GetSystemLog_
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of XSD type tds:GetSystemLog */
public:
	int soap_type() const { return 2727; } /* = unique type id SOAP_TYPE___tds__GetSystemLog_ */
	         __tds__GetSystemLog_();
	virtual ~__tds__GetSystemLog_() { }
	friend __tds__GetSystemLog_ *soap_instantiate___tds__GetSystemLog_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51136 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation_
#define SOAP_TYPE___tds__GetSystemSupportInformation_ (2729)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation_
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of XSD type tds:GetSystemSupportInformation */
public:
	int soap_type() const { return 2729; } /* = unique type id SOAP_TYPE___tds__GetSystemSupportInformation_ */
	         __tds__GetSystemSupportInformation_();
	virtual ~__tds__GetSystemSupportInformation_() { }
	friend __tds__GetSystemSupportInformation_ *soap_instantiate___tds__GetSystemSupportInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51218 */
#ifndef SOAP_TYPE___tds__GetScopes_
#define SOAP_TYPE___tds__GetScopes_ (2731)
/* Operation wrapper: */
struct __tds__GetScopes_
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of XSD type tds:GetScopes */
public:
	int soap_type() const { return 2731; } /* = unique type id SOAP_TYPE___tds__GetScopes_ */
	         __tds__GetScopes_();
	virtual ~__tds__GetScopes_() { }
	friend __tds__GetScopes_ *soap_instantiate___tds__GetScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51293 */
#ifndef SOAP_TYPE___tds__SetScopes_
#define SOAP_TYPE___tds__SetScopes_ (2733)
/* Operation wrapper: */
struct __tds__SetScopes_
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of XSD type tds:SetScopes */
public:
	int soap_type() const { return 2733; } /* = unique type id SOAP_TYPE___tds__SetScopes_ */
	         __tds__SetScopes_();
	virtual ~__tds__SetScopes_() { }
	friend __tds__SetScopes_ *soap_instantiate___tds__SetScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51364 */
#ifndef SOAP_TYPE___tds__AddScopes_
#define SOAP_TYPE___tds__AddScopes_ (2735)
/* Operation wrapper: */
struct __tds__AddScopes_
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of XSD type tds:AddScopes */
public:
	int soap_type() const { return 2735; } /* = unique type id SOAP_TYPE___tds__AddScopes_ */
	         __tds__AddScopes_();
	virtual ~__tds__AddScopes_() { }
	friend __tds__AddScopes_ *soap_instantiate___tds__AddScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51437 */
#ifndef SOAP_TYPE___tds__RemoveScopes_
#define SOAP_TYPE___tds__RemoveScopes_ (2737)
/* Operation wrapper: */
struct __tds__RemoveScopes_
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of XSD type tds:RemoveScopes */
public:
	int soap_type() const { return 2737; } /* = unique type id SOAP_TYPE___tds__RemoveScopes_ */
	         __tds__RemoveScopes_();
	virtual ~__tds__RemoveScopes_() { }
	friend __tds__RemoveScopes_ *soap_instantiate___tds__RemoveScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51508 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode_
#define SOAP_TYPE___tds__GetDiscoveryMode_ (2739)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode_
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of XSD type tds:GetDiscoveryMode */
public:
	int soap_type() const { return 2739; } /* = unique type id SOAP_TYPE___tds__GetDiscoveryMode_ */
	         __tds__GetDiscoveryMode_();
	virtual ~__tds__GetDiscoveryMode_() { }
	friend __tds__GetDiscoveryMode_ *soap_instantiate___tds__GetDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51580 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode_
#define SOAP_TYPE___tds__SetDiscoveryMode_ (2741)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode_
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of XSD type tds:SetDiscoveryMode */
public:
	int soap_type() const { return 2741; } /* = unique type id SOAP_TYPE___tds__SetDiscoveryMode_ */
	         __tds__SetDiscoveryMode_();
	virtual ~__tds__SetDiscoveryMode_() { }
	friend __tds__SetDiscoveryMode_ *soap_instantiate___tds__SetDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51653 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode_
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode_ (2743)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode_
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of XSD type tds:GetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2743; } /* = unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode_ */
	         __tds__GetRemoteDiscoveryMode_();
	virtual ~__tds__GetRemoteDiscoveryMode_() { }
	friend __tds__GetRemoteDiscoveryMode_ *soap_instantiate___tds__GetRemoteDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51726 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode_
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode_ (2745)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode_
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of XSD type tds:SetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2745; } /* = unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode_ */
	         __tds__SetRemoteDiscoveryMode_();
	virtual ~__tds__SetRemoteDiscoveryMode_() { }
	friend __tds__SetRemoteDiscoveryMode_ *soap_instantiate___tds__SetRemoteDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51797 */
#ifndef SOAP_TYPE___tds__GetDPAddresses_
#define SOAP_TYPE___tds__GetDPAddresses_ (2747)
/* Operation wrapper: */
struct __tds__GetDPAddresses_
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of XSD type tds:GetDPAddresses */
public:
	int soap_type() const { return 2747; } /* = unique type id SOAP_TYPE___tds__GetDPAddresses_ */
	         __tds__GetDPAddresses_();
	virtual ~__tds__GetDPAddresses_() { }
	friend __tds__GetDPAddresses_ *soap_instantiate___tds__GetDPAddresses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51870 */
#ifndef SOAP_TYPE___tds__GetEndpointReference_
#define SOAP_TYPE___tds__GetEndpointReference_ (2749)
/* Operation wrapper: */
struct __tds__GetEndpointReference_
{
public:
	_tds__GetEndpointReference *tds__GetEndpointReference;	/* optional element of XSD type tds:GetEndpointReference */
public:
	int soap_type() const { return 2749; } /* = unique type id SOAP_TYPE___tds__GetEndpointReference_ */
	         __tds__GetEndpointReference_();
	virtual ~__tds__GetEndpointReference_() { }
	friend __tds__GetEndpointReference_ *soap_instantiate___tds__GetEndpointReference_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51943 */
#ifndef SOAP_TYPE___tds__GetRemoteUser_
#define SOAP_TYPE___tds__GetRemoteUser_ (2751)
/* Operation wrapper: */
struct __tds__GetRemoteUser_
{
public:
	_tds__GetRemoteUser *tds__GetRemoteUser;	/* optional element of XSD type tds:GetRemoteUser */
public:
	int soap_type() const { return 2751; } /* = unique type id SOAP_TYPE___tds__GetRemoteUser_ */
	         __tds__GetRemoteUser_();
	virtual ~__tds__GetRemoteUser_() { }
	friend __tds__GetRemoteUser_ *soap_instantiate___tds__GetRemoteUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52021 */
#ifndef SOAP_TYPE___tds__SetRemoteUser_
#define SOAP_TYPE___tds__SetRemoteUser_ (2753)
/* Operation wrapper: */
struct __tds__SetRemoteUser_
{
public:
	_tds__SetRemoteUser *tds__SetRemoteUser;	/* optional element of XSD type tds:SetRemoteUser */
public:
	int soap_type() const { return 2753; } /* = unique type id SOAP_TYPE___tds__SetRemoteUser_ */
	         __tds__SetRemoteUser_();
	virtual ~__tds__SetRemoteUser_() { }
	friend __tds__SetRemoteUser_ *soap_instantiate___tds__SetRemoteUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52092 */
#ifndef SOAP_TYPE___tds__GetUsers_
#define SOAP_TYPE___tds__GetUsers_ (2755)
/* Operation wrapper: */
struct __tds__GetUsers_
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of XSD type tds:GetUsers */
public:
	int soap_type() const { return 2755; } /* = unique type id SOAP_TYPE___tds__GetUsers_ */
	         __tds__GetUsers_();
	virtual ~__tds__GetUsers_() { }
	friend __tds__GetUsers_ *soap_instantiate___tds__GetUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52171 */
#ifndef SOAP_TYPE___tds__CreateUsers_
#define SOAP_TYPE___tds__CreateUsers_ (2757)
/* Operation wrapper: */
struct __tds__CreateUsers_
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of XSD type tds:CreateUsers */
public:
	int soap_type() const { return 2757; } /* = unique type id SOAP_TYPE___tds__CreateUsers_ */
	         __tds__CreateUsers_();
	virtual ~__tds__CreateUsers_() { }
	friend __tds__CreateUsers_ *soap_instantiate___tds__CreateUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52245 */
#ifndef SOAP_TYPE___tds__DeleteUsers_
#define SOAP_TYPE___tds__DeleteUsers_ (2759)
/* Operation wrapper: */
struct __tds__DeleteUsers_
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of XSD type tds:DeleteUsers */
public:
	int soap_type() const { return 2759; } /* = unique type id SOAP_TYPE___tds__DeleteUsers_ */
	         __tds__DeleteUsers_();
	virtual ~__tds__DeleteUsers_() { }
	friend __tds__DeleteUsers_ *soap_instantiate___tds__DeleteUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52317 */
#ifndef SOAP_TYPE___tds__SetUser_
#define SOAP_TYPE___tds__SetUser_ (2761)
/* Operation wrapper: */
struct __tds__SetUser_
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of XSD type tds:SetUser */
public:
	int soap_type() const { return 2761; } /* = unique type id SOAP_TYPE___tds__SetUser_ */
	         __tds__SetUser_();
	virtual ~__tds__SetUser_() { }
	friend __tds__SetUser_ *soap_instantiate___tds__SetUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52391 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl_
#define SOAP_TYPE___tds__GetWsdlUrl_ (2763)
/* Operation wrapper: */
struct __tds__GetWsdlUrl_
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of XSD type tds:GetWsdlUrl */
public:
	int soap_type() const { return 2763; } /* = unique type id SOAP_TYPE___tds__GetWsdlUrl_ */
	         __tds__GetWsdlUrl_();
	virtual ~__tds__GetWsdlUrl_() { }
	friend __tds__GetWsdlUrl_ *soap_instantiate___tds__GetWsdlUrl_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52467 */
#ifndef SOAP_TYPE___tds__GetCapabilities_
#define SOAP_TYPE___tds__GetCapabilities_ (2765)
/* Operation wrapper: */
struct __tds__GetCapabilities_
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of XSD type tds:GetCapabilities */
public:
	int soap_type() const { return 2765; } /* = unique type id SOAP_TYPE___tds__GetCapabilities_ */
	         __tds__GetCapabilities_();
	virtual ~__tds__GetCapabilities_() { }
	friend __tds__GetCapabilities_ *soap_instantiate___tds__GetCapabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52539 */
#ifndef SOAP_TYPE___tds__SetDPAddresses_
#define SOAP_TYPE___tds__SetDPAddresses_ (2767)
/* Operation wrapper: */
struct __tds__SetDPAddresses_
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of XSD type tds:SetDPAddresses */
public:
	int soap_type() const { return 2767; } /* = unique type id SOAP_TYPE___tds__SetDPAddresses_ */
	         __tds__SetDPAddresses_();
	virtual ~__tds__SetDPAddresses_() { }
	friend __tds__SetDPAddresses_ *soap_instantiate___tds__SetDPAddresses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52609 */
#ifndef SOAP_TYPE___tds__GetHostname_
#define SOAP_TYPE___tds__GetHostname_ (2769)
/* Operation wrapper: */
struct __tds__GetHostname_
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of XSD type tds:GetHostname */
public:
	int soap_type() const { return 2769; } /* = unique type id SOAP_TYPE___tds__GetHostname_ */
	         __tds__GetHostname_();
	virtual ~__tds__GetHostname_() { }
	friend __tds__GetHostname_ *soap_instantiate___tds__GetHostname_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52683 */
#ifndef SOAP_TYPE___tds__SetHostname_
#define SOAP_TYPE___tds__SetHostname_ (2771)
/* Operation wrapper: */
struct __tds__SetHostname_
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of XSD type tds:SetHostname */
public:
	int soap_type() const { return 2771; } /* = unique type id SOAP_TYPE___tds__SetHostname_ */
	         __tds__SetHostname_();
	virtual ~__tds__SetHostname_() { }
	friend __tds__SetHostname_ *soap_instantiate___tds__SetHostname_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52750 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP_
#define SOAP_TYPE___tds__SetHostnameFromDHCP_ (2773)
/* Operation wrapper: */
struct __tds__SetHostnameFromDHCP_
{
public:
	_tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;	/* optional element of XSD type tds:SetHostnameFromDHCP */
public:
	int soap_type() const { return 2773; } /* = unique type id SOAP_TYPE___tds__SetHostnameFromDHCP_ */
	         __tds__SetHostnameFromDHCP_();
	virtual ~__tds__SetHostnameFromDHCP_() { }
	friend __tds__SetHostnameFromDHCP_ *soap_instantiate___tds__SetHostnameFromDHCP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52819 */
#ifndef SOAP_TYPE___tds__GetDNS_
#define SOAP_TYPE___tds__GetDNS_ (2775)
/* Operation wrapper: */
struct __tds__GetDNS_
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of XSD type tds:GetDNS */
public:
	int soap_type() const { return 2775; } /* = unique type id SOAP_TYPE___tds__GetDNS_ */
	         __tds__GetDNS_();
	virtual ~__tds__GetDNS_() { }
	friend __tds__GetDNS_ *soap_instantiate___tds__GetDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52888 */
#ifndef SOAP_TYPE___tds__SetDNS_
#define SOAP_TYPE___tds__SetDNS_ (2777)
/* Operation wrapper: */
struct __tds__SetDNS_
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of XSD type tds:SetDNS */
public:
	int soap_type() const { return 2777; } /* = unique type id SOAP_TYPE___tds__SetDNS_ */
	         __tds__SetDNS_();
	virtual ~__tds__SetDNS_() { }
	friend __tds__SetDNS_ *soap_instantiate___tds__SetDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52958 */
#ifndef SOAP_TYPE___tds__GetNTP_
#define SOAP_TYPE___tds__GetNTP_ (2779)
/* Operation wrapper: */
struct __tds__GetNTP_
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of XSD type tds:GetNTP */
public:
	int soap_type() const { return 2779; } /* = unique type id SOAP_TYPE___tds__GetNTP_ */
	         __tds__GetNTP_();
	virtual ~__tds__GetNTP_() { }
	friend __tds__GetNTP_ *soap_instantiate___tds__GetNTP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53035 */
#ifndef SOAP_TYPE___tds__SetNTP_
#define SOAP_TYPE___tds__SetNTP_ (2781)
/* Operation wrapper: */
struct __tds__SetNTP_
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of XSD type tds:SetNTP */
public:
	int soap_type() const { return 2781; } /* = unique type id SOAP_TYPE___tds__SetNTP_ */
	         __tds__SetNTP_();
	virtual ~__tds__SetNTP_() { }
	friend __tds__SetNTP_ *soap_instantiate___tds__SetNTP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53106 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS_
#define SOAP_TYPE___tds__GetDynamicDNS_ (2783)
/* Operation wrapper: */
struct __tds__GetDynamicDNS_
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of XSD type tds:GetDynamicDNS */
public:
	int soap_type() const { return 2783; } /* = unique type id SOAP_TYPE___tds__GetDynamicDNS_ */
	         __tds__GetDynamicDNS_();
	virtual ~__tds__GetDynamicDNS_() { }
	friend __tds__GetDynamicDNS_ *soap_instantiate___tds__GetDynamicDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53177 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS_
#define SOAP_TYPE___tds__SetDynamicDNS_ (2785)
/* Operation wrapper: */
struct __tds__SetDynamicDNS_
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of XSD type tds:SetDynamicDNS */
public:
	int soap_type() const { return 2785; } /* = unique type id SOAP_TYPE___tds__SetDynamicDNS_ */
	         __tds__SetDynamicDNS_();
	virtual ~__tds__SetDynamicDNS_() { }
	friend __tds__SetDynamicDNS_ *soap_instantiate___tds__SetDynamicDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53248 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces_
#define SOAP_TYPE___tds__GetNetworkInterfaces_ (2787)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces_
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of XSD type tds:GetNetworkInterfaces */
public:
	int soap_type() const { return 2787; } /* = unique type id SOAP_TYPE___tds__GetNetworkInterfaces_ */
	         __tds__GetNetworkInterfaces_();
	virtual ~__tds__GetNetworkInterfaces_() { }
	friend __tds__GetNetworkInterfaces_ *soap_instantiate___tds__GetNetworkInterfaces_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53324 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces_
#define SOAP_TYPE___tds__SetNetworkInterfaces_ (2789)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces_
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of XSD type tds:SetNetworkInterfaces */
public:
	int soap_type() const { return 2789; } /* = unique type id SOAP_TYPE___tds__SetNetworkInterfaces_ */
	         __tds__SetNetworkInterfaces_();
	virtual ~__tds__SetNetworkInterfaces_() { }
	friend __tds__SetNetworkInterfaces_ *soap_instantiate___tds__SetNetworkInterfaces_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53394 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols_
#define SOAP_TYPE___tds__GetNetworkProtocols_ (2791)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols_
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of XSD type tds:GetNetworkProtocols */
public:
	int soap_type() const { return 2791; } /* = unique type id SOAP_TYPE___tds__GetNetworkProtocols_ */
	         __tds__GetNetworkProtocols_();
	virtual ~__tds__GetNetworkProtocols_() { }
	friend __tds__GetNetworkProtocols_ *soap_instantiate___tds__GetNetworkProtocols_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53464 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols_
#define SOAP_TYPE___tds__SetNetworkProtocols_ (2793)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols_
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of XSD type tds:SetNetworkProtocols */
public:
	int soap_type() const { return 2793; } /* = unique type id SOAP_TYPE___tds__SetNetworkProtocols_ */
	         __tds__SetNetworkProtocols_();
	virtual ~__tds__SetNetworkProtocols_() { }
	friend __tds__SetNetworkProtocols_ *soap_instantiate___tds__SetNetworkProtocols_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53534 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway_
#define SOAP_TYPE___tds__GetNetworkDefaultGateway_ (2795)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway_
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of XSD type tds:GetNetworkDefaultGateway */
public:
	int soap_type() const { return 2795; } /* = unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway_ */
	         __tds__GetNetworkDefaultGateway_();
	virtual ~__tds__GetNetworkDefaultGateway_() { }
	friend __tds__GetNetworkDefaultGateway_ *soap_instantiate___tds__GetNetworkDefaultGateway_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53603 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway_
#define SOAP_TYPE___tds__SetNetworkDefaultGateway_ (2797)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway_
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of XSD type tds:SetNetworkDefaultGateway */
public:
	int soap_type() const { return 2797; } /* = unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway_ */
	         __tds__SetNetworkDefaultGateway_();
	virtual ~__tds__SetNetworkDefaultGateway_() { }
	friend __tds__SetNetworkDefaultGateway_ *soap_instantiate___tds__SetNetworkDefaultGateway_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53677 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration_
#define SOAP_TYPE___tds__GetZeroConfiguration_ (2799)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration_
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of XSD type tds:GetZeroConfiguration */
public:
	int soap_type() const { return 2799; } /* = unique type id SOAP_TYPE___tds__GetZeroConfiguration_ */
	         __tds__GetZeroConfiguration_();
	virtual ~__tds__GetZeroConfiguration_() { }
	friend __tds__GetZeroConfiguration_ *soap_instantiate___tds__GetZeroConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53745 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration_
#define SOAP_TYPE___tds__SetZeroConfiguration_ (2801)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration_
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of XSD type tds:SetZeroConfiguration */
public:
	int soap_type() const { return 2801; } /* = unique type id SOAP_TYPE___tds__SetZeroConfiguration_ */
	         __tds__SetZeroConfiguration_();
	virtual ~__tds__SetZeroConfiguration_() { }
	friend __tds__SetZeroConfiguration_ *soap_instantiate___tds__SetZeroConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53816 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter_
#define SOAP_TYPE___tds__GetIPAddressFilter_ (2803)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter_
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of XSD type tds:GetIPAddressFilter */
public:
	int soap_type() const { return 2803; } /* = unique type id SOAP_TYPE___tds__GetIPAddressFilter_ */
	         __tds__GetIPAddressFilter_();
	virtual ~__tds__GetIPAddressFilter_() { }
	friend __tds__GetIPAddressFilter_ *soap_instantiate___tds__GetIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53889 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter_
#define SOAP_TYPE___tds__SetIPAddressFilter_ (2805)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter_
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of XSD type tds:SetIPAddressFilter */
public:
	int soap_type() const { return 2805; } /* = unique type id SOAP_TYPE___tds__SetIPAddressFilter_ */
	         __tds__SetIPAddressFilter_();
	virtual ~__tds__SetIPAddressFilter_() { }
	friend __tds__SetIPAddressFilter_ *soap_instantiate___tds__SetIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53961 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter_
#define SOAP_TYPE___tds__AddIPAddressFilter_ (2807)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter_
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of XSD type tds:AddIPAddressFilter */
public:
	int soap_type() const { return 2807; } /* = unique type id SOAP_TYPE___tds__AddIPAddressFilter_ */
	         __tds__AddIPAddressFilter_();
	virtual ~__tds__AddIPAddressFilter_() { }
	friend __tds__AddIPAddressFilter_ *soap_instantiate___tds__AddIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54033 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter_
#define SOAP_TYPE___tds__RemoveIPAddressFilter_ (2809)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter_
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of XSD type tds:RemoveIPAddressFilter */
public:
	int soap_type() const { return 2809; } /* = unique type id SOAP_TYPE___tds__RemoveIPAddressFilter_ */
	         __tds__RemoveIPAddressFilter_();
	virtual ~__tds__RemoveIPAddressFilter_() { }
	friend __tds__RemoveIPAddressFilter_ *soap_instantiate___tds__RemoveIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54114 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy_
#define SOAP_TYPE___tds__GetAccessPolicy_ (2811)
/* Operation wrapper: */
struct __tds__GetAccessPolicy_
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of XSD type tds:GetAccessPolicy */
public:
	int soap_type() const { return 2811; } /* = unique type id SOAP_TYPE___tds__GetAccessPolicy_ */
	         __tds__GetAccessPolicy_();
	virtual ~__tds__GetAccessPolicy_() { }
	friend __tds__GetAccessPolicy_ *soap_instantiate___tds__GetAccessPolicy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54186 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy_
#define SOAP_TYPE___tds__SetAccessPolicy_ (2813)
/* Operation wrapper: */
struct __tds__SetAccessPolicy_
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of XSD type tds:SetAccessPolicy */
public:
	int soap_type() const { return 2813; } /* = unique type id SOAP_TYPE___tds__SetAccessPolicy_ */
	         __tds__SetAccessPolicy_();
	virtual ~__tds__SetAccessPolicy_() { }
	friend __tds__SetAccessPolicy_ *soap_instantiate___tds__SetAccessPolicy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54268 */
#ifndef SOAP_TYPE___tds__CreateCertificate_
#define SOAP_TYPE___tds__CreateCertificate_ (2815)
/* Operation wrapper: */
struct __tds__CreateCertificate_
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of XSD type tds:CreateCertificate */
public:
	int soap_type() const { return 2815; } /* = unique type id SOAP_TYPE___tds__CreateCertificate_ */
	         __tds__CreateCertificate_();
	virtual ~__tds__CreateCertificate_() { }
	friend __tds__CreateCertificate_ *soap_instantiate___tds__CreateCertificate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54347 */
#ifndef SOAP_TYPE___tds__GetCertificates_
#define SOAP_TYPE___tds__GetCertificates_ (2817)
/* Operation wrapper: */
struct __tds__GetCertificates_
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of XSD type tds:GetCertificates */
public:
	int soap_type() const { return 2817; } /* = unique type id SOAP_TYPE___tds__GetCertificates_ */
	         __tds__GetCertificates_();
	virtual ~__tds__GetCertificates_() { }
	friend __tds__GetCertificates_ *soap_instantiate___tds__GetCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54417 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus_
#define SOAP_TYPE___tds__GetCertificatesStatus_ (2819)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus_
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of XSD type tds:GetCertificatesStatus */
public:
	int soap_type() const { return 2819; } /* = unique type id SOAP_TYPE___tds__GetCertificatesStatus_ */
	         __tds__GetCertificatesStatus_();
	virtual ~__tds__GetCertificatesStatus_() { }
	friend __tds__GetCertificatesStatus_ *soap_instantiate___tds__GetCertificatesStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54489 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus_
#define SOAP_TYPE___tds__SetCertificatesStatus_ (2821)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus_
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of XSD type tds:SetCertificatesStatus */
public:
	int soap_type() const { return 2821; } /* = unique type id SOAP_TYPE___tds__SetCertificatesStatus_ */
	         __tds__SetCertificatesStatus_();
	virtual ~__tds__SetCertificatesStatus_() { }
	friend __tds__SetCertificatesStatus_ *soap_instantiate___tds__SetCertificatesStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54564 */
#ifndef SOAP_TYPE___tds__DeleteCertificates_
#define SOAP_TYPE___tds__DeleteCertificates_ (2823)
/* Operation wrapper: */
struct __tds__DeleteCertificates_
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of XSD type tds:DeleteCertificates */
public:
	int soap_type() const { return 2823; } /* = unique type id SOAP_TYPE___tds__DeleteCertificates_ */
	         __tds__DeleteCertificates_();
	virtual ~__tds__DeleteCertificates_() { }
	friend __tds__DeleteCertificates_ *soap_instantiate___tds__DeleteCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54644 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request_
#define SOAP_TYPE___tds__GetPkcs10Request_ (2825)
/* Operation wrapper: */
struct __tds__GetPkcs10Request_
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of XSD type tds:GetPkcs10Request */
public:
	int soap_type() const { return 2825; } /* = unique type id SOAP_TYPE___tds__GetPkcs10Request_ */
	         __tds__GetPkcs10Request_();
	virtual ~__tds__GetPkcs10Request_() { }
	friend __tds__GetPkcs10Request_ *soap_instantiate___tds__GetPkcs10Request_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54734 */
#ifndef SOAP_TYPE___tds__LoadCertificates_
#define SOAP_TYPE___tds__LoadCertificates_ (2827)
/* Operation wrapper: */
struct __tds__LoadCertificates_
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of XSD type tds:LoadCertificates */
public:
	int soap_type() const { return 2827; } /* = unique type id SOAP_TYPE___tds__LoadCertificates_ */
	         __tds__LoadCertificates_();
	virtual ~__tds__LoadCertificates_() { }
	friend __tds__LoadCertificates_ *soap_instantiate___tds__LoadCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54804 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode_
#define SOAP_TYPE___tds__GetClientCertificateMode_ (2829)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode_
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of XSD type tds:GetClientCertificateMode */
public:
	int soap_type() const { return 2829; } /* = unique type id SOAP_TYPE___tds__GetClientCertificateMode_ */
	         __tds__GetClientCertificateMode_();
	virtual ~__tds__GetClientCertificateMode_() { }
	friend __tds__GetClientCertificateMode_ *soap_instantiate___tds__GetClientCertificateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54874 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode_
#define SOAP_TYPE___tds__SetClientCertificateMode_ (2831)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode_
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of XSD type tds:SetClientCertificateMode */
public:
	int soap_type() const { return 2831; } /* = unique type id SOAP_TYPE___tds__SetClientCertificateMode_ */
	         __tds__SetClientCertificateMode_();
	virtual ~__tds__SetClientCertificateMode_() { }
	friend __tds__SetClientCertificateMode_ *soap_instantiate___tds__SetClientCertificateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54943 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs_
#define SOAP_TYPE___tds__GetRelayOutputs_ (2833)
/* Operation wrapper: */
struct __tds__GetRelayOutputs_
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 2833; } /* = unique type id SOAP_TYPE___tds__GetRelayOutputs_ */
	         __tds__GetRelayOutputs_();
	virtual ~__tds__GetRelayOutputs_() { }
	friend __tds__GetRelayOutputs_ *soap_instantiate___tds__GetRelayOutputs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55012 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings_
#define SOAP_TYPE___tds__SetRelayOutputSettings_ (2835)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings_
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of XSD type tds:SetRelayOutputSettings */
public:
	int soap_type() const { return 2835; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputSettings_ */
	         __tds__SetRelayOutputSettings_();
	virtual ~__tds__SetRelayOutputSettings_() { }
	friend __tds__SetRelayOutputSettings_ *soap_instantiate___tds__SetRelayOutputSettings_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55081 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState_
#define SOAP_TYPE___tds__SetRelayOutputState_ (2837)
/* Operation wrapper: */
struct __tds__SetRelayOutputState_
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 2837; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputState_ */
	         __tds__SetRelayOutputState_();
	virtual ~__tds__SetRelayOutputState_() { }
	friend __tds__SetRelayOutputState_ *soap_instantiate___tds__SetRelayOutputState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55179 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand_
#define SOAP_TYPE___tds__SendAuxiliaryCommand_ (2839)
/* Operation wrapper: */
struct __tds__SendAuxiliaryCommand_
{
public:
	_tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;	/* optional element of XSD type tds:SendAuxiliaryCommand */
public:
	int soap_type() const { return 2839; } /* = unique type id SOAP_TYPE___tds__SendAuxiliaryCommand_ */
	         __tds__SendAuxiliaryCommand_();
	virtual ~__tds__SendAuxiliaryCommand_() { }
	friend __tds__SendAuxiliaryCommand_ *soap_instantiate___tds__SendAuxiliaryCommand_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55257 */
#ifndef SOAP_TYPE___tds__GetCACertificates_
#define SOAP_TYPE___tds__GetCACertificates_ (2841)
/* Operation wrapper: */
struct __tds__GetCACertificates_
{
public:
	_tds__GetCACertificates *tds__GetCACertificates;	/* optional element of XSD type tds:GetCACertificates */
public:
	int soap_type() const { return 2841; } /* = unique type id SOAP_TYPE___tds__GetCACertificates_ */
	         __tds__GetCACertificates_();
	virtual ~__tds__GetCACertificates_() { }
	friend __tds__GetCACertificates_ *soap_instantiate___tds__GetCACertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55347 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey_
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey_ (2843)
/* Operation wrapper: */
struct __tds__LoadCertificateWithPrivateKey_
{
public:
	_tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;	/* optional element of XSD type tds:LoadCertificateWithPrivateKey */
public:
	int soap_type() const { return 2843; } /* = unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey_ */
	         __tds__LoadCertificateWithPrivateKey_();
	virtual ~__tds__LoadCertificateWithPrivateKey_() { }
	friend __tds__LoadCertificateWithPrivateKey_ *soap_instantiate___tds__LoadCertificateWithPrivateKey_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55424 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation_
#define SOAP_TYPE___tds__GetCertificateInformation_ (2845)
/* Operation wrapper: */
struct __tds__GetCertificateInformation_
{
public:
	_tds__GetCertificateInformation *tds__GetCertificateInformation;	/* optional element of XSD type tds:GetCertificateInformation */
public:
	int soap_type() const { return 2845; } /* = unique type id SOAP_TYPE___tds__GetCertificateInformation_ */
	         __tds__GetCertificateInformation_();
	virtual ~__tds__GetCertificateInformation_() { }
	friend __tds__GetCertificateInformation_ *soap_instantiate___tds__GetCertificateInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55508 */
#ifndef SOAP_TYPE___tds__LoadCACertificates_
#define SOAP_TYPE___tds__LoadCACertificates_ (2847)
/* Operation wrapper: */
struct __tds__LoadCACertificates_
{
public:
	_tds__LoadCACertificates *tds__LoadCACertificates;	/* optional element of XSD type tds:LoadCACertificates */
public:
	int soap_type() const { return 2847; } /* = unique type id SOAP_TYPE___tds__LoadCACertificates_ */
	         __tds__LoadCACertificates_();
	virtual ~__tds__LoadCACertificates_() { }
	friend __tds__LoadCACertificates_ *soap_instantiate___tds__LoadCACertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55583 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration_
#define SOAP_TYPE___tds__CreateDot1XConfiguration_ (2849)
/* Operation wrapper: */
struct __tds__CreateDot1XConfiguration_
{
public:
	_tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;	/* optional element of XSD type tds:CreateDot1XConfiguration */
public:
	int soap_type() const { return 2849; } /* = unique type id SOAP_TYPE___tds__CreateDot1XConfiguration_ */
	         __tds__CreateDot1XConfiguration_();
	virtual ~__tds__CreateDot1XConfiguration_() { }
	friend __tds__CreateDot1XConfiguration_ *soap_instantiate___tds__CreateDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55654 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration_
#define SOAP_TYPE___tds__SetDot1XConfiguration_ (2851)
/* Operation wrapper: */
struct __tds__SetDot1XConfiguration_
{
public:
	_tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;	/* optional element of XSD type tds:SetDot1XConfiguration */
public:
	int soap_type() const { return 2851; } /* = unique type id SOAP_TYPE___tds__SetDot1XConfiguration_ */
	         __tds__SetDot1XConfiguration_();
	virtual ~__tds__SetDot1XConfiguration_() { }
	friend __tds__SetDot1XConfiguration_ *soap_instantiate___tds__SetDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55729 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration_
#define SOAP_TYPE___tds__GetDot1XConfiguration_ (2853)
/* Operation wrapper: */
struct __tds__GetDot1XConfiguration_
{
public:
	_tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;	/* optional element of XSD type tds:GetDot1XConfiguration */
public:
	int soap_type() const { return 2853; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfiguration_ */
	         __tds__GetDot1XConfiguration_();
	virtual ~__tds__GetDot1XConfiguration_() { }
	friend __tds__GetDot1XConfiguration_ *soap_instantiate___tds__GetDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55807 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations_
#define SOAP_TYPE___tds__GetDot1XConfigurations_ (2855)
/* Operation wrapper: */
struct __tds__GetDot1XConfigurations_
{
public:
	_tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;	/* optional element of XSD type tds:GetDot1XConfigurations */
public:
	int soap_type() const { return 2855; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfigurations_ */
	         __tds__GetDot1XConfigurations_();
	virtual ~__tds__GetDot1XConfigurations_() { }
	friend __tds__GetDot1XConfigurations_ *soap_instantiate___tds__GetDot1XConfigurations_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55879 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration_
#define SOAP_TYPE___tds__DeleteDot1XConfiguration_ (2857)
/* Operation wrapper: */
struct __tds__DeleteDot1XConfiguration_
{
public:
	_tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;	/* optional element of XSD type tds:DeleteDot1XConfiguration */
public:
	int soap_type() const { return 2857; } /* = unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration_ */
	         __tds__DeleteDot1XConfiguration_();
	virtual ~__tds__DeleteDot1XConfiguration_() { }
	friend __tds__DeleteDot1XConfiguration_ *soap_instantiate___tds__DeleteDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55947 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities_
#define SOAP_TYPE___tds__GetDot11Capabilities_ (2859)
/* Operation wrapper: */
struct __tds__GetDot11Capabilities_
{
public:
	_tds__GetDot11Capabilities *tds__GetDot11Capabilities;	/* optional element of XSD type tds:GetDot11Capabilities */
public:
	int soap_type() const { return 2859; } /* = unique type id SOAP_TYPE___tds__GetDot11Capabilities_ */
	         __tds__GetDot11Capabilities_();
	virtual ~__tds__GetDot11Capabilities_() { }
	friend __tds__GetDot11Capabilities_ *soap_instantiate___tds__GetDot11Capabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56016 */
#ifndef SOAP_TYPE___tds__GetDot11Status_
#define SOAP_TYPE___tds__GetDot11Status_ (2861)
/* Operation wrapper: */
struct __tds__GetDot11Status_
{
public:
	_tds__GetDot11Status *tds__GetDot11Status;	/* optional element of XSD type tds:GetDot11Status */
public:
	int soap_type() const { return 2861; } /* = unique type id SOAP_TYPE___tds__GetDot11Status_ */
	         __tds__GetDot11Status_();
	virtual ~__tds__GetDot11Status_() { }
	friend __tds__GetDot11Status_ *soap_instantiate___tds__GetDot11Status_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56085 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks_
#define SOAP_TYPE___tds__ScanAvailableDot11Networks_ (2863)
/* Operation wrapper: */
struct __tds__ScanAvailableDot11Networks_
{
public:
	_tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;	/* optional element of XSD type tds:ScanAvailableDot11Networks */
public:
	int soap_type() const { return 2863; } /* = unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks_ */
	         __tds__ScanAvailableDot11Networks_();
	virtual ~__tds__ScanAvailableDot11Networks_() { }
	friend __tds__ScanAvailableDot11Networks_ *soap_instantiate___tds__ScanAvailableDot11Networks_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56171 */
#ifndef SOAP_TYPE___tds__GetSystemUris_
#define SOAP_TYPE___tds__GetSystemUris_ (2865)
/* Operation wrapper: */
struct __tds__GetSystemUris_
{
public:
	_tds__GetSystemUris *tds__GetSystemUris;	/* optional element of XSD type tds:GetSystemUris */
public:
	int soap_type() const { return 2865; } /* = unique type id SOAP_TYPE___tds__GetSystemUris_ */
	         __tds__GetSystemUris_();
	virtual ~__tds__GetSystemUris_() { }
	friend __tds__GetSystemUris_ *soap_instantiate___tds__GetSystemUris_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56266 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade_
#define SOAP_TYPE___tds__StartFirmwareUpgrade_ (2867)
/* Operation wrapper: */
struct __tds__StartFirmwareUpgrade_
{
public:
	_tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;	/* optional element of XSD type tds:StartFirmwareUpgrade */
public:
	int soap_type() const { return 2867; } /* = unique type id SOAP_TYPE___tds__StartFirmwareUpgrade_ */
	         __tds__StartFirmwareUpgrade_();
	virtual ~__tds__StartFirmwareUpgrade_() { }
	friend __tds__StartFirmwareUpgrade_ *soap_instantiate___tds__StartFirmwareUpgrade_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56360 */
#ifndef SOAP_TYPE___tds__StartSystemRestore_
#define SOAP_TYPE___tds__StartSystemRestore_ (2869)
/* Operation wrapper: */
struct __tds__StartSystemRestore_
{
public:
	_tds__StartSystemRestore *tds__StartSystemRestore;	/* optional element of XSD type tds:StartSystemRestore */
public:
	int soap_type() const { return 2869; } /* = unique type id SOAP_TYPE___tds__StartSystemRestore_ */
	         __tds__StartSystemRestore_();
	virtual ~__tds__StartSystemRestore_() { }
	friend __tds__StartSystemRestore_ *soap_instantiate___tds__StartSystemRestore_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56430 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations_
#define SOAP_TYPE___tds__GetStorageConfigurations_ (2871)
/* Operation wrapper: */
struct __tds__GetStorageConfigurations_
{
public:
	_tds__GetStorageConfigurations *tds__GetStorageConfigurations;	/* optional element of XSD type tds:GetStorageConfigurations */
public:
	int soap_type() const { return 2871; } /* = unique type id SOAP_TYPE___tds__GetStorageConfigurations_ */
	         __tds__GetStorageConfigurations_();
	virtual ~__tds__GetStorageConfigurations_() { }
	friend __tds__GetStorageConfigurations_ *soap_instantiate___tds__GetStorageConfigurations_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56501 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration_
#define SOAP_TYPE___tds__CreateStorageConfiguration_ (2873)
/* Operation wrapper: */
struct __tds__CreateStorageConfiguration_
{
public:
	_tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;	/* optional element of XSD type tds:CreateStorageConfiguration */
public:
	int soap_type() const { return 2873; } /* = unique type id SOAP_TYPE___tds__CreateStorageConfiguration_ */
	         __tds__CreateStorageConfiguration_();
	virtual ~__tds__CreateStorageConfiguration_() { }
	friend __tds__CreateStorageConfiguration_ *soap_instantiate___tds__CreateStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56571 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration_
#define SOAP_TYPE___tds__GetStorageConfiguration_ (2875)
/* Operation wrapper: */
struct __tds__GetStorageConfiguration_
{
public:
	_tds__GetStorageConfiguration *tds__GetStorageConfiguration;	/* optional element of XSD type tds:GetStorageConfiguration */
public:
	int soap_type() const { return 2875; } /* = unique type id SOAP_TYPE___tds__GetStorageConfiguration_ */
	         __tds__GetStorageConfiguration_();
	virtual ~__tds__GetStorageConfiguration_() { }
	friend __tds__GetStorageConfiguration_ *soap_instantiate___tds__GetStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56640 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration_
#define SOAP_TYPE___tds__SetStorageConfiguration_ (2877)
/* Operation wrapper: */
struct __tds__SetStorageConfiguration_
{
public:
	_tds__SetStorageConfiguration *tds__SetStorageConfiguration;	/* optional element of XSD type tds:SetStorageConfiguration */
public:
	int soap_type() const { return 2877; } /* = unique type id SOAP_TYPE___tds__SetStorageConfiguration_ */
	         __tds__SetStorageConfiguration_();
	virtual ~__tds__SetStorageConfiguration_() { }
	friend __tds__SetStorageConfiguration_ *soap_instantiate___tds__SetStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56710 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration_
#define SOAP_TYPE___tds__DeleteStorageConfiguration_ (2879)
/* Operation wrapper: */
struct __tds__DeleteStorageConfiguration_
{
public:
	_tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;	/* optional element of XSD type tds:DeleteStorageConfiguration */
public:
	int soap_type() const { return 2879; } /* = unique type id SOAP_TYPE___tds__DeleteStorageConfiguration_ */
	         __tds__DeleteStorageConfiguration_();
	virtual ~__tds__DeleteStorageConfiguration_() { }
	friend __tds__DeleteStorageConfiguration_ *soap_instantiate___tds__DeleteStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56809 */
#ifndef SOAP_TYPE___tev__PullMessages
#define SOAP_TYPE___tev__PullMessages (2883)
/* Operation wrapper: */
struct __tev__PullMessages
{
public:
	_tev__PullMessages *tev__PullMessages;	/* optional element of XSD type tev:PullMessages */
public:
	int soap_type() const { return 2883; } /* = unique type id SOAP_TYPE___tev__PullMessages */
	         __tev__PullMessages();
	virtual ~__tev__PullMessages() { }
	friend __tev__PullMessages *soap_instantiate___tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56890 */
#ifndef SOAP_TYPE___tev__Seek
#define SOAP_TYPE___tev__Seek (2887)
/* Operation wrapper: */
struct __tev__Seek
{
public:
	_tev__Seek *tev__Seek;	/* optional element of XSD type tev:Seek */
public:
	int soap_type() const { return 2887; } /* = unique type id SOAP_TYPE___tev__Seek */
	         __tev__Seek();
	virtual ~__tev__Seek() { }
	friend __tev__Seek *soap_instantiate___tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56972 */
#ifndef SOAP_TYPE___tev__SetSynchronizationPoint
#define SOAP_TYPE___tev__SetSynchronizationPoint (2891)
/* Operation wrapper: */
struct __tev__SetSynchronizationPoint
{
public:
	_tev__SetSynchronizationPoint *tev__SetSynchronizationPoint;	/* optional element of XSD type tev:SetSynchronizationPoint */
public:
	int soap_type() const { return 2891; } /* = unique type id SOAP_TYPE___tev__SetSynchronizationPoint */
	         __tev__SetSynchronizationPoint();
	virtual ~__tev__SetSynchronizationPoint() { }
	friend __tev__SetSynchronizationPoint *soap_instantiate___tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57040 */
#ifndef SOAP_TYPE___tev__GetServiceCapabilities
#define SOAP_TYPE___tev__GetServiceCapabilities (2895)
/* Operation wrapper: */
struct __tev__GetServiceCapabilities
{
public:
	_tev__GetServiceCapabilities *tev__GetServiceCapabilities;	/* optional element of XSD type tev:GetServiceCapabilities */
public:
	int soap_type() const { return 2895; } /* = unique type id SOAP_TYPE___tev__GetServiceCapabilities */
	         __tev__GetServiceCapabilities();
	virtual ~__tev__GetServiceCapabilities() { }
	friend __tev__GetServiceCapabilities *soap_instantiate___tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57149 */
#ifndef SOAP_TYPE___tev__CreatePullPointSubscription
#define SOAP_TYPE___tev__CreatePullPointSubscription (2899)
/* Operation wrapper: */
struct __tev__CreatePullPointSubscription
{
public:
	_tev__CreatePullPointSubscription *tev__CreatePullPointSubscription;	/* optional element of XSD type tev:CreatePullPointSubscription */
public:
	int soap_type() const { return 2899; } /* = unique type id SOAP_TYPE___tev__CreatePullPointSubscription */
	         __tev__CreatePullPointSubscription();
	virtual ~__tev__CreatePullPointSubscription() { }
	friend __tev__CreatePullPointSubscription *soap_instantiate___tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57223 */
#ifndef SOAP_TYPE___tev__GetEventProperties
#define SOAP_TYPE___tev__GetEventProperties (2903)
/* Operation wrapper: */
struct __tev__GetEventProperties
{
public:
	_tev__GetEventProperties *tev__GetEventProperties;	/* optional element of XSD type tev:GetEventProperties */
public:
	int soap_type() const { return 2903; } /* = unique type id SOAP_TYPE___tev__GetEventProperties */
	         __tev__GetEventProperties();
	virtual ~__tev__GetEventProperties() { }
	friend __tev__GetEventProperties *soap_instantiate___tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57295 */
#ifndef SOAP_TYPE___tev__Renew
#define SOAP_TYPE___tev__Renew (2907)
/* Operation wrapper: */
struct __tev__Renew
{
public:
	_wsnt__Renew *wsnt__Renew;	/* optional element of XSD type wsnt:Renew */
public:
	int soap_type() const { return 2907; } /* = unique type id SOAP_TYPE___tev__Renew */
	         __tev__Renew();
	virtual ~__tev__Renew() { }
	friend __tev__Renew *soap_instantiate___tev__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57367 */
#ifndef SOAP_TYPE___tev__Unsubscribe
#define SOAP_TYPE___tev__Unsubscribe (2911)
/* Operation wrapper: */
struct __tev__Unsubscribe
{
public:
	_wsnt__Unsubscribe *wsnt__Unsubscribe;	/* optional element of XSD type wsnt:Unsubscribe */
public:
	int soap_type() const { return 2911; } /* = unique type id SOAP_TYPE___tev__Unsubscribe */
	         __tev__Unsubscribe();
	virtual ~__tev__Unsubscribe() { }
	friend __tev__Unsubscribe *soap_instantiate___tev__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57469 */
#ifndef SOAP_TYPE___tev__Subscribe
#define SOAP_TYPE___tev__Subscribe (2915)
/* Operation wrapper: */
struct __tev__Subscribe
{
public:
	_wsnt__Subscribe *wsnt__Subscribe;	/* optional element of XSD type wsnt:Subscribe */
public:
	int soap_type() const { return 2915; } /* = unique type id SOAP_TYPE___tev__Subscribe */
	         __tev__Subscribe();
	virtual ~__tev__Subscribe() { }
	friend __tev__Subscribe *soap_instantiate___tev__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57553 */
#ifndef SOAP_TYPE___tev__GetCurrentMessage
#define SOAP_TYPE___tev__GetCurrentMessage (2919)
/* Operation wrapper: */
struct __tev__GetCurrentMessage
{
public:
	_wsnt__GetCurrentMessage *wsnt__GetCurrentMessage;	/* optional element of XSD type wsnt:GetCurrentMessage */
public:
	int soap_type() const { return 2919; } /* = unique type id SOAP_TYPE___tev__GetCurrentMessage */
	         __tev__GetCurrentMessage();
	virtual ~__tev__GetCurrentMessage() { }
	friend __tev__GetCurrentMessage *soap_instantiate___tev__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57615 */
#ifndef SOAP_TYPE___tev__Notify
#define SOAP_TYPE___tev__Notify (2922)
/* Operation wrapper: */
struct __tev__Notify
{
public:
	_wsnt__Notify *wsnt__Notify;	/* optional element of XSD type wsnt:Notify */
public:
	int soap_type() const { return 2922; } /* = unique type id SOAP_TYPE___tev__Notify */
	         __tev__Notify();
	virtual ~__tev__Notify() { }
	friend __tev__Notify *soap_instantiate___tev__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57687 */
#ifndef SOAP_TYPE___tev__GetMessages
#define SOAP_TYPE___tev__GetMessages (2926)
/* Operation wrapper: */
struct __tev__GetMessages
{
public:
	_wsnt__GetMessages *wsnt__GetMessages;	/* optional element of XSD type wsnt:GetMessages */
public:
	int soap_type() const { return 2926; } /* = unique type id SOAP_TYPE___tev__GetMessages */
	         __tev__GetMessages();
	virtual ~__tev__GetMessages() { }
	friend __tev__GetMessages *soap_instantiate___tev__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57759 */
#ifndef SOAP_TYPE___tev__DestroyPullPoint
#define SOAP_TYPE___tev__DestroyPullPoint (2930)
/* Operation wrapper: */
struct __tev__DestroyPullPoint
{
public:
	_wsnt__DestroyPullPoint *wsnt__DestroyPullPoint;	/* optional element of XSD type wsnt:DestroyPullPoint */
public:
	int soap_type() const { return 2930; } /* = unique type id SOAP_TYPE___tev__DestroyPullPoint */
	         __tev__DestroyPullPoint();
	virtual ~__tev__DestroyPullPoint() { }
	friend __tev__DestroyPullPoint *soap_instantiate___tev__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57821 */
#ifndef SOAP_TYPE___tev__Notify_
#define SOAP_TYPE___tev__Notify_ (2932)
/* Operation wrapper: */
struct __tev__Notify_
{
public:
	_wsnt__Notify *wsnt__Notify;	/* optional element of XSD type wsnt:Notify */
public:
	int soap_type() const { return 2932; } /* = unique type id SOAP_TYPE___tev__Notify_ */
	         __tev__Notify_();
	virtual ~__tev__Notify_() { }
	friend __tev__Notify_ *soap_instantiate___tev__Notify_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57890 */
#ifndef SOAP_TYPE___tev__CreatePullPoint
#define SOAP_TYPE___tev__CreatePullPoint (2936)
/* Operation wrapper: */
struct __tev__CreatePullPoint
{
public:
	_wsnt__CreatePullPoint *wsnt__CreatePullPoint;	/* optional element of XSD type wsnt:CreatePullPoint */
public:
	int soap_type() const { return 2936; } /* = unique type id SOAP_TYPE___tev__CreatePullPoint */
	         __tev__CreatePullPoint();
	virtual ~__tev__CreatePullPoint() { }
	friend __tev__CreatePullPoint *soap_instantiate___tev__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57962 */
#ifndef SOAP_TYPE___tev__Renew_
#define SOAP_TYPE___tev__Renew_ (2938)
/* Operation wrapper: */
struct __tev__Renew_
{
public:
	_wsnt__Renew *wsnt__Renew;	/* optional element of XSD type wsnt:Renew */
public:
	int soap_type() const { return 2938; } /* = unique type id SOAP_TYPE___tev__Renew_ */
	         __tev__Renew_();
	virtual ~__tev__Renew_() { }
	friend __tev__Renew_ *soap_instantiate___tev__Renew_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58034 */
#ifndef SOAP_TYPE___tev__Unsubscribe_
#define SOAP_TYPE___tev__Unsubscribe_ (2940)
/* Operation wrapper: */
struct __tev__Unsubscribe_
{
public:
	_wsnt__Unsubscribe *wsnt__Unsubscribe;	/* optional element of XSD type wsnt:Unsubscribe */
public:
	int soap_type() const { return 2940; } /* = unique type id SOAP_TYPE___tev__Unsubscribe_ */
	         __tev__Unsubscribe_();
	virtual ~__tev__Unsubscribe_() { }
	friend __tev__Unsubscribe_ *soap_instantiate___tev__Unsubscribe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58106 */
#ifndef SOAP_TYPE___tev__PauseSubscription
#define SOAP_TYPE___tev__PauseSubscription (2944)
/* Operation wrapper: */
struct __tev__PauseSubscription
{
public:
	_wsnt__PauseSubscription *wsnt__PauseSubscription;	/* optional element of XSD type wsnt:PauseSubscription */
public:
	int soap_type() const { return 2944; } /* = unique type id SOAP_TYPE___tev__PauseSubscription */
	         __tev__PauseSubscription();
	virtual ~__tev__PauseSubscription() { }
	friend __tev__PauseSubscription *soap_instantiate___tev__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58178 */
#ifndef SOAP_TYPE___tev__ResumeSubscription
#define SOAP_TYPE___tev__ResumeSubscription (2948)
/* Operation wrapper: */
struct __tev__ResumeSubscription
{
public:
	_wsnt__ResumeSubscription *wsnt__ResumeSubscription;	/* optional element of XSD type wsnt:ResumeSubscription */
public:
	int soap_type() const { return 2948; } /* = unique type id SOAP_TYPE___tev__ResumeSubscription */
	         __tev__ResumeSubscription();
	virtual ~__tev__ResumeSubscription() { }
	friend __tev__ResumeSubscription *soap_instantiate___tev__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58264 */
#ifndef SOAP_TYPE___timg__GetServiceCapabilities
#define SOAP_TYPE___timg__GetServiceCapabilities (2952)
/* Operation wrapper: */
struct __timg__GetServiceCapabilities
{
public:
	_timg__GetServiceCapabilities *timg__GetServiceCapabilities;	/* optional element of XSD type timg:GetServiceCapabilities */
public:
	int soap_type() const { return 2952; } /* = unique type id SOAP_TYPE___timg__GetServiceCapabilities */
	         __timg__GetServiceCapabilities();
	virtual ~__timg__GetServiceCapabilities() { }
	friend __timg__GetServiceCapabilities *soap_instantiate___timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58331 */
#ifndef SOAP_TYPE___timg__GetImagingSettings
#define SOAP_TYPE___timg__GetImagingSettings (2956)
/* Operation wrapper: */
struct __timg__GetImagingSettings
{
public:
	_timg__GetImagingSettings *timg__GetImagingSettings;	/* optional element of XSD type timg:GetImagingSettings */
public:
	int soap_type() const { return 2956; } /* = unique type id SOAP_TYPE___timg__GetImagingSettings */
	         __timg__GetImagingSettings();
	virtual ~__timg__GetImagingSettings() { }
	friend __timg__GetImagingSettings *soap_instantiate___timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58398 */
#ifndef SOAP_TYPE___timg__SetImagingSettings
#define SOAP_TYPE___timg__SetImagingSettings (2960)
/* Operation wrapper: */
struct __timg__SetImagingSettings
{
public:
	_timg__SetImagingSettings *timg__SetImagingSettings;	/* optional element of XSD type timg:SetImagingSettings */
public:
	int soap_type() const { return 2960; } /* = unique type id SOAP_TYPE___timg__SetImagingSettings */
	         __timg__SetImagingSettings();
	virtual ~__timg__SetImagingSettings() { }
	friend __timg__SetImagingSettings *soap_instantiate___timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58475 */
#ifndef SOAP_TYPE___timg__GetOptions
#define SOAP_TYPE___timg__GetOptions (2964)
/* Operation wrapper: */
struct __timg__GetOptions
{
public:
	_timg__GetOptions *timg__GetOptions;	/* optional element of XSD type timg:GetOptions */
public:
	int soap_type() const { return 2964; } /* = unique type id SOAP_TYPE___timg__GetOptions */
	         __timg__GetOptions();
	virtual ~__timg__GetOptions() { }
	friend __timg__GetOptions *soap_instantiate___timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58564 */
#ifndef SOAP_TYPE___timg__Move
#define SOAP_TYPE___timg__Move (2968)
/* Operation wrapper: */
struct __timg__Move
{
public:
	_timg__Move *timg__Move;	/* optional element of XSD type timg:Move */
public:
	int soap_type() const { return 2968; } /* = unique type id SOAP_TYPE___timg__Move */
	         __timg__Move();
	virtual ~__timg__Move() { }
	friend __timg__Move *soap_instantiate___timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58634 */
#ifndef SOAP_TYPE___timg__Stop
#define SOAP_TYPE___timg__Stop (2972)
/* Operation wrapper: */
struct __timg__Stop
{
public:
	_timg__Stop *timg__Stop;	/* optional element of XSD type timg:Stop */
public:
	int soap_type() const { return 2972; } /* = unique type id SOAP_TYPE___timg__Stop */
	         __timg__Stop();
	virtual ~__timg__Stop() { }
	friend __timg__Stop *soap_instantiate___timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58703 */
#ifndef SOAP_TYPE___timg__GetStatus
#define SOAP_TYPE___timg__GetStatus (2976)
/* Operation wrapper: */
struct __timg__GetStatus
{
public:
	_timg__GetStatus *timg__GetStatus;	/* optional element of XSD type timg:GetStatus */
public:
	int soap_type() const { return 2976; } /* = unique type id SOAP_TYPE___timg__GetStatus */
	         __timg__GetStatus();
	virtual ~__timg__GetStatus() { }
	friend __timg__GetStatus *soap_instantiate___timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58770 */
#ifndef SOAP_TYPE___timg__GetMoveOptions
#define SOAP_TYPE___timg__GetMoveOptions (2980)
/* Operation wrapper: */
struct __timg__GetMoveOptions
{
public:
	_timg__GetMoveOptions *timg__GetMoveOptions;	/* optional element of XSD type timg:GetMoveOptions */
public:
	int soap_type() const { return 2980; } /* = unique type id SOAP_TYPE___timg__GetMoveOptions */
	         __timg__GetMoveOptions();
	virtual ~__timg__GetMoveOptions() { }
	friend __timg__GetMoveOptions *soap_instantiate___timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58856 */
#ifndef SOAP_TYPE___tls__GetServiceCapabilities
#define SOAP_TYPE___tls__GetServiceCapabilities (2984)
/* Operation wrapper: */
struct __tls__GetServiceCapabilities
{
public:
	_tls__GetServiceCapabilities *tls__GetServiceCapabilities;	/* optional element of XSD type tls:GetServiceCapabilities */
public:
	int soap_type() const { return 2984; } /* = unique type id SOAP_TYPE___tls__GetServiceCapabilities */
	         __tls__GetServiceCapabilities();
	virtual ~__tls__GetServiceCapabilities() { }
	friend __tls__GetServiceCapabilities *soap_instantiate___tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58927 */
#ifndef SOAP_TYPE___tls__GetLayout
#define SOAP_TYPE___tls__GetLayout (2988)
/* Operation wrapper: */
struct __tls__GetLayout
{
public:
	_tls__GetLayout *tls__GetLayout;	/* optional element of XSD type tls:GetLayout */
public:
	int soap_type() const { return 2988; } /* = unique type id SOAP_TYPE___tls__GetLayout */
	         __tls__GetLayout();
	virtual ~__tls__GetLayout() { }
	friend __tls__GetLayout *soap_instantiate___tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59003 */
#ifndef SOAP_TYPE___tls__SetLayout
#define SOAP_TYPE___tls__SetLayout (2992)
/* Operation wrapper: */
struct __tls__SetLayout
{
public:
	_tls__SetLayout *tls__SetLayout;	/* optional element of XSD type tls:SetLayout */
public:
	int soap_type() const { return 2992; } /* = unique type id SOAP_TYPE___tls__SetLayout */
	         __tls__SetLayout();
	virtual ~__tls__SetLayout() { }
	friend __tls__SetLayout *soap_instantiate___tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59074 */
#ifndef SOAP_TYPE___tls__GetDisplayOptions
#define SOAP_TYPE___tls__GetDisplayOptions (2996)
/* Operation wrapper: */
struct __tls__GetDisplayOptions
{
public:
	_tls__GetDisplayOptions *tls__GetDisplayOptions;	/* optional element of XSD type tls:GetDisplayOptions */
public:
	int soap_type() const { return 2996; } /* = unique type id SOAP_TYPE___tls__GetDisplayOptions */
	         __tls__GetDisplayOptions();
	virtual ~__tls__GetDisplayOptions() { }
	friend __tls__GetDisplayOptions *soap_instantiate___tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59149 */
#ifndef SOAP_TYPE___tls__GetPaneConfigurations
#define SOAP_TYPE___tls__GetPaneConfigurations (3000)
/* Operation wrapper: */
struct __tls__GetPaneConfigurations
{
public:
	_tls__GetPaneConfigurations *tls__GetPaneConfigurations;	/* optional element of XSD type tls:GetPaneConfigurations */
public:
	int soap_type() const { return 3000; } /* = unique type id SOAP_TYPE___tls__GetPaneConfigurations */
	         __tls__GetPaneConfigurations();
	virtual ~__tls__GetPaneConfigurations() { }
	friend __tls__GetPaneConfigurations *soap_instantiate___tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59216 */
#ifndef SOAP_TYPE___tls__GetPaneConfiguration
#define SOAP_TYPE___tls__GetPaneConfiguration (3004)
/* Operation wrapper: */
struct __tls__GetPaneConfiguration
{
public:
	_tls__GetPaneConfiguration *tls__GetPaneConfiguration;	/* optional element of XSD type tls:GetPaneConfiguration */
public:
	int soap_type() const { return 3004; } /* = unique type id SOAP_TYPE___tls__GetPaneConfiguration */
	         __tls__GetPaneConfiguration();
	virtual ~__tls__GetPaneConfiguration() { }
	friend __tls__GetPaneConfiguration *soap_instantiate___tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59287 */
#ifndef SOAP_TYPE___tls__SetPaneConfigurations
#define SOAP_TYPE___tls__SetPaneConfigurations (3008)
/* Operation wrapper: */
struct __tls__SetPaneConfigurations
{
public:
	_tls__SetPaneConfigurations *tls__SetPaneConfigurations;	/* optional element of XSD type tls:SetPaneConfigurations */
public:
	int soap_type() const { return 3008; } /* = unique type id SOAP_TYPE___tls__SetPaneConfigurations */
	         __tls__SetPaneConfigurations();
	virtual ~__tls__SetPaneConfigurations() { }
	friend __tls__SetPaneConfigurations *soap_instantiate___tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59354 */
#ifndef SOAP_TYPE___tls__SetPaneConfiguration
#define SOAP_TYPE___tls__SetPaneConfiguration (3012)
/* Operation wrapper: */
struct __tls__SetPaneConfiguration
{
public:
	_tls__SetPaneConfiguration *tls__SetPaneConfiguration;	/* optional element of XSD type tls:SetPaneConfiguration */
public:
	int soap_type() const { return 3012; } /* = unique type id SOAP_TYPE___tls__SetPaneConfiguration */
	         __tls__SetPaneConfiguration();
	virtual ~__tls__SetPaneConfiguration() { }
	friend __tls__SetPaneConfiguration *soap_instantiate___tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59427 */
#ifndef SOAP_TYPE___tls__CreatePaneConfiguration
#define SOAP_TYPE___tls__CreatePaneConfiguration (3016)
/* Operation wrapper: */
struct __tls__CreatePaneConfiguration
{
public:
	_tls__CreatePaneConfiguration *tls__CreatePaneConfiguration;	/* optional element of XSD type tls:CreatePaneConfiguration */
public:
	int soap_type() const { return 3016; } /* = unique type id SOAP_TYPE___tls__CreatePaneConfiguration */
	         __tls__CreatePaneConfiguration();
	virtual ~__tls__CreatePaneConfiguration() { }
	friend __tls__CreatePaneConfiguration *soap_instantiate___tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59498 */
#ifndef SOAP_TYPE___tls__DeletePaneConfiguration
#define SOAP_TYPE___tls__DeletePaneConfiguration (3020)
/* Operation wrapper: */
struct __tls__DeletePaneConfiguration
{
public:
	_tls__DeletePaneConfiguration *tls__DeletePaneConfiguration;	/* optional element of XSD type tls:DeletePaneConfiguration */
public:
	int soap_type() const { return 3020; } /* = unique type id SOAP_TYPE___tls__DeletePaneConfiguration */
	         __tls__DeletePaneConfiguration();
	virtual ~__tls__DeletePaneConfiguration() { }
	friend __tls__DeletePaneConfiguration *soap_instantiate___tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59584 */
#ifndef SOAP_TYPE___tmd__GetServiceCapabilities
#define SOAP_TYPE___tmd__GetServiceCapabilities (3024)
/* Operation wrapper: */
struct __tmd__GetServiceCapabilities
{
public:
	_tmd__GetServiceCapabilities *tmd__GetServiceCapabilities;	/* optional element of XSD type tmd:GetServiceCapabilities */
public:
	int soap_type() const { return 3024; } /* = unique type id SOAP_TYPE___tmd__GetServiceCapabilities */
	         __tmd__GetServiceCapabilities();
	virtual ~__tmd__GetServiceCapabilities() { }
	friend __tmd__GetServiceCapabilities *soap_instantiate___tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59676 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputOptions
#define SOAP_TYPE___tmd__GetRelayOutputOptions (3028)
/* Operation wrapper: */
struct __tmd__GetRelayOutputOptions
{
public:
	_tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions;	/* optional element of XSD type tmd:GetRelayOutputOptions */
public:
	int soap_type() const { return 3028; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputOptions */
	         __tmd__GetRelayOutputOptions();
	virtual ~__tmd__GetRelayOutputOptions() { }
	friend __tmd__GetRelayOutputOptions *soap_instantiate___tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59745 */
#ifndef SOAP_TYPE___tmd__GetAudioSources
#define SOAP_TYPE___tmd__GetAudioSources (3032)
/* Operation wrapper: */
struct __tmd__GetAudioSources
{
public:
	tmd__Get *tmd__GetAudioSources;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 3032; } /* = unique type id SOAP_TYPE___tmd__GetAudioSources */
	         __tmd__GetAudioSources();
	virtual ~__tmd__GetAudioSources() { }
	friend __tmd__GetAudioSources *soap_instantiate___tmd__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59814 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputs
#define SOAP_TYPE___tmd__GetAudioOutputs (3034)
/* Operation wrapper: */
struct __tmd__GetAudioOutputs
{
public:
	tmd__Get *tmd__GetAudioOutputs;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 3034; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputs */
	         __tmd__GetAudioOutputs();
	virtual ~__tmd__GetAudioOutputs() { }
	friend __tmd__GetAudioOutputs *soap_instantiate___tmd__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59883 */
#ifndef SOAP_TYPE___tmd__GetVideoSources
#define SOAP_TYPE___tmd__GetVideoSources (3036)
/* Operation wrapper: */
struct __tmd__GetVideoSources
{
public:
	tmd__Get *tmd__GetVideoSources;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 3036; } /* = unique type id SOAP_TYPE___tmd__GetVideoSources */
	         __tmd__GetVideoSources();
	virtual ~__tmd__GetVideoSources() { }
	friend __tmd__GetVideoSources *soap_instantiate___tmd__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59952 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputs
#define SOAP_TYPE___tmd__GetVideoOutputs (3040)
/* Operation wrapper: */
struct __tmd__GetVideoOutputs
{
public:
	_tmd__GetVideoOutputs *tmd__GetVideoOutputs;	/* optional element of XSD type tmd:GetVideoOutputs */
public:
	int soap_type() const { return 3040; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputs */
	         __tmd__GetVideoOutputs();
	virtual ~__tmd__GetVideoOutputs() { }
	friend __tmd__GetVideoOutputs *soap_instantiate___tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60020 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfiguration
#define SOAP_TYPE___tmd__GetVideoSourceConfiguration (3044)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfiguration
{
public:
	_tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration;	/* optional element of XSD type tmd:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 3044; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfiguration */
	         __tmd__GetVideoSourceConfiguration();
	virtual ~__tmd__GetVideoSourceConfiguration() { }
	friend __tmd__GetVideoSourceConfiguration *soap_instantiate___tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60088 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfiguration
#define SOAP_TYPE___tmd__GetVideoOutputConfiguration (3048)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfiguration
{
public:
	_tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration;	/* optional element of XSD type tmd:GetVideoOutputConfiguration */
public:
	int soap_type() const { return 3048; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfiguration */
	         __tmd__GetVideoOutputConfiguration();
	virtual ~__tmd__GetVideoOutputConfiguration() { }
	friend __tmd__GetVideoOutputConfiguration *soap_instantiate___tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60156 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfiguration
#define SOAP_TYPE___tmd__GetAudioSourceConfiguration (3052)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfiguration
{
public:
	_tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration;	/* optional element of XSD type tmd:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 3052; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfiguration */
	         __tmd__GetAudioSourceConfiguration();
	virtual ~__tmd__GetAudioSourceConfiguration() { }
	friend __tmd__GetAudioSourceConfiguration *soap_instantiate___tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60225 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfiguration
#define SOAP_TYPE___tmd__GetAudioOutputConfiguration (3056)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfiguration
{
public:
	_tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration;	/* optional element of XSD type tmd:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 3056; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfiguration */
	         __tmd__GetAudioOutputConfiguration();
	virtual ~__tmd__GetAudioOutputConfiguration() { }
	friend __tmd__GetAudioOutputConfiguration *soap_instantiate___tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60293 */
#ifndef SOAP_TYPE___tmd__SetVideoSourceConfiguration
#define SOAP_TYPE___tmd__SetVideoSourceConfiguration (3060)
/* Operation wrapper: */
struct __tmd__SetVideoSourceConfiguration
{
public:
	_tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration;	/* optional element of XSD type tmd:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 3060; } /* = unique type id SOAP_TYPE___tmd__SetVideoSourceConfiguration */
	         __tmd__SetVideoSourceConfiguration();
	virtual ~__tmd__SetVideoSourceConfiguration() { }
	friend __tmd__SetVideoSourceConfiguration *soap_instantiate___tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60361 */
#ifndef SOAP_TYPE___tmd__SetVideoOutputConfiguration
#define SOAP_TYPE___tmd__SetVideoOutputConfiguration (3064)
/* Operation wrapper: */
struct __tmd__SetVideoOutputConfiguration
{
public:
	_tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration;	/* optional element of XSD type tmd:SetVideoOutputConfiguration */
public:
	int soap_type() const { return 3064; } /* = unique type id SOAP_TYPE___tmd__SetVideoOutputConfiguration */
	         __tmd__SetVideoOutputConfiguration();
	virtual ~__tmd__SetVideoOutputConfiguration() { }
	friend __tmd__SetVideoOutputConfiguration *soap_instantiate___tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60429 */
#ifndef SOAP_TYPE___tmd__SetAudioSourceConfiguration
#define SOAP_TYPE___tmd__SetAudioSourceConfiguration (3068)
/* Operation wrapper: */
struct __tmd__SetAudioSourceConfiguration
{
public:
	_tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration;	/* optional element of XSD type tmd:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 3068; } /* = unique type id SOAP_TYPE___tmd__SetAudioSourceConfiguration */
	         __tmd__SetAudioSourceConfiguration();
	virtual ~__tmd__SetAudioSourceConfiguration() { }
	friend __tmd__SetAudioSourceConfiguration *soap_instantiate___tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60497 */
#ifndef SOAP_TYPE___tmd__SetAudioOutputConfiguration
#define SOAP_TYPE___tmd__SetAudioOutputConfiguration (3072)
/* Operation wrapper: */
struct __tmd__SetAudioOutputConfiguration
{
public:
	_tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration;	/* optional element of XSD type tmd:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 3072; } /* = unique type id SOAP_TYPE___tmd__SetAudioOutputConfiguration */
	         __tmd__SetAudioOutputConfiguration();
	virtual ~__tmd__SetAudioOutputConfiguration() { }
	friend __tmd__SetAudioOutputConfiguration *soap_instantiate___tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60565 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions (3076)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfigurationOptions
{
public:
	_tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions;	/* optional element of XSD type tmd:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 3076; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions */
	         __tmd__GetVideoSourceConfigurationOptions();
	virtual ~__tmd__GetVideoSourceConfigurationOptions() { }
	friend __tmd__GetVideoSourceConfigurationOptions *soap_instantiate___tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60634 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions (3080)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfigurationOptions
{
public:
	_tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions;	/* optional element of XSD type tmd:GetVideoOutputConfigurationOptions */
public:
	int soap_type() const { return 3080; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions */
	         __tmd__GetVideoOutputConfigurationOptions();
	virtual ~__tmd__GetVideoOutputConfigurationOptions() { }
	friend __tmd__GetVideoOutputConfigurationOptions *soap_instantiate___tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60702 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions (3084)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfigurationOptions
{
public:
	_tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions;	/* optional element of XSD type tmd:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 3084; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions */
	         __tmd__GetAudioSourceConfigurationOptions();
	virtual ~__tmd__GetAudioSourceConfigurationOptions() { }
	friend __tmd__GetAudioSourceConfigurationOptions *soap_instantiate___tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60770 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions (3088)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfigurationOptions
{
public:
	_tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions;	/* optional element of XSD type tmd:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 3088; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions */
	         __tmd__GetAudioOutputConfigurationOptions();
	virtual ~__tmd__GetAudioOutputConfigurationOptions() { }
	friend __tmd__GetAudioOutputConfigurationOptions *soap_instantiate___tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60837 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputs
#define SOAP_TYPE___tmd__GetRelayOutputs (3090)
/* Operation wrapper: */
struct __tmd__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 3090; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputs */
	         __tmd__GetRelayOutputs();
	virtual ~__tmd__GetRelayOutputs() { }
	friend __tmd__GetRelayOutputs *soap_instantiate___tmd__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60926 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputSettings
#define SOAP_TYPE___tmd__SetRelayOutputSettings (3094)
/* Operation wrapper: */
struct __tmd__SetRelayOutputSettings
{
public:
	_tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings;	/* optional element of XSD type tmd:SetRelayOutputSettings */
public:
	int soap_type() const { return 3094; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputSettings */
	         __tmd__SetRelayOutputSettings();
	virtual ~__tmd__SetRelayOutputSettings() { }
	friend __tmd__SetRelayOutputSettings *soap_instantiate___tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60993 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputState
#define SOAP_TYPE___tmd__SetRelayOutputState (3096)
/* Operation wrapper: */
struct __tmd__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 3096; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputState */
	         __tmd__SetRelayOutputState();
	virtual ~__tmd__SetRelayOutputState() { }
	friend __tmd__SetRelayOutputState *soap_instantiate___tmd__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61060 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputs
#define SOAP_TYPE___tmd__GetDigitalInputs (3100)
/* Operation wrapper: */
struct __tmd__GetDigitalInputs
{
public:
	_tmd__GetDigitalInputs *tmd__GetDigitalInputs;	/* optional element of XSD type tmd:GetDigitalInputs */
public:
	int soap_type() const { return 3100; } /* = unique type id SOAP_TYPE___tmd__GetDigitalInputs */
	         __tmd__GetDigitalInputs();
	virtual ~__tmd__GetDigitalInputs() { }
	friend __tmd__GetDigitalInputs *soap_instantiate___tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61127 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions (3104)
/* Operation wrapper: */
struct __tmd__GetDigitalInputConfigurationOptions
{
public:
	_tmd__GetDigitalInputConfigurationOptions *tmd__GetDigitalInputConfigurationOptions;	/* optional element of XSD type tmd:GetDigitalInputConfigurationOptions */
public:
	int soap_type() const { return 3104; } /* = unique type id SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions */
	         __tmd__GetDigitalInputConfigurationOptions();
	virtual ~__tmd__GetDigitalInputConfigurationOptions() { }
	friend __tmd__GetDigitalInputConfigurationOptions *soap_instantiate___tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61194 */
#ifndef SOAP_TYPE___tmd__SetDigitalInputConfigurations
#define SOAP_TYPE___tmd__SetDigitalInputConfigurations (3108)
/* Operation wrapper: */
struct __tmd__SetDigitalInputConfigurations
{
public:
	_tmd__SetDigitalInputConfigurations *tmd__SetDigitalInputConfigurations;	/* optional element of XSD type tmd:SetDigitalInputConfigurations */
public:
	int soap_type() const { return 3108; } /* = unique type id SOAP_TYPE___tmd__SetDigitalInputConfigurations */
	         __tmd__SetDigitalInputConfigurations();
	virtual ~__tmd__SetDigitalInputConfigurations() { }
	friend __tmd__SetDigitalInputConfigurations *soap_instantiate___tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61260 */
#ifndef SOAP_TYPE___tmd__GetSerialPorts
#define SOAP_TYPE___tmd__GetSerialPorts (3112)
/* Operation wrapper: */
struct __tmd__GetSerialPorts
{
public:
	_tmd__GetSerialPorts *tmd__GetSerialPorts;	/* optional element of XSD type tmd:GetSerialPorts */
public:
	int soap_type() const { return 3112; } /* = unique type id SOAP_TYPE___tmd__GetSerialPorts */
	         __tmd__GetSerialPorts();
	virtual ~__tmd__GetSerialPorts() { }
	friend __tmd__GetSerialPorts *soap_instantiate___tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61326 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfiguration
#define SOAP_TYPE___tmd__GetSerialPortConfiguration (3116)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfiguration
{
public:
	_tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration;	/* optional element of XSD type tmd:GetSerialPortConfiguration */
public:
	int soap_type() const { return 3116; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfiguration */
	         __tmd__GetSerialPortConfiguration();
	virtual ~__tmd__GetSerialPortConfiguration() { }
	friend __tmd__GetSerialPortConfiguration *soap_instantiate___tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61392 */
#ifndef SOAP_TYPE___tmd__SetSerialPortConfiguration
#define SOAP_TYPE___tmd__SetSerialPortConfiguration (3120)
/* Operation wrapper: */
struct __tmd__SetSerialPortConfiguration
{
public:
	_tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration;	/* optional element of XSD type tmd:SetSerialPortConfiguration */
public:
	int soap_type() const { return 3120; } /* = unique type id SOAP_TYPE___tmd__SetSerialPortConfiguration */
	         __tmd__SetSerialPortConfiguration();
	virtual ~__tmd__SetSerialPortConfiguration() { }
	friend __tmd__SetSerialPortConfiguration *soap_instantiate___tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61458 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE___tmd__GetSerialPortConfigurationOptions (3124)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfigurationOptions
{
public:
	_tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions;	/* optional element of XSD type tmd:GetSerialPortConfigurationOptions */
public:
	int soap_type() const { return 3124; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfigurationOptions */
	         __tmd__GetSerialPortConfigurationOptions();
	virtual ~__tmd__GetSerialPortConfigurationOptions() { }
	friend __tmd__GetSerialPortConfigurationOptions *soap_instantiate___tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61524 */
#ifndef SOAP_TYPE___tmd__SendReceiveSerialCommand
#define SOAP_TYPE___tmd__SendReceiveSerialCommand (3128)
/* Operation wrapper: */
struct __tmd__SendReceiveSerialCommand
{
public:
	_tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand;	/* optional element of XSD type tmd:SendReceiveSerialCommand */
public:
	int soap_type() const { return 3128; } /* = unique type id SOAP_TYPE___tmd__SendReceiveSerialCommand */
	         __tmd__SendReceiveSerialCommand();
	virtual ~__tmd__SendReceiveSerialCommand() { }
	friend __tmd__SendReceiveSerialCommand *soap_instantiate___tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61609 */
#ifndef SOAP_TYPE___tptz__GetServiceCapabilities
#define SOAP_TYPE___tptz__GetServiceCapabilities (3132)
/* Operation wrapper: */
struct __tptz__GetServiceCapabilities
{
public:
	_tptz__GetServiceCapabilities *tptz__GetServiceCapabilities;	/* optional element of XSD type tptz:GetServiceCapabilities */
public:
	int soap_type() const { return 3132; } /* = unique type id SOAP_TYPE___tptz__GetServiceCapabilities */
	         __tptz__GetServiceCapabilities();
	virtual ~__tptz__GetServiceCapabilities() { }
	friend __tptz__GetServiceCapabilities *soap_instantiate___tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61705 */
#ifndef SOAP_TYPE___tptz__GetConfigurations
#define SOAP_TYPE___tptz__GetConfigurations (3136)
/* Operation wrapper: */
struct __tptz__GetConfigurations
{
public:
	_tptz__GetConfigurations *tptz__GetConfigurations;	/* optional element of XSD type tptz:GetConfigurations */
public:
	int soap_type() const { return 3136; } /* = unique type id SOAP_TYPE___tptz__GetConfigurations */
	         __tptz__GetConfigurations();
	virtual ~__tptz__GetConfigurations() { }
	friend __tptz__GetConfigurations *soap_instantiate___tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61775 */
#ifndef SOAP_TYPE___tptz__GetPresets
#define SOAP_TYPE___tptz__GetPresets (3140)
/* Operation wrapper: */
struct __tptz__GetPresets
{
public:
	_tptz__GetPresets *tptz__GetPresets;	/* optional element of XSD type tptz:GetPresets */
public:
	int soap_type() const { return 3140; } /* = unique type id SOAP_TYPE___tptz__GetPresets */
	         __tptz__GetPresets();
	virtual ~__tptz__GetPresets() { }
	friend __tptz__GetPresets *soap_instantiate___tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61860 */
#ifndef SOAP_TYPE___tptz__SetPreset
#define SOAP_TYPE___tptz__SetPreset (3144)
/* Operation wrapper: */
struct __tptz__SetPreset
{
public:
	_tptz__SetPreset *tptz__SetPreset;	/* optional element of XSD type tptz:SetPreset */
public:
	int soap_type() const { return 3144; } /* = unique type id SOAP_TYPE___tptz__SetPreset */
	         __tptz__SetPreset();
	virtual ~__tptz__SetPreset() { }
	friend __tptz__SetPreset *soap_instantiate___tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61934 */
#ifndef SOAP_TYPE___tptz__RemovePreset
#define SOAP_TYPE___tptz__RemovePreset (3148)
/* Operation wrapper: */
struct __tptz__RemovePreset
{
public:
	_tptz__RemovePreset *tptz__RemovePreset;	/* optional element of XSD type tptz:RemovePreset */
public:
	int soap_type() const { return 3148; } /* = unique type id SOAP_TYPE___tptz__RemovePreset */
	         __tptz__RemovePreset();
	virtual ~__tptz__RemovePreset() { }
	friend __tptz__RemovePreset *soap_instantiate___tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62004 */
#ifndef SOAP_TYPE___tptz__GotoPreset
#define SOAP_TYPE___tptz__GotoPreset (3152)
/* Operation wrapper: */
struct __tptz__GotoPreset
{
public:
	_tptz__GotoPreset *tptz__GotoPreset;	/* optional element of XSD type tptz:GotoPreset */
public:
	int soap_type() const { return 3152; } /* = unique type id SOAP_TYPE___tptz__GotoPreset */
	         __tptz__GotoPreset();
	virtual ~__tptz__GotoPreset() { }
	friend __tptz__GotoPreset *soap_instantiate___tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62074 */
#ifndef SOAP_TYPE___tptz__GetStatus
#define SOAP_TYPE___tptz__GetStatus (3156)
/* Operation wrapper: */
struct __tptz__GetStatus
{
public:
	_tptz__GetStatus *tptz__GetStatus;	/* optional element of XSD type tptz:GetStatus */
public:
	int soap_type() const { return 3156; } /* = unique type id SOAP_TYPE___tptz__GetStatus */
	         __tptz__GetStatus();
	virtual ~__tptz__GetStatus() { }
	friend __tptz__GetStatus *soap_instantiate___tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62170 */
#ifndef SOAP_TYPE___tptz__GetConfiguration
#define SOAP_TYPE___tptz__GetConfiguration (3160)
/* Operation wrapper: */
struct __tptz__GetConfiguration
{
public:
	_tptz__GetConfiguration *tptz__GetConfiguration;	/* optional element of XSD type tptz:GetConfiguration */
public:
	int soap_type() const { return 3160; } /* = unique type id SOAP_TYPE___tptz__GetConfiguration */
	         __tptz__GetConfiguration();
	virtual ~__tptz__GetConfiguration() { }
	friend __tptz__GetConfiguration *soap_instantiate___tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62248 */
#ifndef SOAP_TYPE___tptz__GetNodes
#define SOAP_TYPE___tptz__GetNodes (3164)
/* Operation wrapper: */
struct __tptz__GetNodes
{
public:
	_tptz__GetNodes *tptz__GetNodes;	/* optional element of XSD type tptz:GetNodes */
public:
	int soap_type() const { return 3164; } /* = unique type id SOAP_TYPE___tptz__GetNodes */
	         __tptz__GetNodes();
	virtual ~__tptz__GetNodes() { }
	friend __tptz__GetNodes *soap_instantiate___tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62317 */
#ifndef SOAP_TYPE___tptz__GetNode
#define SOAP_TYPE___tptz__GetNode (3168)
/* Operation wrapper: */
struct __tptz__GetNode
{
public:
	_tptz__GetNode *tptz__GetNode;	/* optional element of XSD type tptz:GetNode */
public:
	int soap_type() const { return 3168; } /* = unique type id SOAP_TYPE___tptz__GetNode */
	         __tptz__GetNode();
	virtual ~__tptz__GetNode() { }
	friend __tptz__GetNode *soap_instantiate___tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62386 */
#ifndef SOAP_TYPE___tptz__SetConfiguration
#define SOAP_TYPE___tptz__SetConfiguration (3172)
/* Operation wrapper: */
struct __tptz__SetConfiguration
{
public:
	_tptz__SetConfiguration *tptz__SetConfiguration;	/* optional element of XSD type tptz:SetConfiguration */
public:
	int soap_type() const { return 3172; } /* = unique type id SOAP_TYPE___tptz__SetConfiguration */
	         __tptz__SetConfiguration();
	virtual ~__tptz__SetConfiguration() { }
	friend __tptz__SetConfiguration *soap_instantiate___tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62465 */
#ifndef SOAP_TYPE___tptz__GetConfigurationOptions
#define SOAP_TYPE___tptz__GetConfigurationOptions (3176)
/* Operation wrapper: */
struct __tptz__GetConfigurationOptions
{
public:
	_tptz__GetConfigurationOptions *tptz__GetConfigurationOptions;	/* optional element of XSD type tptz:GetConfigurationOptions */
public:
	int soap_type() const { return 3176; } /* = unique type id SOAP_TYPE___tptz__GetConfigurationOptions */
	         __tptz__GetConfigurationOptions();
	virtual ~__tptz__GetConfigurationOptions() { }
	friend __tptz__GetConfigurationOptions *soap_instantiate___tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62534 */
#ifndef SOAP_TYPE___tptz__GotoHomePosition
#define SOAP_TYPE___tptz__GotoHomePosition (3180)
/* Operation wrapper: */
struct __tptz__GotoHomePosition
{
public:
	_tptz__GotoHomePosition *tptz__GotoHomePosition;	/* optional element of XSD type tptz:GotoHomePosition */
public:
	int soap_type() const { return 3180; } /* = unique type id SOAP_TYPE___tptz__GotoHomePosition */
	         __tptz__GotoHomePosition();
	virtual ~__tptz__GotoHomePosition() { }
	friend __tptz__GotoHomePosition *soap_instantiate___tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62606 */
#ifndef SOAP_TYPE___tptz__SetHomePosition
#define SOAP_TYPE___tptz__SetHomePosition (3184)
/* Operation wrapper: */
struct __tptz__SetHomePosition
{
public:
	_tptz__SetHomePosition *tptz__SetHomePosition;	/* optional element of XSD type tptz:SetHomePosition */
public:
	int soap_type() const { return 3184; } /* = unique type id SOAP_TYPE___tptz__SetHomePosition */
	         __tptz__SetHomePosition();
	virtual ~__tptz__SetHomePosition() { }
	friend __tptz__SetHomePosition *soap_instantiate___tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62676 */
#ifndef SOAP_TYPE___tptz__ContinuousMove
#define SOAP_TYPE___tptz__ContinuousMove (3188)
/* Operation wrapper: */
struct __tptz__ContinuousMove
{
public:
	_tptz__ContinuousMove *tptz__ContinuousMove;	/* optional element of XSD type tptz:ContinuousMove */
public:
	int soap_type() const { return 3188; } /* = unique type id SOAP_TYPE___tptz__ContinuousMove */
	         __tptz__ContinuousMove();
	virtual ~__tptz__ContinuousMove() { }
	friend __tptz__ContinuousMove *soap_instantiate___tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62751 */
#ifndef SOAP_TYPE___tptz__RelativeMove
#define SOAP_TYPE___tptz__RelativeMove (3192)
/* Operation wrapper: */
struct __tptz__RelativeMove
{
public:
	_tptz__RelativeMove *tptz__RelativeMove;	/* optional element of XSD type tptz:RelativeMove */
public:
	int soap_type() const { return 3192; } /* = unique type id SOAP_TYPE___tptz__RelativeMove */
	         __tptz__RelativeMove();
	virtual ~__tptz__RelativeMove() { }
	friend __tptz__RelativeMove *soap_instantiate___tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62823 */
#ifndef SOAP_TYPE___tptz__SendAuxiliaryCommand
#define SOAP_TYPE___tptz__SendAuxiliaryCommand (3196)
/* Operation wrapper: */
struct __tptz__SendAuxiliaryCommand
{
public:
	_tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand;	/* optional element of XSD type tptz:SendAuxiliaryCommand */
public:
	int soap_type() const { return 3196; } /* = unique type id SOAP_TYPE___tptz__SendAuxiliaryCommand */
	         __tptz__SendAuxiliaryCommand();
	virtual ~__tptz__SendAuxiliaryCommand() { }
	friend __tptz__SendAuxiliaryCommand *soap_instantiate___tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62897 */
#ifndef SOAP_TYPE___tptz__AbsoluteMove
#define SOAP_TYPE___tptz__AbsoluteMove (3200)
/* Operation wrapper: */
struct __tptz__AbsoluteMove
{
public:
	_tptz__AbsoluteMove *tptz__AbsoluteMove;	/* optional element of XSD type tptz:AbsoluteMove */
public:
	int soap_type() const { return 3200; } /* = unique type id SOAP_TYPE___tptz__AbsoluteMove */
	         __tptz__AbsoluteMove();
	virtual ~__tptz__AbsoluteMove() { }
	friend __tptz__AbsoluteMove *soap_instantiate___tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62967 */
#ifndef SOAP_TYPE___tptz__Stop
#define SOAP_TYPE___tptz__Stop (3204)
/* Operation wrapper: */
struct __tptz__Stop
{
public:
	_tptz__Stop *tptz__Stop;	/* optional element of XSD type tptz:Stop */
public:
	int soap_type() const { return 3204; } /* = unique type id SOAP_TYPE___tptz__Stop */
	         __tptz__Stop();
	virtual ~__tptz__Stop() { }
	friend __tptz__Stop *soap_instantiate___tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63034 */
#ifndef SOAP_TYPE___tptz__GetPresetTours
#define SOAP_TYPE___tptz__GetPresetTours (3208)
/* Operation wrapper: */
struct __tptz__GetPresetTours
{
public:
	_tptz__GetPresetTours *tptz__GetPresetTours;	/* optional element of XSD type tptz:GetPresetTours */
public:
	int soap_type() const { return 3208; } /* = unique type id SOAP_TYPE___tptz__GetPresetTours */
	         __tptz__GetPresetTours();
	virtual ~__tptz__GetPresetTours() { }
	friend __tptz__GetPresetTours *soap_instantiate___tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63101 */
#ifndef SOAP_TYPE___tptz__GetPresetTour
#define SOAP_TYPE___tptz__GetPresetTour (3212)
/* Operation wrapper: */
struct __tptz__GetPresetTour
{
public:
	_tptz__GetPresetTour *tptz__GetPresetTour;	/* optional element of XSD type tptz:GetPresetTour */
public:
	int soap_type() const { return 3212; } /* = unique type id SOAP_TYPE___tptz__GetPresetTour */
	         __tptz__GetPresetTour();
	virtual ~__tptz__GetPresetTour() { }
	friend __tptz__GetPresetTour *soap_instantiate___tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63168 */
#ifndef SOAP_TYPE___tptz__GetPresetTourOptions
#define SOAP_TYPE___tptz__GetPresetTourOptions (3216)
/* Operation wrapper: */
struct __tptz__GetPresetTourOptions
{
public:
	_tptz__GetPresetTourOptions *tptz__GetPresetTourOptions;	/* optional element of XSD type tptz:GetPresetTourOptions */
public:
	int soap_type() const { return 3216; } /* = unique type id SOAP_TYPE___tptz__GetPresetTourOptions */
	         __tptz__GetPresetTourOptions();
	virtual ~__tptz__GetPresetTourOptions() { }
	friend __tptz__GetPresetTourOptions *soap_instantiate___tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63235 */
#ifndef SOAP_TYPE___tptz__CreatePresetTour
#define SOAP_TYPE___tptz__CreatePresetTour (3220)
/* Operation wrapper: */
struct __tptz__CreatePresetTour
{
public:
	_tptz__CreatePresetTour *tptz__CreatePresetTour;	/* optional element of XSD type tptz:CreatePresetTour */
public:
	int soap_type() const { return 3220; } /* = unique type id SOAP_TYPE___tptz__CreatePresetTour */
	         __tptz__CreatePresetTour();
	virtual ~__tptz__CreatePresetTour() { }
	friend __tptz__CreatePresetTour *soap_instantiate___tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63302 */
#ifndef SOAP_TYPE___tptz__ModifyPresetTour
#define SOAP_TYPE___tptz__ModifyPresetTour (3224)
/* Operation wrapper: */
struct __tptz__ModifyPresetTour
{
public:
	_tptz__ModifyPresetTour *tptz__ModifyPresetTour;	/* optional element of XSD type tptz:ModifyPresetTour */
public:
	int soap_type() const { return 3224; } /* = unique type id SOAP_TYPE___tptz__ModifyPresetTour */
	         __tptz__ModifyPresetTour();
	virtual ~__tptz__ModifyPresetTour() { }
	friend __tptz__ModifyPresetTour *soap_instantiate___tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63369 */
#ifndef SOAP_TYPE___tptz__OperatePresetTour
#define SOAP_TYPE___tptz__OperatePresetTour (3228)
/* Operation wrapper: */
struct __tptz__OperatePresetTour
{
public:
	_tptz__OperatePresetTour *tptz__OperatePresetTour;	/* optional element of XSD type tptz:OperatePresetTour */
public:
	int soap_type() const { return 3228; } /* = unique type id SOAP_TYPE___tptz__OperatePresetTour */
	         __tptz__OperatePresetTour();
	virtual ~__tptz__OperatePresetTour() { }
	friend __tptz__OperatePresetTour *soap_instantiate___tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63436 */
#ifndef SOAP_TYPE___tptz__RemovePresetTour
#define SOAP_TYPE___tptz__RemovePresetTour (3232)
/* Operation wrapper: */
struct __tptz__RemovePresetTour
{
public:
	_tptz__RemovePresetTour *tptz__RemovePresetTour;	/* optional element of XSD type tptz:RemovePresetTour */
public:
	int soap_type() const { return 3232; } /* = unique type id SOAP_TYPE___tptz__RemovePresetTour */
	         __tptz__RemovePresetTour();
	virtual ~__tptz__RemovePresetTour() { }
	friend __tptz__RemovePresetTour *soap_instantiate___tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63511 */
#ifndef SOAP_TYPE___tptz__GetCompatibleConfigurations
#define SOAP_TYPE___tptz__GetCompatibleConfigurations (3236)
/* Operation wrapper: */
struct __tptz__GetCompatibleConfigurations
{
public:
	_tptz__GetCompatibleConfigurations *tptz__GetCompatibleConfigurations;	/* optional element of XSD type tptz:GetCompatibleConfigurations */
public:
	int soap_type() const { return 3236; } /* = unique type id SOAP_TYPE___tptz__GetCompatibleConfigurations */
	         __tptz__GetCompatibleConfigurations();
	virtual ~__tptz__GetCompatibleConfigurations() { }
	friend __tptz__GetCompatibleConfigurations *soap_instantiate___tptz__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63597 */
#ifndef SOAP_TYPE___trc__GetServiceCapabilities
#define SOAP_TYPE___trc__GetServiceCapabilities (3240)
/* Operation wrapper: */
struct __trc__GetServiceCapabilities
{
public:
	_trc__GetServiceCapabilities *trc__GetServiceCapabilities;	/* optional element of XSD type trc:GetServiceCapabilities */
public:
	int soap_type() const { return 3240; } /* = unique type id SOAP_TYPE___trc__GetServiceCapabilities */
	         __trc__GetServiceCapabilities();
	virtual ~__trc__GetServiceCapabilities() { }
	friend __trc__GetServiceCapabilities *soap_instantiate___trc__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63684 */
#ifndef SOAP_TYPE___trc__CreateRecording
#define SOAP_TYPE___trc__CreateRecording (3244)
/* Operation wrapper: */
struct __trc__CreateRecording
{
public:
	_trc__CreateRecording *trc__CreateRecording;	/* optional element of XSD type trc:CreateRecording */
public:
	int soap_type() const { return 3244; } /* = unique type id SOAP_TYPE___trc__CreateRecording */
	         __trc__CreateRecording();
	virtual ~__trc__CreateRecording() { }
	friend __trc__CreateRecording *soap_instantiate___trc__CreateRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63764 */
#ifndef SOAP_TYPE___trc__DeleteRecording
#define SOAP_TYPE___trc__DeleteRecording (3248)
/* Operation wrapper: */
struct __trc__DeleteRecording
{
public:
	_trc__DeleteRecording *trc__DeleteRecording;	/* optional element of XSD type trc:DeleteRecording */
public:
	int soap_type() const { return 3248; } /* = unique type id SOAP_TYPE___trc__DeleteRecording */
	         __trc__DeleteRecording();
	virtual ~__trc__DeleteRecording() { }
	friend __trc__DeleteRecording *soap_instantiate___trc__DeleteRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63834 */
#ifndef SOAP_TYPE___trc__GetRecordings
#define SOAP_TYPE___trc__GetRecordings (3252)
/* Operation wrapper: */
struct __trc__GetRecordings
{
public:
	_trc__GetRecordings *trc__GetRecordings;	/* optional element of XSD type trc:GetRecordings */
public:
	int soap_type() const { return 3252; } /* = unique type id SOAP_TYPE___trc__GetRecordings */
	         __trc__GetRecordings();
	virtual ~__trc__GetRecordings() { }
	friend __trc__GetRecordings *soap_instantiate___trc__GetRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63901 */
#ifndef SOAP_TYPE___trc__SetRecordingConfiguration
#define SOAP_TYPE___trc__SetRecordingConfiguration (3256)
/* Operation wrapper: */
struct __trc__SetRecordingConfiguration
{
public:
	_trc__SetRecordingConfiguration *trc__SetRecordingConfiguration;	/* optional element of XSD type trc:SetRecordingConfiguration */
public:
	int soap_type() const { return 3256; } /* = unique type id SOAP_TYPE___trc__SetRecordingConfiguration */
	         __trc__SetRecordingConfiguration();
	virtual ~__trc__SetRecordingConfiguration() { }
	friend __trc__SetRecordingConfiguration *soap_instantiate___trc__SetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63968 */
#ifndef SOAP_TYPE___trc__GetRecordingConfiguration
#define SOAP_TYPE___trc__GetRecordingConfiguration (3260)
/* Operation wrapper: */
struct __trc__GetRecordingConfiguration
{
public:
	_trc__GetRecordingConfiguration *trc__GetRecordingConfiguration;	/* optional element of XSD type trc:GetRecordingConfiguration */
public:
	int soap_type() const { return 3260; } /* = unique type id SOAP_TYPE___trc__GetRecordingConfiguration */
	         __trc__GetRecordingConfiguration();
	virtual ~__trc__GetRecordingConfiguration() { }
	friend __trc__GetRecordingConfiguration *soap_instantiate___trc__GetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64037 */
#ifndef SOAP_TYPE___trc__GetRecordingOptions
#define SOAP_TYPE___trc__GetRecordingOptions (3264)
/* Operation wrapper: */
struct __trc__GetRecordingOptions
{
public:
	_trc__GetRecordingOptions *trc__GetRecordingOptions;	/* optional element of XSD type trc:GetRecordingOptions */
public:
	int soap_type() const { return 3264; } /* = unique type id SOAP_TYPE___trc__GetRecordingOptions */
	         __trc__GetRecordingOptions();
	virtual ~__trc__GetRecordingOptions() { }
	friend __trc__GetRecordingOptions *soap_instantiate___trc__GetRecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64110 */
#ifndef SOAP_TYPE___trc__CreateTrack
#define SOAP_TYPE___trc__CreateTrack (3268)
/* Operation wrapper: */
struct __trc__CreateTrack
{
public:
	_trc__CreateTrack *trc__CreateTrack;	/* optional element of XSD type trc:CreateTrack */
public:
	int soap_type() const { return 3268; } /* = unique type id SOAP_TYPE___trc__CreateTrack */
	         __trc__CreateTrack();
	virtual ~__trc__CreateTrack() { }
	friend __trc__CreateTrack *soap_instantiate___trc__CreateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64181 */
#ifndef SOAP_TYPE___trc__DeleteTrack
#define SOAP_TYPE___trc__DeleteTrack (3272)
/* Operation wrapper: */
struct __trc__DeleteTrack
{
public:
	_trc__DeleteTrack *trc__DeleteTrack;	/* optional element of XSD type trc:DeleteTrack */
public:
	int soap_type() const { return 3272; } /* = unique type id SOAP_TYPE___trc__DeleteTrack */
	         __trc__DeleteTrack();
	virtual ~__trc__DeleteTrack() { }
	friend __trc__DeleteTrack *soap_instantiate___trc__DeleteTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64248 */
#ifndef SOAP_TYPE___trc__GetTrackConfiguration
#define SOAP_TYPE___trc__GetTrackConfiguration (3276)
/* Operation wrapper: */
struct __trc__GetTrackConfiguration
{
public:
	_trc__GetTrackConfiguration *trc__GetTrackConfiguration;	/* optional element of XSD type trc:GetTrackConfiguration */
public:
	int soap_type() const { return 3276; } /* = unique type id SOAP_TYPE___trc__GetTrackConfiguration */
	         __trc__GetTrackConfiguration();
	virtual ~__trc__GetTrackConfiguration() { }
	friend __trc__GetTrackConfiguration *soap_instantiate___trc__GetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64315 */
#ifndef SOAP_TYPE___trc__SetTrackConfiguration
#define SOAP_TYPE___trc__SetTrackConfiguration (3280)
/* Operation wrapper: */
struct __trc__SetTrackConfiguration
{
public:
	_trc__SetTrackConfiguration *trc__SetTrackConfiguration;	/* optional element of XSD type trc:SetTrackConfiguration */
public:
	int soap_type() const { return 3280; } /* = unique type id SOAP_TYPE___trc__SetTrackConfiguration */
	         __trc__SetTrackConfiguration();
	virtual ~__trc__SetTrackConfiguration() { }
	friend __trc__SetTrackConfiguration *soap_instantiate___trc__SetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64390 */
#ifndef SOAP_TYPE___trc__CreateRecordingJob
#define SOAP_TYPE___trc__CreateRecordingJob (3284)
/* Operation wrapper: */
struct __trc__CreateRecordingJob
{
public:
	_trc__CreateRecordingJob *trc__CreateRecordingJob;	/* optional element of XSD type trc:CreateRecordingJob */
public:
	int soap_type() const { return 3284; } /* = unique type id SOAP_TYPE___trc__CreateRecordingJob */
	         __trc__CreateRecordingJob();
	virtual ~__trc__CreateRecordingJob() { }
	friend __trc__CreateRecordingJob *soap_instantiate___trc__CreateRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64463 */
#ifndef SOAP_TYPE___trc__DeleteRecordingJob
#define SOAP_TYPE___trc__DeleteRecordingJob (3288)
/* Operation wrapper: */
struct __trc__DeleteRecordingJob
{
public:
	_trc__DeleteRecordingJob *trc__DeleteRecordingJob;	/* optional element of XSD type trc:DeleteRecordingJob */
public:
	int soap_type() const { return 3288; } /* = unique type id SOAP_TYPE___trc__DeleteRecordingJob */
	         __trc__DeleteRecordingJob();
	virtual ~__trc__DeleteRecordingJob() { }
	friend __trc__DeleteRecordingJob *soap_instantiate___trc__DeleteRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64530 */
#ifndef SOAP_TYPE___trc__GetRecordingJobs
#define SOAP_TYPE___trc__GetRecordingJobs (3292)
/* Operation wrapper: */
struct __trc__GetRecordingJobs
{
public:
	_trc__GetRecordingJobs *trc__GetRecordingJobs;	/* optional element of XSD type trc:GetRecordingJobs */
public:
	int soap_type() const { return 3292; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobs */
	         __trc__GetRecordingJobs();
	virtual ~__trc__GetRecordingJobs() { }
	friend __trc__GetRecordingJobs *soap_instantiate___trc__GetRecordingJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64602 */
#ifndef SOAP_TYPE___trc__SetRecordingJobConfiguration
#define SOAP_TYPE___trc__SetRecordingJobConfiguration (3296)
/* Operation wrapper: */
struct __trc__SetRecordingJobConfiguration
{
public:
	_trc__SetRecordingJobConfiguration *trc__SetRecordingJobConfiguration;	/* optional element of XSD type trc:SetRecordingJobConfiguration */
public:
	int soap_type() const { return 3296; } /* = unique type id SOAP_TYPE___trc__SetRecordingJobConfiguration */
	         __trc__SetRecordingJobConfiguration();
	virtual ~__trc__SetRecordingJobConfiguration() { }
	friend __trc__SetRecordingJobConfiguration *soap_instantiate___trc__SetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64670 */
#ifndef SOAP_TYPE___trc__GetRecordingJobConfiguration
#define SOAP_TYPE___trc__GetRecordingJobConfiguration (3300)
/* Operation wrapper: */
struct __trc__GetRecordingJobConfiguration
{
public:
	_trc__GetRecordingJobConfiguration *trc__GetRecordingJobConfiguration;	/* optional element of XSD type trc:GetRecordingJobConfiguration */
public:
	int soap_type() const { return 3300; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobConfiguration */
	         __trc__GetRecordingJobConfiguration();
	virtual ~__trc__GetRecordingJobConfiguration() { }
	friend __trc__GetRecordingJobConfiguration *soap_instantiate___trc__GetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64741 */
#ifndef SOAP_TYPE___trc__SetRecordingJobMode
#define SOAP_TYPE___trc__SetRecordingJobMode (3304)
/* Operation wrapper: */
struct __trc__SetRecordingJobMode
{
public:
	_trc__SetRecordingJobMode *trc__SetRecordingJobMode;	/* optional element of XSD type trc:SetRecordingJobMode */
public:
	int soap_type() const { return 3304; } /* = unique type id SOAP_TYPE___trc__SetRecordingJobMode */
	         __trc__SetRecordingJobMode();
	virtual ~__trc__SetRecordingJobMode() { }
	friend __trc__SetRecordingJobMode *soap_instantiate___trc__SetRecordingJobMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64810 */
#ifndef SOAP_TYPE___trc__GetRecordingJobState
#define SOAP_TYPE___trc__GetRecordingJobState (3308)
/* Operation wrapper: */
struct __trc__GetRecordingJobState
{
public:
	_trc__GetRecordingJobState *trc__GetRecordingJobState;	/* optional element of XSD type trc:GetRecordingJobState */
public:
	int soap_type() const { return 3308; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobState */
	         __trc__GetRecordingJobState();
	virtual ~__trc__GetRecordingJobState() { }
	friend __trc__GetRecordingJobState *soap_instantiate___trc__GetRecordingJobState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64880 */
#ifndef SOAP_TYPE___trc__ExportRecordedData
#define SOAP_TYPE___trc__ExportRecordedData (3312)
/* Operation wrapper: */
struct __trc__ExportRecordedData
{
public:
	_trc__ExportRecordedData *trc__ExportRecordedData;	/* optional element of XSD type trc:ExportRecordedData */
public:
	int soap_type() const { return 3312; } /* = unique type id SOAP_TYPE___trc__ExportRecordedData */
	         __trc__ExportRecordedData();
	virtual ~__trc__ExportRecordedData() { }
	friend __trc__ExportRecordedData *soap_instantiate___trc__ExportRecordedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64949 */
#ifndef SOAP_TYPE___trc__StopExportRecordedData
#define SOAP_TYPE___trc__StopExportRecordedData (3316)
/* Operation wrapper: */
struct __trc__StopExportRecordedData
{
public:
	_trc__StopExportRecordedData *trc__StopExportRecordedData;	/* optional element of XSD type trc:StopExportRecordedData */
public:
	int soap_type() const { return 3316; } /* = unique type id SOAP_TYPE___trc__StopExportRecordedData */
	         __trc__StopExportRecordedData();
	virtual ~__trc__StopExportRecordedData() { }
	friend __trc__StopExportRecordedData *soap_instantiate___trc__StopExportRecordedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65019 */
#ifndef SOAP_TYPE___trc__GetExportRecordedDataState
#define SOAP_TYPE___trc__GetExportRecordedDataState (3320)
/* Operation wrapper: */
struct __trc__GetExportRecordedDataState
{
public:
	_trc__GetExportRecordedDataState *trc__GetExportRecordedDataState;	/* optional element of XSD type trc:GetExportRecordedDataState */
public:
	int soap_type() const { return 3320; } /* = unique type id SOAP_TYPE___trc__GetExportRecordedDataState */
	         __trc__GetExportRecordedDataState();
	virtual ~__trc__GetExportRecordedDataState() { }
	friend __trc__GetExportRecordedDataState *soap_instantiate___trc__GetExportRecordedDataState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65105 */
#ifndef SOAP_TYPE___trp__GetServiceCapabilities
#define SOAP_TYPE___trp__GetServiceCapabilities (3324)
/* Operation wrapper: */
struct __trp__GetServiceCapabilities
{
public:
	_trp__GetServiceCapabilities *trp__GetServiceCapabilities;	/* optional element of XSD type trp:GetServiceCapabilities */
public:
	int soap_type() const { return 3324; } /* = unique type id SOAP_TYPE___trp__GetServiceCapabilities */
	         __trp__GetServiceCapabilities();
	virtual ~__trp__GetServiceCapabilities() { }
	friend __trp__GetServiceCapabilities *soap_instantiate___trp__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65179 */
#ifndef SOAP_TYPE___trp__GetReplayUri
#define SOAP_TYPE___trp__GetReplayUri (3328)
/* Operation wrapper: */
struct __trp__GetReplayUri
{
public:
	_trp__GetReplayUri *trp__GetReplayUri;	/* optional element of XSD type trp:GetReplayUri */
public:
	int soap_type() const { return 3328; } /* = unique type id SOAP_TYPE___trp__GetReplayUri */
	         __trp__GetReplayUri();
	virtual ~__trp__GetReplayUri() { }
	friend __trp__GetReplayUri *soap_instantiate___trp__GetReplayUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65250 */
#ifndef SOAP_TYPE___trp__GetReplayConfiguration
#define SOAP_TYPE___trp__GetReplayConfiguration (3332)
/* Operation wrapper: */
struct __trp__GetReplayConfiguration
{
public:
	_trp__GetReplayConfiguration *trp__GetReplayConfiguration;	/* optional element of XSD type trp:GetReplayConfiguration */
public:
	int soap_type() const { return 3332; } /* = unique type id SOAP_TYPE___trp__GetReplayConfiguration */
	         __trp__GetReplayConfiguration();
	virtual ~__trp__GetReplayConfiguration() { }
	friend __trp__GetReplayConfiguration *soap_instantiate___trp__GetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65321 */
#ifndef SOAP_TYPE___trp__SetReplayConfiguration
#define SOAP_TYPE___trp__SetReplayConfiguration (3336)
/* Operation wrapper: */
struct __trp__SetReplayConfiguration
{
public:
	_trp__SetReplayConfiguration *trp__SetReplayConfiguration;	/* optional element of XSD type trp:SetReplayConfiguration */
public:
	int soap_type() const { return 3336; } /* = unique type id SOAP_TYPE___trp__SetReplayConfiguration */
	         __trp__SetReplayConfiguration();
	virtual ~__trp__SetReplayConfiguration() { }
	friend __trp__SetReplayConfiguration *soap_instantiate___trp__SetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65407 */
#ifndef SOAP_TYPE___trt__GetServiceCapabilities
#define SOAP_TYPE___trt__GetServiceCapabilities (3340)
/* Operation wrapper: */
struct __trt__GetServiceCapabilities
{
public:
	_trt__GetServiceCapabilities *trt__GetServiceCapabilities;	/* optional element of XSD type trt:GetServiceCapabilities */
public:
	int soap_type() const { return 3340; } /* = unique type id SOAP_TYPE___trt__GetServiceCapabilities */
	         __trt__GetServiceCapabilities();
	virtual ~__trt__GetServiceCapabilities() { }
	friend __trt__GetServiceCapabilities *soap_instantiate___trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65474 */
#ifndef SOAP_TYPE___trt__GetVideoSources
#define SOAP_TYPE___trt__GetVideoSources (3344)
/* Operation wrapper: */
struct __trt__GetVideoSources
{
public:
	_trt__GetVideoSources *trt__GetVideoSources;	/* optional element of XSD type trt:GetVideoSources */
public:
	int soap_type() const { return 3344; } /* = unique type id SOAP_TYPE___trt__GetVideoSources */
	         __trt__GetVideoSources();
	virtual ~__trt__GetVideoSources() { }
	friend __trt__GetVideoSources *soap_instantiate___trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65541 */
#ifndef SOAP_TYPE___trt__GetAudioSources
#define SOAP_TYPE___trt__GetAudioSources (3348)
/* Operation wrapper: */
struct __trt__GetAudioSources
{
public:
	_trt__GetAudioSources *trt__GetAudioSources;	/* optional element of XSD type trt:GetAudioSources */
public:
	int soap_type() const { return 3348; } /* = unique type id SOAP_TYPE___trt__GetAudioSources */
	         __trt__GetAudioSources();
	virtual ~__trt__GetAudioSources() { }
	friend __trt__GetAudioSources *soap_instantiate___trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65608 */
#ifndef SOAP_TYPE___trt__GetAudioOutputs
#define SOAP_TYPE___trt__GetAudioOutputs (3352)
/* Operation wrapper: */
struct __trt__GetAudioOutputs
{
public:
	_trt__GetAudioOutputs *trt__GetAudioOutputs;	/* optional element of XSD type trt:GetAudioOutputs */
public:
	int soap_type() const { return 3352; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputs */
	         __trt__GetAudioOutputs();
	virtual ~__trt__GetAudioOutputs() { }
	friend __trt__GetAudioOutputs *soap_instantiate___trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65679 */
#ifndef SOAP_TYPE___trt__CreateProfile
#define SOAP_TYPE___trt__CreateProfile (3356)
/* Operation wrapper: */
struct __trt__CreateProfile
{
public:
	_trt__CreateProfile *trt__CreateProfile;	/* optional element of XSD type trt:CreateProfile */
public:
	int soap_type() const { return 3356; } /* = unique type id SOAP_TYPE___trt__CreateProfile */
	         __trt__CreateProfile();
	virtual ~__trt__CreateProfile() { }
	friend __trt__CreateProfile *soap_instantiate___trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65747 */
#ifndef SOAP_TYPE___trt__GetProfile
#define SOAP_TYPE___trt__GetProfile (3360)
/* Operation wrapper: */
struct __trt__GetProfile
{
public:
	_trt__GetProfile *trt__GetProfile;	/* optional element of XSD type trt:GetProfile */
public:
	int soap_type() const { return 3360; } /* = unique type id SOAP_TYPE___trt__GetProfile */
	         __trt__GetProfile();
	virtual ~__trt__GetProfile() { }
	friend __trt__GetProfile *soap_instantiate___trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65819 */
#ifndef SOAP_TYPE___trt__GetProfiles
#define SOAP_TYPE___trt__GetProfiles (3364)
/* Operation wrapper: */
struct __trt__GetProfiles
{
public:
	_trt__GetProfiles *trt__GetProfiles;	/* optional element of XSD type trt:GetProfiles */
public:
	int soap_type() const { return 3364; } /* = unique type id SOAP_TYPE___trt__GetProfiles */
	         __trt__GetProfiles();
	virtual ~__trt__GetProfiles() { }
	friend __trt__GetProfiles *soap_instantiate___trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65893 */
#ifndef SOAP_TYPE___trt__AddVideoEncoderConfiguration
#define SOAP_TYPE___trt__AddVideoEncoderConfiguration (3368)
/* Operation wrapper: */
struct __trt__AddVideoEncoderConfiguration
{
public:
	_trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration;	/* optional element of XSD type trt:AddVideoEncoderConfiguration */
public:
	int soap_type() const { return 3368; } /* = unique type id SOAP_TYPE___trt__AddVideoEncoderConfiguration */
	         __trt__AddVideoEncoderConfiguration();
	virtual ~__trt__AddVideoEncoderConfiguration() { }
	friend __trt__AddVideoEncoderConfiguration *soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65963 */
#ifndef SOAP_TYPE___trt__AddVideoSourceConfiguration
#define SOAP_TYPE___trt__AddVideoSourceConfiguration (3372)
/* Operation wrapper: */
struct __trt__AddVideoSourceConfiguration
{
public:
	_trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration;	/* optional element of XSD type trt:AddVideoSourceConfiguration */
public:
	int soap_type() const { return 3372; } /* = unique type id SOAP_TYPE___trt__AddVideoSourceConfiguration */
	         __trt__AddVideoSourceConfiguration();
	virtual ~__trt__AddVideoSourceConfiguration() { }
	friend __trt__AddVideoSourceConfiguration *soap_instantiate___trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66037 */
#ifndef SOAP_TYPE___trt__AddAudioEncoderConfiguration
#define SOAP_TYPE___trt__AddAudioEncoderConfiguration (3376)
/* Operation wrapper: */
struct __trt__AddAudioEncoderConfiguration
{
public:
	_trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration;	/* optional element of XSD type trt:AddAudioEncoderConfiguration */
public:
	int soap_type() const { return 3376; } /* = unique type id SOAP_TYPE___trt__AddAudioEncoderConfiguration */
	         __trt__AddAudioEncoderConfiguration();
	virtual ~__trt__AddAudioEncoderConfiguration() { }
	friend __trt__AddAudioEncoderConfiguration *soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66107 */
#ifndef SOAP_TYPE___trt__AddAudioSourceConfiguration
#define SOAP_TYPE___trt__AddAudioSourceConfiguration (3380)
/* Operation wrapper: */
struct __trt__AddAudioSourceConfiguration
{
public:
	_trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration;	/* optional element of XSD type trt:AddAudioSourceConfiguration */
public:
	int soap_type() const { return 3380; } /* = unique type id SOAP_TYPE___trt__AddAudioSourceConfiguration */
	         __trt__AddAudioSourceConfiguration();
	virtual ~__trt__AddAudioSourceConfiguration() { }
	friend __trt__AddAudioSourceConfiguration *soap_instantiate___trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66181 */
#ifndef SOAP_TYPE___trt__AddPTZConfiguration
#define SOAP_TYPE___trt__AddPTZConfiguration (3384)
/* Operation wrapper: */
struct __trt__AddPTZConfiguration
{
public:
	_trt__AddPTZConfiguration *trt__AddPTZConfiguration;	/* optional element of XSD type trt:AddPTZConfiguration */
public:
	int soap_type() const { return 3384; } /* = unique type id SOAP_TYPE___trt__AddPTZConfiguration */
	         __trt__AddPTZConfiguration();
	virtual ~__trt__AddPTZConfiguration() { }
	friend __trt__AddPTZConfiguration *soap_instantiate___trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66258 */
#ifndef SOAP_TYPE___trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__AddVideoAnalyticsConfiguration (3388)
/* Operation wrapper: */
struct __trt__AddVideoAnalyticsConfiguration
{
public:
	_trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration;	/* optional element of XSD type trt:AddVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3388; } /* = unique type id SOAP_TYPE___trt__AddVideoAnalyticsConfiguration */
	         __trt__AddVideoAnalyticsConfiguration();
	virtual ~__trt__AddVideoAnalyticsConfiguration() { }
	friend __trt__AddVideoAnalyticsConfiguration *soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66329 */
#ifndef SOAP_TYPE___trt__AddMetadataConfiguration
#define SOAP_TYPE___trt__AddMetadataConfiguration (3392)
/* Operation wrapper: */
struct __trt__AddMetadataConfiguration
{
public:
	_trt__AddMetadataConfiguration *trt__AddMetadataConfiguration;	/* optional element of XSD type trt:AddMetadataConfiguration */
public:
	int soap_type() const { return 3392; } /* = unique type id SOAP_TYPE___trt__AddMetadataConfiguration */
	         __trt__AddMetadataConfiguration();
	virtual ~__trt__AddMetadataConfiguration() { }
	friend __trt__AddMetadataConfiguration *soap_instantiate___trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66398 */
#ifndef SOAP_TYPE___trt__AddAudioOutputConfiguration
#define SOAP_TYPE___trt__AddAudioOutputConfiguration (3396)
/* Operation wrapper: */
struct __trt__AddAudioOutputConfiguration
{
public:
	_trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration;	/* optional element of XSD type trt:AddAudioOutputConfiguration */
public:
	int soap_type() const { return 3396; } /* = unique type id SOAP_TYPE___trt__AddAudioOutputConfiguration */
	         __trt__AddAudioOutputConfiguration();
	virtual ~__trt__AddAudioOutputConfiguration() { }
	friend __trt__AddAudioOutputConfiguration *soap_instantiate___trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66467 */
#ifndef SOAP_TYPE___trt__AddAudioDecoderConfiguration
#define SOAP_TYPE___trt__AddAudioDecoderConfiguration (3400)
/* Operation wrapper: */
struct __trt__AddAudioDecoderConfiguration
{
public:
	_trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration;	/* optional element of XSD type trt:AddAudioDecoderConfiguration */
public:
	int soap_type() const { return 3400; } /* = unique type id SOAP_TYPE___trt__AddAudioDecoderConfiguration */
	         __trt__AddAudioDecoderConfiguration();
	virtual ~__trt__AddAudioDecoderConfiguration() { }
	friend __trt__AddAudioDecoderConfiguration *soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66537 */
#ifndef SOAP_TYPE___trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___trt__RemoveVideoEncoderConfiguration (3404)
/* Operation wrapper: */
struct __trt__RemoveVideoEncoderConfiguration
{
public:
	_trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration;	/* optional element of XSD type trt:RemoveVideoEncoderConfiguration */
public:
	int soap_type() const { return 3404; } /* = unique type id SOAP_TYPE___trt__RemoveVideoEncoderConfiguration */
	         __trt__RemoveVideoEncoderConfiguration();
	virtual ~__trt__RemoveVideoEncoderConfiguration() { }
	friend __trt__RemoveVideoEncoderConfiguration *soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66609 */
#ifndef SOAP_TYPE___trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE___trt__RemoveVideoSourceConfiguration (3408)
/* Operation wrapper: */
struct __trt__RemoveVideoSourceConfiguration
{
public:
	_trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration;	/* optional element of XSD type trt:RemoveVideoSourceConfiguration */
public:
	int soap_type() const { return 3408; } /* = unique type id SOAP_TYPE___trt__RemoveVideoSourceConfiguration */
	         __trt__RemoveVideoSourceConfiguration();
	virtual ~__trt__RemoveVideoSourceConfiguration() { }
	friend __trt__RemoveVideoSourceConfiguration *soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66680 */
#ifndef SOAP_TYPE___trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioEncoderConfiguration (3412)
/* Operation wrapper: */
struct __trt__RemoveAudioEncoderConfiguration
{
public:
	_trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration;	/* optional element of XSD type trt:RemoveAudioEncoderConfiguration */
public:
	int soap_type() const { return 3412; } /* = unique type id SOAP_TYPE___trt__RemoveAudioEncoderConfiguration */
	         __trt__RemoveAudioEncoderConfiguration();
	virtual ~__trt__RemoveAudioEncoderConfiguration() { }
	friend __trt__RemoveAudioEncoderConfiguration *soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66753 */
#ifndef SOAP_TYPE___trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE___trt__RemoveAudioSourceConfiguration (3416)
/* Operation wrapper: */
struct __trt__RemoveAudioSourceConfiguration
{
public:
	_trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration;	/* optional element of XSD type trt:RemoveAudioSourceConfiguration */
public:
	int soap_type() const { return 3416; } /* = unique type id SOAP_TYPE___trt__RemoveAudioSourceConfiguration */
	         __trt__RemoveAudioSourceConfiguration();
	virtual ~__trt__RemoveAudioSourceConfiguration() { }
	friend __trt__RemoveAudioSourceConfiguration *soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66823 */
#ifndef SOAP_TYPE___trt__RemovePTZConfiguration
#define SOAP_TYPE___trt__RemovePTZConfiguration (3420)
/* Operation wrapper: */
struct __trt__RemovePTZConfiguration
{
public:
	_trt__RemovePTZConfiguration *trt__RemovePTZConfiguration;	/* optional element of XSD type trt:RemovePTZConfiguration */
public:
	int soap_type() const { return 3420; } /* = unique type id SOAP_TYPE___trt__RemovePTZConfiguration */
	         __trt__RemovePTZConfiguration();
	virtual ~__trt__RemovePTZConfiguration() { }
	friend __trt__RemovePTZConfiguration *soap_instantiate___trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66893 */
#ifndef SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration (3424)
/* Operation wrapper: */
struct __trt__RemoveVideoAnalyticsConfiguration
{
public:
	_trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration;	/* optional element of XSD type trt:RemoveVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3424; } /* = unique type id SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration */
	         __trt__RemoveVideoAnalyticsConfiguration();
	virtual ~__trt__RemoveVideoAnalyticsConfiguration() { }
	friend __trt__RemoveVideoAnalyticsConfiguration *soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66962 */
#ifndef SOAP_TYPE___trt__RemoveMetadataConfiguration
#define SOAP_TYPE___trt__RemoveMetadataConfiguration (3428)
/* Operation wrapper: */
struct __trt__RemoveMetadataConfiguration
{
public:
	_trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration;	/* optional element of XSD type trt:RemoveMetadataConfiguration */
public:
	int soap_type() const { return 3428; } /* = unique type id SOAP_TYPE___trt__RemoveMetadataConfiguration */
	         __trt__RemoveMetadataConfiguration();
	virtual ~__trt__RemoveMetadataConfiguration() { }
	friend __trt__RemoveMetadataConfiguration *soap_instantiate___trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67031 */
#ifndef SOAP_TYPE___trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE___trt__RemoveAudioOutputConfiguration (3432)
/* Operation wrapper: */
struct __trt__RemoveAudioOutputConfiguration
{
public:
	_trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration;	/* optional element of XSD type trt:RemoveAudioOutputConfiguration */
public:
	int soap_type() const { return 3432; } /* = unique type id SOAP_TYPE___trt__RemoveAudioOutputConfiguration */
	         __trt__RemoveAudioOutputConfiguration();
	virtual ~__trt__RemoveAudioOutputConfiguration() { }
	friend __trt__RemoveAudioOutputConfiguration *soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67100 */
#ifndef SOAP_TYPE___trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioDecoderConfiguration (3436)
/* Operation wrapper: */
struct __trt__RemoveAudioDecoderConfiguration
{
public:
	_trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration;	/* optional element of XSD type trt:RemoveAudioDecoderConfiguration */
public:
	int soap_type() const { return 3436; } /* = unique type id SOAP_TYPE___trt__RemoveAudioDecoderConfiguration */
	         __trt__RemoveAudioDecoderConfiguration();
	virtual ~__trt__RemoveAudioDecoderConfiguration() { }
	friend __trt__RemoveAudioDecoderConfiguration *soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67168 */
#ifndef SOAP_TYPE___trt__DeleteProfile
#define SOAP_TYPE___trt__DeleteProfile (3440)
/* Operation wrapper: */
struct __trt__DeleteProfile
{
public:
	_trt__DeleteProfile *trt__DeleteProfile;	/* optional element of XSD type trt:DeleteProfile */
public:
	int soap_type() const { return 3440; } /* = unique type id SOAP_TYPE___trt__DeleteProfile */
	         __trt__DeleteProfile();
	virtual ~__trt__DeleteProfile() { }
	friend __trt__DeleteProfile *soap_instantiate___trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67237 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurations
#define SOAP_TYPE___trt__GetVideoSourceConfigurations (3444)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurations
{
public:
	_trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations;	/* optional element of XSD type trt:GetVideoSourceConfigurations */
public:
	int soap_type() const { return 3444; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurations */
	         __trt__GetVideoSourceConfigurations();
	virtual ~__trt__GetVideoSourceConfigurations() { }
	friend __trt__GetVideoSourceConfigurations *soap_instantiate___trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67307 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetVideoEncoderConfigurations (3448)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurations
{
public:
	_trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations;	/* optional element of XSD type trt:GetVideoEncoderConfigurations */
public:
	int soap_type() const { return 3448; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurations */
	         __trt__GetVideoEncoderConfigurations();
	virtual ~__trt__GetVideoEncoderConfigurations() { }
	friend __trt__GetVideoEncoderConfigurations *soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67377 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurations
#define SOAP_TYPE___trt__GetAudioSourceConfigurations (3452)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurations
{
public:
	_trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations;	/* optional element of XSD type trt:GetAudioSourceConfigurations */
public:
	int soap_type() const { return 3452; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurations */
	         __trt__GetAudioSourceConfigurations();
	virtual ~__trt__GetAudioSourceConfigurations() { }
	friend __trt__GetAudioSourceConfigurations *soap_instantiate___trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67446 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetAudioEncoderConfigurations (3456)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurations
{
public:
	_trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations;	/* optional element of XSD type trt:GetAudioEncoderConfigurations */
public:
	int soap_type() const { return 3456; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurations */
	         __trt__GetAudioEncoderConfigurations();
	virtual ~__trt__GetAudioEncoderConfigurations() { }
	friend __trt__GetAudioEncoderConfigurations *soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67515 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetVideoAnalyticsConfigurations (3460)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfigurations
{
public:
	_trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 3460; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfigurations */
	         __trt__GetVideoAnalyticsConfigurations();
	virtual ~__trt__GetVideoAnalyticsConfigurations() { }
	friend __trt__GetVideoAnalyticsConfigurations *soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67583 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurations
#define SOAP_TYPE___trt__GetMetadataConfigurations (3464)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurations
{
public:
	_trt__GetMetadataConfigurations *trt__GetMetadataConfigurations;	/* optional element of XSD type trt:GetMetadataConfigurations */
public:
	int soap_type() const { return 3464; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurations */
	         __trt__GetMetadataConfigurations();
	virtual ~__trt__GetMetadataConfigurations() { }
	friend __trt__GetMetadataConfigurations *soap_instantiate___trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67651 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurations
#define SOAP_TYPE___trt__GetAudioOutputConfigurations (3468)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurations
{
public:
	_trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations;	/* optional element of XSD type trt:GetAudioOutputConfigurations */
public:
	int soap_type() const { return 3468; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurations */
	         __trt__GetAudioOutputConfigurations();
	virtual ~__trt__GetAudioOutputConfigurations() { }
	friend __trt__GetAudioOutputConfigurations *soap_instantiate___trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67721 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetAudioDecoderConfigurations (3472)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurations
{
public:
	_trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations;	/* optional element of XSD type trt:GetAudioDecoderConfigurations */
public:
	int soap_type() const { return 3472; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurations */
	         __trt__GetAudioDecoderConfigurations();
	virtual ~__trt__GetAudioDecoderConfigurations() { }
	friend __trt__GetAudioDecoderConfigurations *soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67789 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfiguration
#define SOAP_TYPE___trt__GetVideoSourceConfiguration (3476)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfiguration
{
public:
	_trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration;	/* optional element of XSD type trt:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 3476; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfiguration */
	         __trt__GetVideoSourceConfiguration();
	virtual ~__trt__GetVideoSourceConfiguration() { }
	friend __trt__GetVideoSourceConfiguration *soap_instantiate___trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67857 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfiguration
#define SOAP_TYPE___trt__GetVideoEncoderConfiguration (3480)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfiguration
{
public:
	_trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration;	/* optional element of XSD type trt:GetVideoEncoderConfiguration */
public:
	int soap_type() const { return 3480; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfiguration */
	         __trt__GetVideoEncoderConfiguration();
	virtual ~__trt__GetVideoEncoderConfiguration() { }
	friend __trt__GetVideoEncoderConfiguration *soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67925 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfiguration
#define SOAP_TYPE___trt__GetAudioSourceConfiguration (3484)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfiguration
{
public:
	_trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration;	/* optional element of XSD type trt:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 3484; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfiguration */
	         __trt__GetAudioSourceConfiguration();
	virtual ~__trt__GetAudioSourceConfiguration() { }
	friend __trt__GetAudioSourceConfiguration *soap_instantiate___trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:67993 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfiguration
#define SOAP_TYPE___trt__GetAudioEncoderConfiguration (3488)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfiguration
{
public:
	_trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration;	/* optional element of XSD type trt:GetAudioEncoderConfiguration */
public:
	int soap_type() const { return 3488; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfiguration */
	         __trt__GetAudioEncoderConfiguration();
	virtual ~__trt__GetAudioEncoderConfiguration() { }
	friend __trt__GetAudioEncoderConfiguration *soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68061 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__GetVideoAnalyticsConfiguration (3492)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfiguration
{
public:
	_trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:GetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3492; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfiguration */
	         __trt__GetVideoAnalyticsConfiguration();
	virtual ~__trt__GetVideoAnalyticsConfiguration() { }
	friend __trt__GetVideoAnalyticsConfiguration *soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68129 */
#ifndef SOAP_TYPE___trt__GetMetadataConfiguration
#define SOAP_TYPE___trt__GetMetadataConfiguration (3496)
/* Operation wrapper: */
struct __trt__GetMetadataConfiguration
{
public:
	_trt__GetMetadataConfiguration *trt__GetMetadataConfiguration;	/* optional element of XSD type trt:GetMetadataConfiguration */
public:
	int soap_type() const { return 3496; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfiguration */
	         __trt__GetMetadataConfiguration();
	virtual ~__trt__GetMetadataConfiguration() { }
	friend __trt__GetMetadataConfiguration *soap_instantiate___trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68197 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfiguration
#define SOAP_TYPE___trt__GetAudioOutputConfiguration (3500)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfiguration
{
public:
	_trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration;	/* optional element of XSD type trt:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 3500; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfiguration */
	         __trt__GetAudioOutputConfiguration();
	virtual ~__trt__GetAudioOutputConfiguration() { }
	friend __trt__GetAudioOutputConfiguration *soap_instantiate___trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68265 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfiguration
#define SOAP_TYPE___trt__GetAudioDecoderConfiguration (3504)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfiguration
{
public:
	_trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration;	/* optional element of XSD type trt:GetAudioDecoderConfiguration */
public:
	int soap_type() const { return 3504; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfiguration */
	         __trt__GetAudioDecoderConfiguration();
	virtual ~__trt__GetAudioDecoderConfiguration() { }
	friend __trt__GetAudioDecoderConfiguration *soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68336 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations (3508)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoEncoderConfigurations
{
public:
	_trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoEncoderConfigurations */
public:
	int soap_type() const { return 3508; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations */
	         __trt__GetCompatibleVideoEncoderConfigurations();
	virtual ~__trt__GetCompatibleVideoEncoderConfigurations() { }
	friend __trt__GetCompatibleVideoEncoderConfigurations *soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68409 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations (3512)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoSourceConfigurations
{
public:
	_trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoSourceConfigurations */
public:
	int soap_type() const { return 3512; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations */
	         __trt__GetCompatibleVideoSourceConfigurations();
	virtual ~__trt__GetCompatibleVideoSourceConfigurations() { }
	friend __trt__GetCompatibleVideoSourceConfigurations *soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68480 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations (3516)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioEncoderConfigurations
{
public:
	_trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioEncoderConfigurations */
public:
	int soap_type() const { return 3516; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations */
	         __trt__GetCompatibleAudioEncoderConfigurations();
	virtual ~__trt__GetCompatibleAudioEncoderConfigurations() { }
	friend __trt__GetCompatibleAudioEncoderConfigurations *soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68551 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations (3520)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioSourceConfigurations
{
public:
	_trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioSourceConfigurations */
public:
	int soap_type() const { return 3520; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations */
	         __trt__GetCompatibleAudioSourceConfigurations();
	virtual ~__trt__GetCompatibleAudioSourceConfigurations() { }
	friend __trt__GetCompatibleAudioSourceConfigurations *soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68622 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations (3524)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	_trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 3524; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations */
	         __trt__GetCompatibleVideoAnalyticsConfigurations();
	virtual ~__trt__GetCompatibleVideoAnalyticsConfigurations() { }
	friend __trt__GetCompatibleVideoAnalyticsConfigurations *soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68693 */
#ifndef SOAP_TYPE___trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___trt__GetCompatibleMetadataConfigurations (3528)
/* Operation wrapper: */
struct __trt__GetCompatibleMetadataConfigurations
{
public:
	_trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations;	/* optional element of XSD type trt:GetCompatibleMetadataConfigurations */
public:
	int soap_type() const { return 3528; } /* = unique type id SOAP_TYPE___trt__GetCompatibleMetadataConfigurations */
	         __trt__GetCompatibleMetadataConfigurations();
	virtual ~__trt__GetCompatibleMetadataConfigurations() { }
	friend __trt__GetCompatibleMetadataConfigurations *soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68763 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations (3532)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioOutputConfigurations
{
public:
	_trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioOutputConfigurations */
public:
	int soap_type() const { return 3532; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations */
	         __trt__GetCompatibleAudioOutputConfigurations();
	virtual ~__trt__GetCompatibleAudioOutputConfigurations() { }
	friend __trt__GetCompatibleAudioOutputConfigurations *soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68833 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations (3536)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioDecoderConfigurations
{
public:
	_trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioDecoderConfigurations */
public:
	int soap_type() const { return 3536; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations */
	         __trt__GetCompatibleAudioDecoderConfigurations();
	virtual ~__trt__GetCompatibleAudioDecoderConfigurations() { }
	friend __trt__GetCompatibleAudioDecoderConfigurations *soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68905 */
#ifndef SOAP_TYPE___trt__SetVideoSourceConfiguration
#define SOAP_TYPE___trt__SetVideoSourceConfiguration (3540)
/* Operation wrapper: */
struct __trt__SetVideoSourceConfiguration
{
public:
	_trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration;	/* optional element of XSD type trt:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 3540; } /* = unique type id SOAP_TYPE___trt__SetVideoSourceConfiguration */
	         __trt__SetVideoSourceConfiguration();
	virtual ~__trt__SetVideoSourceConfiguration() { }
	friend __trt__SetVideoSourceConfiguration *soap_instantiate___trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:68981 */
#ifndef SOAP_TYPE___trt__SetVideoEncoderConfiguration
#define SOAP_TYPE___trt__SetVideoEncoderConfiguration (3544)
/* Operation wrapper: */
struct __trt__SetVideoEncoderConfiguration
{
public:
	_trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration;	/* optional element of XSD type trt:SetVideoEncoderConfiguration */
public:
	int soap_type() const { return 3544; } /* = unique type id SOAP_TYPE___trt__SetVideoEncoderConfiguration */
	         __trt__SetVideoEncoderConfiguration();
	virtual ~__trt__SetVideoEncoderConfiguration() { }
	friend __trt__SetVideoEncoderConfiguration *soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69055 */
#ifndef SOAP_TYPE___trt__SetAudioSourceConfiguration
#define SOAP_TYPE___trt__SetAudioSourceConfiguration (3548)
/* Operation wrapper: */
struct __trt__SetAudioSourceConfiguration
{
public:
	_trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration;	/* optional element of XSD type trt:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 3548; } /* = unique type id SOAP_TYPE___trt__SetAudioSourceConfiguration */
	         __trt__SetAudioSourceConfiguration();
	virtual ~__trt__SetAudioSourceConfiguration() { }
	friend __trt__SetAudioSourceConfiguration *soap_instantiate___trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69130 */
#ifndef SOAP_TYPE___trt__SetAudioEncoderConfiguration
#define SOAP_TYPE___trt__SetAudioEncoderConfiguration (3552)
/* Operation wrapper: */
struct __trt__SetAudioEncoderConfiguration
{
public:
	_trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration;	/* optional element of XSD type trt:SetAudioEncoderConfiguration */
public:
	int soap_type() const { return 3552; } /* = unique type id SOAP_TYPE___trt__SetAudioEncoderConfiguration */
	         __trt__SetAudioEncoderConfiguration();
	virtual ~__trt__SetAudioEncoderConfiguration() { }
	friend __trt__SetAudioEncoderConfiguration *soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69207 */
#ifndef SOAP_TYPE___trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__SetVideoAnalyticsConfiguration (3556)
/* Operation wrapper: */
struct __trt__SetVideoAnalyticsConfiguration
{
public:
	_trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:SetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3556; } /* = unique type id SOAP_TYPE___trt__SetVideoAnalyticsConfiguration */
	         __trt__SetVideoAnalyticsConfiguration();
	virtual ~__trt__SetVideoAnalyticsConfiguration() { }
	friend __trt__SetVideoAnalyticsConfiguration *soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69283 */
#ifndef SOAP_TYPE___trt__SetMetadataConfiguration
#define SOAP_TYPE___trt__SetMetadataConfiguration (3560)
/* Operation wrapper: */
struct __trt__SetMetadataConfiguration
{
public:
	_trt__SetMetadataConfiguration *trt__SetMetadataConfiguration;	/* optional element of XSD type trt:SetMetadataConfiguration */
public:
	int soap_type() const { return 3560; } /* = unique type id SOAP_TYPE___trt__SetMetadataConfiguration */
	         __trt__SetMetadataConfiguration();
	virtual ~__trt__SetMetadataConfiguration() { }
	friend __trt__SetMetadataConfiguration *soap_instantiate___trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69352 */
#ifndef SOAP_TYPE___trt__SetAudioOutputConfiguration
#define SOAP_TYPE___trt__SetAudioOutputConfiguration (3564)
/* Operation wrapper: */
struct __trt__SetAudioOutputConfiguration
{
public:
	_trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration;	/* optional element of XSD type trt:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 3564; } /* = unique type id SOAP_TYPE___trt__SetAudioOutputConfiguration */
	         __trt__SetAudioOutputConfiguration();
	virtual ~__trt__SetAudioOutputConfiguration() { }
	friend __trt__SetAudioOutputConfiguration *soap_instantiate___trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69421 */
#ifndef SOAP_TYPE___trt__SetAudioDecoderConfiguration
#define SOAP_TYPE___trt__SetAudioDecoderConfiguration (3568)
/* Operation wrapper: */
struct __trt__SetAudioDecoderConfiguration
{
public:
	_trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration;	/* optional element of XSD type trt:SetAudioDecoderConfiguration */
public:
	int soap_type() const { return 3568; } /* = unique type id SOAP_TYPE___trt__SetAudioDecoderConfiguration */
	         __trt__SetAudioDecoderConfiguration();
	virtual ~__trt__SetAudioDecoderConfiguration() { }
	friend __trt__SetAudioDecoderConfiguration *soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69494 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___trt__GetVideoSourceConfigurationOptions (3572)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurationOptions
{
public:
	_trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions;	/* optional element of XSD type trt:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 3572; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurationOptions */
	         __trt__GetVideoSourceConfigurationOptions();
	virtual ~__trt__GetVideoSourceConfigurationOptions() { }
	friend __trt__GetVideoSourceConfigurationOptions *soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69575 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions (3576)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurationOptions
{
public:
	_trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions;	/* optional element of XSD type trt:GetVideoEncoderConfigurationOptions */
public:
	int soap_type() const { return 3576; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions */
	         __trt__GetVideoEncoderConfigurationOptions();
	virtual ~__trt__GetVideoEncoderConfigurationOptions() { }
	friend __trt__GetVideoEncoderConfigurationOptions *soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69648 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___trt__GetAudioSourceConfigurationOptions (3580)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurationOptions
{
public:
	_trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions;	/* optional element of XSD type trt:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 3580; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurationOptions */
	         __trt__GetAudioSourceConfigurationOptions();
	virtual ~__trt__GetAudioSourceConfigurationOptions() { }
	friend __trt__GetAudioSourceConfigurationOptions *soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69717 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions (3584)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurationOptions
{
public:
	_trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioEncoderConfigurationOptions */
public:
	int soap_type() const { return 3584; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions */
	         __trt__GetAudioEncoderConfigurationOptions();
	virtual ~__trt__GetAudioEncoderConfigurationOptions() { }
	friend __trt__GetAudioEncoderConfigurationOptions *soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69785 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurationOptions
#define SOAP_TYPE___trt__GetMetadataConfigurationOptions (3588)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurationOptions
{
public:
	_trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions;	/* optional element of XSD type trt:GetMetadataConfigurationOptions */
public:
	int soap_type() const { return 3588; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurationOptions */
	         __trt__GetMetadataConfigurationOptions();
	virtual ~__trt__GetMetadataConfigurationOptions() { }
	friend __trt__GetMetadataConfigurationOptions *soap_instantiate___trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69853 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___trt__GetAudioOutputConfigurationOptions (3592)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurationOptions
{
public:
	_trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions;	/* optional element of XSD type trt:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 3592; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurationOptions */
	         __trt__GetAudioOutputConfigurationOptions();
	virtual ~__trt__GetAudioOutputConfigurationOptions() { }
	friend __trt__GetAudioOutputConfigurationOptions *soap_instantiate___trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69922 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions (3596)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurationOptions
{
public:
	_trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioDecoderConfigurationOptions */
public:
	int soap_type() const { return 3596; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions */
	         __trt__GetAudioDecoderConfigurationOptions();
	virtual ~__trt__GetAudioDecoderConfigurationOptions() { }
	friend __trt__GetAudioDecoderConfigurationOptions *soap_instantiate___trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:69991 */
#ifndef SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances (3600)
/* Operation wrapper: */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	_trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* optional element of XSD type trt:GetGuaranteedNumberOfVideoEncoderInstances */
public:
	int soap_type() const { return 3600; } /* = unique type id SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances */
	         __trt__GetGuaranteedNumberOfVideoEncoderInstances();
	virtual ~__trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
	friend __trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70082 */
#ifndef SOAP_TYPE___trt__GetStreamUri
#define SOAP_TYPE___trt__GetStreamUri (3604)
/* Operation wrapper: */
struct __trt__GetStreamUri
{
public:
	_trt__GetStreamUri *trt__GetStreamUri;	/* optional element of XSD type trt:GetStreamUri */
public:
	int soap_type() const { return 3604; } /* = unique type id SOAP_TYPE___trt__GetStreamUri */
	         __trt__GetStreamUri();
	virtual ~__trt__GetStreamUri() { }
	friend __trt__GetStreamUri *soap_instantiate___trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70156 */
#ifndef SOAP_TYPE___trt__StartMulticastStreaming
#define SOAP_TYPE___trt__StartMulticastStreaming (3608)
/* Operation wrapper: */
struct __trt__StartMulticastStreaming
{
public:
	_trt__StartMulticastStreaming *trt__StartMulticastStreaming;	/* optional element of XSD type trt:StartMulticastStreaming */
public:
	int soap_type() const { return 3608; } /* = unique type id SOAP_TYPE___trt__StartMulticastStreaming */
	         __trt__StartMulticastStreaming();
	virtual ~__trt__StartMulticastStreaming() { }
	friend __trt__StartMulticastStreaming *soap_instantiate___trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70223 */
#ifndef SOAP_TYPE___trt__StopMulticastStreaming
#define SOAP_TYPE___trt__StopMulticastStreaming (3612)
/* Operation wrapper: */
struct __trt__StopMulticastStreaming
{
public:
	_trt__StopMulticastStreaming *trt__StopMulticastStreaming;	/* optional element of XSD type trt:StopMulticastStreaming */
public:
	int soap_type() const { return 3612; } /* = unique type id SOAP_TYPE___trt__StopMulticastStreaming */
	         __trt__StopMulticastStreaming();
	virtual ~__trt__StopMulticastStreaming() { }
	friend __trt__StopMulticastStreaming *soap_instantiate___trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70307 */
#ifndef SOAP_TYPE___trt__SetSynchronizationPoint
#define SOAP_TYPE___trt__SetSynchronizationPoint (3616)
/* Operation wrapper: */
struct __trt__SetSynchronizationPoint
{
public:
	_trt__SetSynchronizationPoint *trt__SetSynchronizationPoint;	/* optional element of XSD type trt:SetSynchronizationPoint */
public:
	int soap_type() const { return 3616; } /* = unique type id SOAP_TYPE___trt__SetSynchronizationPoint */
	         __trt__SetSynchronizationPoint();
	virtual ~__trt__SetSynchronizationPoint() { }
	friend __trt__SetSynchronizationPoint *soap_instantiate___trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70384 */
#ifndef SOAP_TYPE___trt__GetSnapshotUri
#define SOAP_TYPE___trt__GetSnapshotUri (3620)
/* Operation wrapper: */
struct __trt__GetSnapshotUri
{
public:
	_trt__GetSnapshotUri *trt__GetSnapshotUri;	/* optional element of XSD type trt:GetSnapshotUri */
public:
	int soap_type() const { return 3620; } /* = unique type id SOAP_TYPE___trt__GetSnapshotUri */
	         __trt__GetSnapshotUri();
	virtual ~__trt__GetSnapshotUri() { }
	friend __trt__GetSnapshotUri *soap_instantiate___trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70453 */
#ifndef SOAP_TYPE___trt__GetVideoSourceModes
#define SOAP_TYPE___trt__GetVideoSourceModes (3624)
/* Operation wrapper: */
struct __trt__GetVideoSourceModes
{
public:
	_trt__GetVideoSourceModes *trt__GetVideoSourceModes;	/* optional element of XSD type trt:GetVideoSourceModes */
public:
	int soap_type() const { return 3624; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceModes */
	         __trt__GetVideoSourceModes();
	virtual ~__trt__GetVideoSourceModes() { }
	friend __trt__GetVideoSourceModes *soap_instantiate___trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70523 */
#ifndef SOAP_TYPE___trt__SetVideoSourceMode
#define SOAP_TYPE___trt__SetVideoSourceMode (3628)
/* Operation wrapper: */
struct __trt__SetVideoSourceMode
{
public:
	_trt__SetVideoSourceMode *trt__SetVideoSourceMode;	/* optional element of XSD type trt:SetVideoSourceMode */
public:
	int soap_type() const { return 3628; } /* = unique type id SOAP_TYPE___trt__SetVideoSourceMode */
	         __trt__SetVideoSourceMode();
	virtual ~__trt__SetVideoSourceMode() { }
	friend __trt__SetVideoSourceMode *soap_instantiate___trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70590 */
#ifndef SOAP_TYPE___trt__GetOSDs
#define SOAP_TYPE___trt__GetOSDs (3632)
/* Operation wrapper: */
struct __trt__GetOSDs
{
public:
	_trt__GetOSDs *trt__GetOSDs;	/* optional element of XSD type trt:GetOSDs */
public:
	int soap_type() const { return 3632; } /* = unique type id SOAP_TYPE___trt__GetOSDs */
	         __trt__GetOSDs();
	virtual ~__trt__GetOSDs() { }
	friend __trt__GetOSDs *soap_instantiate___trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70657 */
#ifndef SOAP_TYPE___trt__GetOSD
#define SOAP_TYPE___trt__GetOSD (3636)
/* Operation wrapper: */
struct __trt__GetOSD
{
public:
	_trt__GetOSD *trt__GetOSD;	/* optional element of XSD type trt:GetOSD */
public:
	int soap_type() const { return 3636; } /* = unique type id SOAP_TYPE___trt__GetOSD */
	         __trt__GetOSD();
	virtual ~__trt__GetOSD() { }
	friend __trt__GetOSD *soap_instantiate___trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70724 */
#ifndef SOAP_TYPE___trt__GetOSDOptions
#define SOAP_TYPE___trt__GetOSDOptions (3640)
/* Operation wrapper: */
struct __trt__GetOSDOptions
{
public:
	_trt__GetOSDOptions *trt__GetOSDOptions;	/* optional element of XSD type trt:GetOSDOptions */
public:
	int soap_type() const { return 3640; } /* = unique type id SOAP_TYPE___trt__GetOSDOptions */
	         __trt__GetOSDOptions();
	virtual ~__trt__GetOSDOptions() { }
	friend __trt__GetOSDOptions *soap_instantiate___trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70791 */
#ifndef SOAP_TYPE___trt__SetOSD
#define SOAP_TYPE___trt__SetOSD (3644)
/* Operation wrapper: */
struct __trt__SetOSD
{
public:
	_trt__SetOSD *trt__SetOSD;	/* optional element of XSD type trt:SetOSD */
public:
	int soap_type() const { return 3644; } /* = unique type id SOAP_TYPE___trt__SetOSD */
	         __trt__SetOSD();
	virtual ~__trt__SetOSD() { }
	friend __trt__SetOSD *soap_instantiate___trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70858 */
#ifndef SOAP_TYPE___trt__CreateOSD
#define SOAP_TYPE___trt__CreateOSD (3648)
/* Operation wrapper: */
struct __trt__CreateOSD
{
public:
	_trt__CreateOSD *trt__CreateOSD;	/* optional element of XSD type trt:CreateOSD */
public:
	int soap_type() const { return 3648; } /* = unique type id SOAP_TYPE___trt__CreateOSD */
	         __trt__CreateOSD();
	virtual ~__trt__CreateOSD() { }
	friend __trt__CreateOSD *soap_instantiate___trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:70925 */
#ifndef SOAP_TYPE___trt__DeleteOSD
#define SOAP_TYPE___trt__DeleteOSD (3652)
/* Operation wrapper: */
struct __trt__DeleteOSD
{
public:
	_trt__DeleteOSD *trt__DeleteOSD;	/* optional element of XSD type trt:DeleteOSD */
public:
	int soap_type() const { return 3652; } /* = unique type id SOAP_TYPE___trt__DeleteOSD */
	         __trt__DeleteOSD();
	virtual ~__trt__DeleteOSD() { }
	friend __trt__DeleteOSD *soap_instantiate___trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71011 */
#ifndef SOAP_TYPE___trv__GetServiceCapabilities
#define SOAP_TYPE___trv__GetServiceCapabilities (3656)
/* Operation wrapper: */
struct __trv__GetServiceCapabilities
{
public:
	_trv__GetServiceCapabilities *trv__GetServiceCapabilities;	/* optional element of XSD type trv:GetServiceCapabilities */
public:
	int soap_type() const { return 3656; } /* = unique type id SOAP_TYPE___trv__GetServiceCapabilities */
	         __trv__GetServiceCapabilities();
	virtual ~__trv__GetServiceCapabilities() { }
	friend __trv__GetServiceCapabilities *soap_instantiate___trv__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71081 */
#ifndef SOAP_TYPE___trv__GetReceivers
#define SOAP_TYPE___trv__GetReceivers (3660)
/* Operation wrapper: */
struct __trv__GetReceivers
{
public:
	_trv__GetReceivers *trv__GetReceivers;	/* optional element of XSD type trv:GetReceivers */
public:
	int soap_type() const { return 3660; } /* = unique type id SOAP_TYPE___trv__GetReceivers */
	         __trv__GetReceivers();
	virtual ~__trv__GetReceivers() { }
	friend __trv__GetReceivers *soap_instantiate___trv__GetReceivers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71151 */
#ifndef SOAP_TYPE___trv__GetReceiver
#define SOAP_TYPE___trv__GetReceiver (3664)
/* Operation wrapper: */
struct __trv__GetReceiver
{
public:
	_trv__GetReceiver *trv__GetReceiver;	/* optional element of XSD type trv:GetReceiver */
public:
	int soap_type() const { return 3664; } /* = unique type id SOAP_TYPE___trv__GetReceiver */
	         __trv__GetReceiver();
	virtual ~__trv__GetReceiver() { }
	friend __trv__GetReceiver *soap_instantiate___trv__GetReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71222 */
#ifndef SOAP_TYPE___trv__CreateReceiver
#define SOAP_TYPE___trv__CreateReceiver (3668)
/* Operation wrapper: */
struct __trv__CreateReceiver
{
public:
	_trv__CreateReceiver *trv__CreateReceiver;	/* optional element of XSD type trv:CreateReceiver */
public:
	int soap_type() const { return 3668; } /* = unique type id SOAP_TYPE___trv__CreateReceiver */
	         __trv__CreateReceiver();
	virtual ~__trv__CreateReceiver() { }
	friend __trv__CreateReceiver *soap_instantiate___trv__CreateReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71294 */
#ifndef SOAP_TYPE___trv__DeleteReceiver
#define SOAP_TYPE___trv__DeleteReceiver (3672)
/* Operation wrapper: */
struct __trv__DeleteReceiver
{
public:
	_trv__DeleteReceiver *trv__DeleteReceiver;	/* optional element of XSD type trv:DeleteReceiver */
public:
	int soap_type() const { return 3672; } /* = unique type id SOAP_TYPE___trv__DeleteReceiver */
	         __trv__DeleteReceiver();
	virtual ~__trv__DeleteReceiver() { }
	friend __trv__DeleteReceiver *soap_instantiate___trv__DeleteReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71364 */
#ifndef SOAP_TYPE___trv__ConfigureReceiver
#define SOAP_TYPE___trv__ConfigureReceiver (3676)
/* Operation wrapper: */
struct __trv__ConfigureReceiver
{
public:
	_trv__ConfigureReceiver *trv__ConfigureReceiver;	/* optional element of XSD type trv:ConfigureReceiver */
public:
	int soap_type() const { return 3676; } /* = unique type id SOAP_TYPE___trv__ConfigureReceiver */
	         __trv__ConfigureReceiver();
	virtual ~__trv__ConfigureReceiver() { }
	friend __trv__ConfigureReceiver *soap_instantiate___trv__ConfigureReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71435 */
#ifndef SOAP_TYPE___trv__SetReceiverMode
#define SOAP_TYPE___trv__SetReceiverMode (3680)
/* Operation wrapper: */
struct __trv__SetReceiverMode
{
public:
	_trv__SetReceiverMode *trv__SetReceiverMode;	/* optional element of XSD type trv:SetReceiverMode */
public:
	int soap_type() const { return 3680; } /* = unique type id SOAP_TYPE___trv__SetReceiverMode */
	         __trv__SetReceiverMode();
	virtual ~__trv__SetReceiverMode() { }
	friend __trv__SetReceiverMode *soap_instantiate___trv__SetReceiverMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71507 */
#ifndef SOAP_TYPE___trv__GetReceiverState
#define SOAP_TYPE___trv__GetReceiverState (3684)
/* Operation wrapper: */
struct __trv__GetReceiverState
{
public:
	_trv__GetReceiverState *trv__GetReceiverState;	/* optional element of XSD type trv:GetReceiverState */
public:
	int soap_type() const { return 3684; } /* = unique type id SOAP_TYPE___trv__GetReceiverState */
	         __trv__GetReceiverState();
	virtual ~__trv__GetReceiverState() { }
	friend __trv__GetReceiverState *soap_instantiate___trv__GetReceiverState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71593 */
#ifndef SOAP_TYPE___tse__GetServiceCapabilities
#define SOAP_TYPE___tse__GetServiceCapabilities (3688)
/* Operation wrapper: */
struct __tse__GetServiceCapabilities
{
public:
	_tse__GetServiceCapabilities *tse__GetServiceCapabilities;	/* optional element of XSD type tse:GetServiceCapabilities */
public:
	int soap_type() const { return 3688; } /* = unique type id SOAP_TYPE___tse__GetServiceCapabilities */
	         __tse__GetServiceCapabilities();
	virtual ~__tse__GetServiceCapabilities() { }
	friend __tse__GetServiceCapabilities *soap_instantiate___tse__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71662 */
#ifndef SOAP_TYPE___tse__GetRecordingSummary
#define SOAP_TYPE___tse__GetRecordingSummary (3692)
/* Operation wrapper: */
struct __tse__GetRecordingSummary
{
public:
	_tse__GetRecordingSummary *tse__GetRecordingSummary;	/* optional element of XSD type tse:GetRecordingSummary */
public:
	int soap_type() const { return 3692; } /* = unique type id SOAP_TYPE___tse__GetRecordingSummary */
	         __tse__GetRecordingSummary();
	virtual ~__tse__GetRecordingSummary() { }
	friend __tse__GetRecordingSummary *soap_instantiate___tse__GetRecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71732 */
#ifndef SOAP_TYPE___tse__GetRecordingInformation
#define SOAP_TYPE___tse__GetRecordingInformation (3696)
/* Operation wrapper: */
struct __tse__GetRecordingInformation
{
public:
	_tse__GetRecordingInformation *tse__GetRecordingInformation;	/* optional element of XSD type tse:GetRecordingInformation */
public:
	int soap_type() const { return 3696; } /* = unique type id SOAP_TYPE___tse__GetRecordingInformation */
	         __tse__GetRecordingInformation();
	virtual ~__tse__GetRecordingInformation() { }
	friend __tse__GetRecordingInformation *soap_instantiate___tse__GetRecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71809 */
#ifndef SOAP_TYPE___tse__GetMediaAttributes
#define SOAP_TYPE___tse__GetMediaAttributes (3700)
/* Operation wrapper: */
struct __tse__GetMediaAttributes
{
public:
	_tse__GetMediaAttributes *tse__GetMediaAttributes;	/* optional element of XSD type tse:GetMediaAttributes */
public:
	int soap_type() const { return 3700; } /* = unique type id SOAP_TYPE___tse__GetMediaAttributes */
	         __tse__GetMediaAttributes();
	virtual ~__tse__GetMediaAttributes() { }
	friend __tse__GetMediaAttributes *soap_instantiate___tse__GetMediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71898 */
#ifndef SOAP_TYPE___tse__FindRecordings
#define SOAP_TYPE___tse__FindRecordings (3704)
/* Operation wrapper: */
struct __tse__FindRecordings
{
public:
	_tse__FindRecordings *tse__FindRecordings;	/* optional element of XSD type tse:FindRecordings */
public:
	int soap_type() const { return 3704; } /* = unique type id SOAP_TYPE___tse__FindRecordings */
	         __tse__FindRecordings();
	virtual ~__tse__FindRecordings() { }
	friend __tse__FindRecordings *soap_instantiate___tse__FindRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:71984 */
#ifndef SOAP_TYPE___tse__GetRecordingSearchResults
#define SOAP_TYPE___tse__GetRecordingSearchResults (3708)
/* Operation wrapper: */
struct __tse__GetRecordingSearchResults
{
public:
	_tse__GetRecordingSearchResults *tse__GetRecordingSearchResults;	/* optional element of XSD type tse:GetRecordingSearchResults */
public:
	int soap_type() const { return 3708; } /* = unique type id SOAP_TYPE___tse__GetRecordingSearchResults */
	         __tse__GetRecordingSearchResults();
	virtual ~__tse__GetRecordingSearchResults() { }
	friend __tse__GetRecordingSearchResults *soap_instantiate___tse__GetRecordingSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72075 */
#ifndef SOAP_TYPE___tse__FindEvents
#define SOAP_TYPE___tse__FindEvents (3712)
/* Operation wrapper: */
struct __tse__FindEvents
{
public:
	_tse__FindEvents *tse__FindEvents;	/* optional element of XSD type tse:FindEvents */
public:
	int soap_type() const { return 3712; } /* = unique type id SOAP_TYPE___tse__FindEvents */
	         __tse__FindEvents();
	virtual ~__tse__FindEvents() { }
	friend __tse__FindEvents *soap_instantiate___tse__FindEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72159 */
#ifndef SOAP_TYPE___tse__GetEventSearchResults
#define SOAP_TYPE___tse__GetEventSearchResults (3716)
/* Operation wrapper: */
struct __tse__GetEventSearchResults
{
public:
	_tse__GetEventSearchResults *tse__GetEventSearchResults;	/* optional element of XSD type tse:GetEventSearchResults */
public:
	int soap_type() const { return 3716; } /* = unique type id SOAP_TYPE___tse__GetEventSearchResults */
	         __tse__GetEventSearchResults();
	virtual ~__tse__GetEventSearchResults() { }
	friend __tse__GetEventSearchResults *soap_instantiate___tse__GetEventSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72248 */
#ifndef SOAP_TYPE___tse__FindPTZPosition
#define SOAP_TYPE___tse__FindPTZPosition (3720)
/* Operation wrapper: */
struct __tse__FindPTZPosition
{
public:
	_tse__FindPTZPosition *tse__FindPTZPosition;	/* optional element of XSD type tse:FindPTZPosition */
public:
	int soap_type() const { return 3720; } /* = unique type id SOAP_TYPE___tse__FindPTZPosition */
	         __tse__FindPTZPosition();
	virtual ~__tse__FindPTZPosition() { }
	friend __tse__FindPTZPosition *soap_instantiate___tse__FindPTZPosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72333 */
#ifndef SOAP_TYPE___tse__GetPTZPositionSearchResults
#define SOAP_TYPE___tse__GetPTZPositionSearchResults (3724)
/* Operation wrapper: */
struct __tse__GetPTZPositionSearchResults
{
public:
	_tse__GetPTZPositionSearchResults *tse__GetPTZPositionSearchResults;	/* optional element of XSD type tse:GetPTZPositionSearchResults */
public:
	int soap_type() const { return 3724; } /* = unique type id SOAP_TYPE___tse__GetPTZPositionSearchResults */
	         __tse__GetPTZPositionSearchResults();
	virtual ~__tse__GetPTZPositionSearchResults() { }
	friend __tse__GetPTZPositionSearchResults *soap_instantiate___tse__GetPTZPositionSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72401 */
#ifndef SOAP_TYPE___tse__GetSearchState
#define SOAP_TYPE___tse__GetSearchState (3728)
/* Operation wrapper: */
struct __tse__GetSearchState
{
public:
	_tse__GetSearchState *tse__GetSearchState;	/* optional element of XSD type tse:GetSearchState */
public:
	int soap_type() const { return 3728; } /* = unique type id SOAP_TYPE___tse__GetSearchState */
	         __tse__GetSearchState();
	virtual ~__tse__GetSearchState() { }
	friend __tse__GetSearchState *soap_instantiate___tse__GetSearchState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72483 */
#ifndef SOAP_TYPE___tse__EndSearch
#define SOAP_TYPE___tse__EndSearch (3732)
/* Operation wrapper: */
struct __tse__EndSearch
{
public:
	_tse__EndSearch *tse__EndSearch;	/* optional element of XSD type tse:EndSearch */
public:
	int soap_type() const { return 3732; } /* = unique type id SOAP_TYPE___tse__EndSearch */
	         __tse__EndSearch();
	virtual ~__tse__EndSearch() { }
	friend __tse__EndSearch *soap_instantiate___tse__EndSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72573 */
#ifndef SOAP_TYPE___tse__FindMetadata
#define SOAP_TYPE___tse__FindMetadata (3736)
/* Operation wrapper: */
struct __tse__FindMetadata
{
public:
	_tse__FindMetadata *tse__FindMetadata;	/* optional element of XSD type tse:FindMetadata */
public:
	int soap_type() const { return 3736; } /* = unique type id SOAP_TYPE___tse__FindMetadata */
	         __tse__FindMetadata();
	virtual ~__tse__FindMetadata() { }
	friend __tse__FindMetadata *soap_instantiate___tse__FindMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:72658 */
#ifndef SOAP_TYPE___tse__GetMetadataSearchResults
#define SOAP_TYPE___tse__GetMetadataSearchResults (3740)
/* Operation wrapper: */
struct __tse__GetMetadataSearchResults
{
public:
	_tse__GetMetadataSearchResults *tse__GetMetadataSearchResults;	/* optional element of XSD type tse:GetMetadataSearchResults */
public:
	int soap_type() const { return 3740; } /* = unique type id SOAP_TYPE___tse__GetMetadataSearchResults */
	         __tse__GetMetadataSearchResults();
	virtual ~__tse__GetMetadataSearchResults() { }
	friend __tse__GetMetadataSearchResults *soap_instantiate___tse__GetMetadataSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* onvif.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* onvif.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* ds.h:51 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (29)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:77 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (37)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:91 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (44)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (82)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* wsa5.h:87 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (110)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:90 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (111)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:209 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (117)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:212 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (118)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:215 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (119)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:218 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (120)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:221 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (121)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:224 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (122)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:227 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (123)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:230 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (124)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:233 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (125)
typedef char *_wsa5__To;
#endif

/* wsa5.h:236 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (126)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:239 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (127)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:242 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (128)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:245 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (129)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:248 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (130)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* wsdd.h:99 */
#ifndef SOAP_TYPE_wsdd__QNameListType
#define SOAP_TYPE_wsdd__QNameListType (159)
typedef _QName wsdd__QNameListType;
#endif

/* wsdd.h:102 */
#ifndef SOAP_TYPE_wsdd__UriListType
#define SOAP_TYPE_wsdd__UriListType (160)
typedef char *wsdd__UriListType;
#endif

/* wsdd.h:105 */
#ifndef SOAP_TYPE_wsdd__FaultCodeOpenType
#define SOAP_TYPE_wsdd__FaultCodeOpenType (161)
typedef char *wsdd__FaultCodeOpenType;
#endif

/* onvif.h:270 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (203)
typedef std::string xsd__NCName;
#endif

/* onvif.h:287 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (206)
typedef std::string xsd__anySimpleType;
#endif

/* onvif.h:297 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (208)
typedef std::string xsd__anyURI;
#endif

/* onvif.h:356 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (220)
typedef std::string xsd__integer;
#endif

/* onvif.h:366 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (222)
typedef std::string xsd__nonNegativeInteger;
#endif

/* onvif.h:383 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (225)
typedef std::string xsd__token;
#endif

/* onvif.h:394 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (227)
typedef std::string _xml__lang;
#endif

/* onvif.h:3894 */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (1388)
typedef std::string tds__EAPMethodTypes;
#endif

/* onvif.h:3906 */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (1389)
typedef std::string tt__IntAttrList;
#endif

/* onvif.h:3910 */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (1390)
typedef std::string tt__FloatAttrList;
#endif

/* onvif.h:3914 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (1391)
typedef std::string tt__StringAttrList;
#endif

/* onvif.h:3918 */
#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (1392)
typedef std::string tt__ReferenceTokenList;
#endif

/* onvif.h:3929 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (1393)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* onvif.h:3997 */
#ifndef SOAP_TYPE_tmd__DelayTimes
#define SOAP_TYPE_tmd__DelayTimes (1394)
typedef std::string tmd__DelayTimes;
#endif

/* onvif.h:4020 */
#ifndef SOAP_TYPE_trt__EncodingTypes
#define SOAP_TYPE_trt__EncodingTypes (1395)
typedef std::string trt__EncodingTypes;
#endif

/* onvif.h:4048 */
#ifndef SOAP_TYPE_trc__EncodingTypes
#define SOAP_TYPE_trc__EncodingTypes (1396)
typedef std::string trc__EncodingTypes;
#endif

/* onvif.h:4116 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (1399)
typedef std::string tt__ReferenceToken;
#endif

/* onvif.h:4131 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (1401)
typedef std::string tt__Name;
#endif

/* onvif.h:4373 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (1429)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* onvif.h:4403 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (1433)
typedef int tt__IANA_IfTypes;
#endif

/* onvif.h:4466 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (1441)
typedef xsd__token tt__IPv4Address;
#endif

/* onvif.h:4477 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (1443)
typedef xsd__token tt__IPv6Address;
#endif

/* onvif.h:4488 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (1445)
typedef xsd__token tt__HwAddress;
#endif

/* onvif.h:4515 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (1449)
typedef xsd__token tt__DNSName;
#endif

/* onvif.h:4526 */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (1451)
typedef xsd__token tt__Domain;
#endif

/* onvif.h:4571 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (1457)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* onvif.h:4637 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (1465)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* onvif.h:4649 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (1467)
typedef std::string tt__Dot11PSKPassphrase;
#endif

/* onvif.h:4910 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (1495)
typedef std::string tt__AuxiliaryData;
#endif

/* onvif.h:5199 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (1529)
typedef xsd__anyURI tt__TopicNamespaceLocation;
#endif

/* onvif.h:5329 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (1541)
typedef std::string tt__Description;
#endif

/* onvif.h:5340 */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (1543)
typedef std::string tt__XPathExpression;
#endif

/* onvif.h:5425 */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (1551)
typedef std::string tt__RecordingJobMode;
#endif

/* onvif.h:5436 */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (1553)
typedef std::string tt__RecordingJobState;
#endif

/* onvif.h:5471 */
#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (1557)
typedef std::string tt__AudioClassType;
#endif

/* onvif.h:5527 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (1561)
typedef std::string wstop__FullTopicExpression;
#endif

/* onvif.h:5543 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1563)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/* onvif.h:5558 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (1565)
typedef xsd__QName wstop__SimpleTopicExpression;
#endif

/* onvif.h:5727 */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (1571)
typedef tt__ReferenceToken tt__ReceiverReference;
#endif

/* onvif.h:5738 */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (1573)
typedef tt__ReferenceToken tt__RecordingReference;
#endif

/* onvif.h:5749 */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (1575)
typedef tt__ReferenceToken tt__TrackReference;
#endif

/* onvif.h:5760 */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (1577)
typedef tt__ReferenceToken tt__JobToken;
#endif

/* onvif.h:5771 */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (1579)
typedef tt__ReferenceToken tt__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
